<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/categories/python/</link><description>Recent content in python on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 11 Feb 2022 15:07:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/categories/python/index.xml" rel="self" type="application/rss+xml"/><item><title>AVL树</title><link>https://nnnewb.github.io/blog/p/avl-tree/</link><pubDate>Fri, 11 Feb 2022 15:07:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/avl-tree/</guid><description>前言 还记得很久以前学数据结构只看到二叉树，讲到平衡，但平衡方法当时看纸质书手头也没有实验环境，后来就没继续学下去。现在有闲就重新捡起来学一下。先从AVL树继续看。
AVL树 AVL 树是以提出者名字命名的，Adelson-Velskii &amp;amp; Landis，俄国人，后来移居以色列。人怎么样不管啦。
AVL 树是一种平衡二叉树，左右子树高度差不超过1。保持平衡的方法是每次插入数据的时候发现子树不平衡，就把较高的子树提升为根，把根变成新的根的子树，把较高的子树变矮，较矮的子树变高，实现平衡。这个过程被叫做旋转，下面介绍旋转。
左旋转/右旋转 右旋转
左旋转
左旋转和右旋转的逻辑是一样的。如果右子树比左子树高，就把右子树提升成根。如果左子树比右子树高，就把左子树提升成根。提升右子树叫左旋转，提升左子树叫右旋转。
把子树提升成根会有点麻烦。比如右子树提升为根，原来的根和左子树怎么办？我们并不想重新平衡树的时候把整个左子树都删掉，那原来的根和左子树就必须插回新的树里。
我们知道右子树的 key 肯定比根和左子树所有节点大，所以根要插回树的话，一个很直接的想法就是把旧的根接到右子树左下角的叶子节点。
旧的根插回新根
的确，这样保持了二叉搜索树的特征，但新的树依然不平衡：节点5的左子树高度2，右子树高度0，高度差超过了1。稍微想想就知道，旧的根和左子树直接接到左下角叶子节点的话，会让原本平衡的新树左子树高度增加，进而失去平衡。
解决方法也很简单，不要把旧的树接到新的树最小值上，而是把新树的左子树，移植成旧树的右子树，再把旧树移植成新树的左子树。这样一来，右子树的左子树和左子树的右子树不管怎么旋转，高度都一样。
image-20220211135807095
为什么这样可以保持平衡呢？首先AVL树的子树也是AVL树，所以子树的子树之间高度差也不超过1。左旋转、右旋转的的作用是让子树高度一侧升高，一侧降低——注意，左旋转只能降低右儿子的右子树高度，右儿子的左子树高度不变。右旋转只能降低左儿子的左子树高度，左儿子的右子树高度不变。
举例来说，上图中右儿子的右子树（4-6-7-8）较高，旋转后变成了（6-7-8），而原本的（4-6-5）变成了（6-4-5），高度不变。
这个规律很好理解，因为原来的右子树变成了根，整个右子树剩下的节点高度都降低了。而右子树的左子树变成了现在的左子树的右子树，和根的距离一样，所以高度不变。
左旋转让右子树的右子树高度-1，左子树的左子树高度+1。左子树的右子树高度等于右子树的左子树，旋转后新树的左右子树的高度相等。
双旋转 对于往左儿子的左子树插入节点造成的不平衡，右旋转可以实现降低左儿子的左子树高度，再次平衡。往右儿子的右子树插入节点造成的不平衡，左旋转可以降低右儿子的右子树高度，再次平衡。但对于左儿子的右子树或右儿子的左子树插入节点造成的不平衡，一次左、右旋转无法实现再平衡。
再看一个例子。
image-20220211141652944
旋转前，右儿子的左子树（4-7-6-5）高度是4，旋转后（7-4-6-5）高度不变，依然是4，树仍然不平衡。解决办法也很简单，先把右子树（7）右旋，让右儿子的左子树高度低于右子树，再对整棵树左旋，也就是AVL树的双旋转。
一步一步看双旋转是怎么解决这个问题的。
第一步，右儿子的左子树比右儿子右子树高，所以将右儿子右旋，使得右儿子的右子树高于右儿子的左子树。
image-20220211142847329
我们知道的左旋转时右儿子的左子树高度不变，右儿子的右子树高度-1。这一步前，直接对整棵树左旋时，最高的那颗子树（右儿子的左子树）高度没有变化，树依然不平衡，只是变成了右子树更矮，左子树更高而已。
而这一步之后，最高的子树变成了右子树的右子树。现在对整棵树左旋，右子树的右子树高度下降了，和原本右子树的左子树高度一致，达成平衡。
image-20220211151253277
这个原则简单地说，就是左子树下最高的子树应该是左子树，右子树下最高的子树应该是右子树。如果新增节点后不满足这个条件，就要先对左子树左旋，或者对右子树右旋，来满足这个条件。
代码实现 from typing import Optional class AVLTreeNode: &amp;#34;&amp;#34;&amp;#34;树节点 &amp;#34;&amp;#34;&amp;#34; def __init__(self, value: int, parent: &amp;#39;AVLTreeNode&amp;#39;) -&amp;gt; None: self.value = value self.</description></item><item><title>pattern-match-in-python310</title><link>https://nnnewb.github.io/blog/p/pattern-match-in-python310/</link><pubDate>Fri, 19 Mar 2021 10:19:06 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/pattern-match-in-python310/</guid><description>说明 简单机翻润色一下 PEP-636
概要 这个PEP是PEP 634引入的模式匹配教程。
PEP 622提出了模式匹配的语法，社区和指导委员会对此进行了详细讨论。一个常见的问题是解释(和学习)这个特性是否容易。这个PEP关注的是提供开发人员可以用来学习Python中的模式匹配的文档类型。
PEP 636 被认为是PEP 634(模式匹配的技术规范)和PEP 635(模式匹配的添加动机和理由与设计考虑)的支持材料。
对于想要快速回顾而不是教程的读者，请参阅附录a。
教程 作为本教程的一个例子，你将编写一个文本冒险游戏。这是一种互动小说形式，用户输入文本命令与虚构世界进行互动，并接收关于所发生事情的文本描述。命令将是简化形式的自然语言，如get sword，attack dragon，go north，enter shop或but cheese。
匹配序列 你的主循环将需要从用户那里获取输入，并将它分割成单词，例如一个像这样的字符串列表:
command = input(&amp;#34;What are you doing next? &amp;#34;) # analyze the result of command.split() 下一步是解读这些单词。我们的大多数命令都有两个词:一个动作和一个对象。所以你可能会忍不住这样做:
[action, obj] = command.split() ... # interpret action, obj 这行代码的问题在于它遗漏了一些东西：如果用户输入的单词多于或少于2个单词怎么办?为了防止这个问题，您可以检查单词列表的长度，或者捕获上面的语句将引发的ValueError。
或者，你可以使用match语句来代替:
match command.split(): case [action, obj]: ... # interpret action, obj match语句计算**“subject”**(match关键字后面的值)，并根据模式(case旁边的代码)检查它。一个模式可以做两件不同的事情:
验证 subject 具有一定的结构。在您的示例中，[action, obj]模式匹配任何恰好包含两个元素的序列。这叫做 maching。 它将模式中的一些名称绑定到 subject 的组件元素。在本例中，如果列表有两个元素，它将绑定action = subject[0]和obj = subject[1]。 如果匹配，则case块内的语句将与绑定的变量一起执行。如果没有匹配，则什么也不发生，然后执行match之后的语句。</description></item><item><title>Flask源码阅读笔记：WSGI</title><link>https://nnnewb.github.io/blog/p/flask%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0wsgi/</link><pubDate>Sun, 17 Mar 2019 00:00:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/flask%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0wsgi/</guid><description>0. Intro Flask 是一个基于 WSGI 协议的上层应用框架，据我了解应该是和 Tornado、Django 流行程度相近，当然 Django 老大哥始终占据了最多的份额。Flask 是一个轻量级的 Micro Framework，源码值得一读。
1. 回顾 WSGI 开始之前，需要先回顾以下 WSGI 协议。
WSGI 是一个针对 Python 的协议，故说到的 App、Server、函数、参数等描述都是指 Python 对应的概念或实现。
1.1 PEP-0333 到 PEP-3333 PEP-0333 是初版的 WSGI 协议提案，PEP-3333 是 1.0.1 版本的 WSGI 提案，差别不大，主要是对 py3 和 py2 不兼容的部分作了更新说明（str和unicode方面的问题，python2 的 str 在 python3 是 bytes，故 python3 编写的 wsgi app 必须返回 bytes）。
WSGI 协议规范了 Python Web 应用的两个层级：服务器层（Server）和应用层（Application），两者通过 WSGI 协议进行通信。
其中 Server 负责处理请求，将请求转换成符合 WSGI 要求的模式（environ参数）。 Application 完成处理后再通知 Server 返回 Response（start_response参数）。</description></item><item><title>Django 的各种关系字段详解</title><link>https://nnnewb.github.io/blog/p/django-%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3/</link><pubDate>Wed, 06 Mar 2019 21:11:35 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/django-%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3/</guid><description>参考资料如下
Django 文档 - Model field reference SQLAlchemy 中的级联删除 1. ForeignKey ForeignKey用于多对一关系，直接对应到数据库外键的概念。使用ForeignKey需要指定引用的目标表，会自动关联到目标表的主键（一般是id字段）。
例子如下。
from django.db import models class Child(models.Model): parent = models.ForeignKey(&amp;#39;Parent&amp;#39;, on_delete=models.CASCADE, ) # ... class Parent(models.Model): # ... pass 对比之 sqlalchemy，一行parent=models.ForeignKey(...)包含了 sqlalchemy 中的ForeignKey和relationship两部分内容。
1.1 参数：on_delete on_delete意为当ForeignKey引用的对象被删除时进行的操作。
有几个可以考虑的选项。
1.1.1 models.CASCADE CASCADE意为级联，on_delete设置为CASCADE时意为执行级联删除。依据文档，Django 会模仿 SQL 的ON DELETE CASCADE，对包含了ForeignKey的对象执行删除。
需要注意的是不会调用被级联删除对象上的model.delete()，但是会发送pre_delete和post_delete信号。
1.1.1.2 models.PROTECT PROTECT意为保护，on_delete设置为PROTECT意味着要阻止删除操作发生。删除关联的对象时，ForeignKey的on_delete设置为PROTECT会触发ProtectedError。
1.1.1.3 models.SET_NULL 如其名所述，如果这个ForeignKey是 nullable 的，则关联的对象删除时将外键设置为 null。
1.1.1.4 models.SET_DEFAULT 如其名所述，如果这个ForeignKey设置了DEFAULT，则关联的对象删除时设置这个外键为DEFAULT值。
1.1.1.5 models.SET 在关联的对象删除时，设置为一个指定的值。这个参数可以接受一个可以赋值给这个 ForeignKey 的对象或者一个可调用对象。
官方例子如下。</description></item><item><title>轻量级 django 阅读笔记：最小的 django 应用</title><link>https://nnnewb.github.io/blog/p/%E8%BD%BB%E9%87%8F%E7%BA%A7-django-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%9C%80%E5%B0%8F%E7%9A%84-django-%E5%BA%94%E7%94%A8/</link><pubDate>Sun, 03 Mar 2019 12:26:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E8%BD%BB%E9%87%8F%E7%BA%A7-django-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%9C%80%E5%B0%8F%E7%9A%84-django-%E5%BA%94%E7%94%A8/</guid><description>Intro 找不到工作十分难受，在家看书，恰巧翻到这本《轻量级 Django》，看起来还蛮有意思的，做个读书笔记。
1. 最小的 Django App Django 是个重量级框架，所谓最小指的是写最少的代码，理解一个 Django App 的最小组成元素。
作为开场，先创建一个 app.py 文件，作为整个 Django App 存储的地方。
1.1 django.conf.settings 书中使用 django.core.management.execute_from_command_line 作为启动 Django app 的手段。
execute_from_command_line，就是通过 django startproject的方式创建的manage.py内的主要内容，这种方式启动必须要配置settings才行。
在一个常规方式创建的 Django App 中，settings.py是一个独立的 python 模块，Django通过DJANGO_SETTINGS_MODULE这个环境变量来确定配置信息存储位置。
但是换一种方式，django.conf.settings.configure()可以手动完成配置。
看代码。
from django.conf import settings settings.configure(DEBUG=True, ROOT_URLCONF=__name__, ) 每一个 keyword argument 都和 settings.py这个模块内的名字相同，去除所有不必要的元素之后，剩下的就是DEBUG和ROOT_URLCONF了。
阅读源码可知configure只能被调用一次。
# 摘自 django.conf.settings.configure 源码 # Django 版本号: # VERSION = (2, 1, 7, &amp;#39;final&amp;#39;, 0) def configure(self, default_settings=global_settings, **options): &amp;#34;&amp;#34;&amp;#34; Called to manually configure the settings.</description></item><item><title>sqlalchemy 各种表关系</title><link>https://nnnewb.github.io/blog/p/sqlalchemy-%E5%90%84%E7%A7%8D%E8%A1%A8%E5%85%B3%E7%B3%BB/</link><pubDate>Fri, 01 Mar 2019 15:52:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/sqlalchemy-%E5%90%84%E7%A7%8D%E8%A1%A8%E5%85%B3%E7%B3%BB/</guid><description>注意事项 ForeignKey db.ForeginKey的参数是&amp;lt;表名&amp;gt;.&amp;lt;键名&amp;gt;，而不是&amp;lt;类名&amp;gt;.&amp;lt;字段名&amp;gt;，务必注意这个区别。
back_populates 和 backref 在多对多关系中使用的区别 back_populates是更推荐的写法。
多对多关系中使用backref并指定了secondary的话，另一张表关联的relationship字段会使用相同的secondary。
back_populates则需要在两张表的relationship中都写上相同的secondary中间表。
可调用的 secondary secondary参数可以是一个可调用对象，做一些 trick 的时候应该有用。姑且记下。
一对多关系 class Parent(Base): __tablename__ = &amp;#39;parent&amp;#39; id = Column(Integer, primary_key=True) child = relationship(&amp;#34;Child&amp;#34;, back_populates=&amp;#34;parent&amp;#34;) class Child(Base): __tablename__ = &amp;#39;child&amp;#39; id = Column(Integer, primary_key=True) parent_id = Column(Integer, ForeignKey(&amp;#39;parent.id&amp;#39;)) parent = relationship(&amp;#34;Parent&amp;#34;, back_populates=&amp;#34;child&amp;#34;) parent包含多个child的一对多关系。child里写ForeignKey为parent的主键，child里写relationship，parent里同样写relationship，back_populates填充上，完事。
一对一关系 class Parent(Base): __tablename__ = &amp;#39;parent&amp;#39; id = Column(Integer, primary_key=True) child = relationship(&amp;#34;Child&amp;#34;, uselist=False, back_populates=&amp;#34;parent&amp;#34;) class Child(Base): __tablename__ = &amp;#39;child&amp;#39; id = Column(Integer, primary_key=True) parent_id = Column(Integer, ForeignKey(&amp;#39;parent.</description></item><item><title>利用 descriptor 实现自己的 property</title><link>https://nnnewb.github.io/blog/p/%E5%88%A9%E7%94%A8-descriptor-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84-property/</link><pubDate>Thu, 21 Feb 2019 17:53:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E5%88%A9%E7%94%A8-descriptor-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84-property/</guid><description>1.概念简介 1.1 property 在 python 代码中，property 是非常常见的一个内置函数。property 可以为一个 python 类的 attribute 设置 getter/setter，可以类比之 C# 的 properties。
见下面的例子。
class A: def __init__(self): self.a = 1 @property() def hello(self): return self.a @hello.setter() def hell(self, value): self.a = value print(A().hello) # output: # 1 obj = A() obj.hello = &amp;#34;hello world&amp;#34; print(obj.hello) # output: # hello world 1.2 descriptor python 中的 descriptor 指的是实现了__get__、__set__、__delete__三个方法之一的类。
当一个 descriptor 类的实例作为其他类的成员时，通过obj.attr语法访问该实例将会调用 descriptor 实例的__get__方法。同理，__set__和__delete__也是相似的逻辑。
先看个例子。
class DescriptorClass: def __get__(self, instance, owner): print(self) print(instance) print(owner) return &amp;#39;some value&amp;#39; class SomeClass: some_attr = DescriptorClass() print(SomeClass().</description></item><item><title>python3元类深入解读</title><link>https://nnnewb.github.io/blog/p/python3%E5%85%83%E7%B1%BB%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB/</link><pubDate>Thu, 20 Dec 2018 19:46:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/python3%E5%85%83%E7%B1%BB%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB/</guid><description>0. intro 元类是 python 里被说烂了的一个东西，然而日常用到的地方实在不多，每次想到都得查一下谷歌，想想干脆在博客留个笔记好了。
元类的主要用途是定制类的产生过程，以便于根据类声明包含的信息来创建出不同的类。
1. type 提到元类不得不说一下 python 的类型系统。
python 的 class 也被视作一个对象，定制一个 class 的构造过程其实就和平时在 class 定义里写__init__没啥区别。
python3 里类的类型是type，type又继承自object，object的父类是自己，构成一个奇怪的闭环。其中，type本身是一个特殊的类，他是自己的实例。
graph TB; type --&amp;gt; |inherite|object; type --&amp;gt; |instance-of| type; object --&amp;gt; |instance-of|type; other-cls --&amp;gt; |instance-of| type; other-cls --&amp;gt; |inherite| object; other-cls-instance --&amp;gt; |instance-of|other-cls; type有两种调用方式，一种是最常用的接受一个对象参数，返回该对象的类型，另一种是不怎么常用的，直接创建一个新的类型。
# usage with one argument type(object) # 返回对象的类型，这里返回的是 `type` # usage with three arguments type(name, bases, attr) # 返回新创建的类型 2. meta class 元类语法如下
class MyClass(basecls1, basecls2, metaclass=MetaClass, named1=arg, named2=arg): .</description></item><item><title>python 实现 redis 分布式锁</title><link>https://nnnewb.github.io/blog/p/python-%E5%AE%9E%E7%8E%B0-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link><pubDate>Mon, 17 Dec 2018 14:57:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/python-%E5%AE%9E%E7%8E%B0-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid><description>Intro 分布式不是啥黑魔法，究其理念无非是用多台服务器处理更多的请求。提高每秒处理的数据量，并发就不可避免了。
在单机并发的情况下，我们可以用 mutex，可以用 os 的文件锁，全局锁，多台服务器的并发就需要另一个持有并保护锁的角色了。
概述如何使用 redis 实现一个分布式锁。
为何是 Lua redis 保证了 lua 解释器执行脚本的事务性，即执行结果要么不可见，要么已完成。
参考这篇文档。
简单锁 简单锁指的是简单互斥锁，一旦锁定，则其他锁定请求都必须等待。
加锁 直觉的想法是通过 redis 的键来保持锁，故准备一个用于锁定互斥的名字（比如说 mutex-1）然后指定为键。
直接使用 set 是显然不正确的，如果临界区内程序崩溃或意外断网将导致死锁，所以 setnx 和 expire 是必选项。
加锁需要判断锁的键为空，才能加锁，这两步必须保证原子性，要么都执行，要么一个都不执行。幸好 redis 提供了这方面保证，只要使用 lua 脚本的话。
-- 加锁 if redis.call(&amp;#34;get&amp;#34;, KEYS[1]) == nil then if redis.call(&amp;#34;setnx&amp;#34;, KEYS[1], ARGV[1]) == 1 then redis.call(&amp;#34;expire&amp;#34;, KEYS[1], ARGV[2]) return 1 else return end end 上面的 lua 代码用 python 再封装一层，就是这样
def lock(key, expire): redis.eval( &amp;#39;&amp;#39;&amp;#39; -- 加锁 if redis.</description></item></channel></rss>