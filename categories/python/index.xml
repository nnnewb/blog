<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/categories/python/</link><description>Recent content in python on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 19 Mar 2021 10:19:06 +0000</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/categories/python/index.xml" rel="self" type="application/rss+xml"/><item><title>pattern-match-in-python310</title><link>https://nnnewb.github.io/blog/p/pattern-match-in-python310/</link><pubDate>Fri, 19 Mar 2021 10:19:06 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/pattern-match-in-python310/</guid><description>说明 简单机翻润色一下 PEP-636
概要 这个PEP是PEP 634引入的模式匹配教程。
PEP 622提出了模式匹配的语法，社区和指导委员会对此进行了详细讨论。一个常见的问题是解释(和学习)这个特性是否容易。这个PEP关注的是提供开发人员可以用来学习Python中的模式匹配的文档类型。
PEP 636 被认为是PEP 634(模式匹配的技术规范)和PEP 635(模式匹配的添加动机和理由与设计考虑)的支持材料。
对于想要快速回顾而不是教程的读者，请参阅附录a。
教程 作为本教程的一个例子，你将编写一个文本冒险游戏。这是一种互动小说形式，用户输入文本命令与虚构世界进行互动，并接收关于所发生事情的文本描述。命令将是简化形式的自然语言，如get sword，attack dragon，go north，enter shop或but cheese。
匹配序列 你的主循环将需要从用户那里获取输入，并将它分割成单词，例如一个像这样的字符串列表:
command = input(&amp;#34;What are you doing next? &amp;#34;) # analyze the result of command.split() 下一步是解读这些单词。我们的大多数命令都有两个词:一个动作和一个对象。所以你可能会忍不住这样做:
[action, obj] = command.split() ... # interpret action, obj 这行代码的问题在于它遗漏了一些东西：如果用户输入的单词多于或少于2个单词怎么办?为了防止这个问题，您可以检查单词列表的长度，或者捕获上面的语句将引发的ValueError。
或者，你可以使用match语句来代替:
match command.split(): case [action, obj]: ... # interpret action, obj match语句计算**“subject”**(match关键字后面的值)，并根据模式(case旁边的代码)检查它。一个模式可以做两件不同的事情:
验证 subject 具有一定的结构。在您的示例中，[action, obj]模式匹配任何恰好包含两个元素的序列。这叫做 maching。 它将模式中的一些名称绑定到 subject 的组件元素。在本例中，如果列表有两个元素，它将绑定action = subject[0]和obj = subject[1]。 如果匹配，则case块内的语句将与绑定的变量一起执行。如果没有匹配，则什么也不发生，然后执行match之后的语句。</description></item><item><title>Flask源码阅读笔记：WSGI</title><link>https://nnnewb.github.io/blog/p/flask%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0wsgi/</link><pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/flask%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0wsgi/</guid><description>0. Intro Flask 是一个基于 WSGI 协议的上层应用框架，据我了解应该是和 Tornado、Django 流行程度相近，当然 Django 老大哥始终占据了最多的份额。Flask 是一个轻量级的 Micro Framework，源码值得一读。
1. 回顾 WSGI 开始之前，需要先回顾以下 WSGI 协议。
WSGI 是一个针对 Python 的协议，故说到的 App、Server、函数、参数等描述都是指 Python 对应的概念或实现。
1.1 PEP-0333 到 PEP-3333 PEP-0333 是初版的 WSGI 协议提案，PEP-3333 是 1.0.1 版本的 WSGI 提案，差别不大，主要是对 py3 和 py2 不兼容的部分作了更新说明（str和unicode方面的问题，python2 的 str 在 python3 是 bytes，故 python3 编写的 wsgi app 必须返回 bytes）。
WSGI 协议规范了 Python Web 应用的两个层级：服务器层（Server）和应用层（Application），两者通过 WSGI 协议进行通信。
其中 Server 负责处理请求，将请求转换成符合 WSGI 要求的模式（environ参数）。 Application 完成处理后再通知 Server 返回 Response（start_response参数）。</description></item><item><title>Django 的各种关系字段详解</title><link>https://nnnewb.github.io/blog/p/django-%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3/</link><pubDate>Wed, 06 Mar 2019 21:11:35 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/django-%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3/</guid><description>参考资料如下
Django 文档 - Model field reference SQLAlchemy 中的级联删除 1. ForeignKey ForeignKey用于多对一关系，直接对应到数据库外键的概念。使用ForeignKey需要指定引用的目标表，会自动关联到目标表的主键（一般是id字段）。
例子如下。
from django.db import models class Child(models.Model): parent = models.ForeignKey(&amp;#39;Parent&amp;#39;, on_delete=models.CASCADE, ) # ... class Parent(models.Model): # ... pass 对比之 sqlalchemy，一行parent=models.ForeignKey(...)包含了 sqlalchemy 中的ForeignKey和relationship两部分内容。
1.1 参数：on_delete on_delete意为当ForeignKey引用的对象被删除时进行的操作。
有几个可以考虑的选项。
1.1.1 models.CASCADE CASCADE意为级联，on_delete设置为CASCADE时意为执行级联删除。依据文档，Django 会模仿 SQL 的ON DELETE CASCADE，对包含了ForeignKey的对象执行删除。
需要注意的是不会调用被级联删除对象上的model.delete()，但是会发送pre_delete和post_delete信号。
1.1.1.2 models.PROTECT PROTECT意为保护，on_delete设置为PROTECT意味着要阻止删除操作发生。删除关联的对象时，ForeignKey的on_delete设置为PROTECT会触发ProtectedError。
1.1.1.3 models.SET_NULL 如其名所述，如果这个ForeignKey是 nullable 的，则关联的对象删除时将外键设置为 null。
1.1.1.4 models.SET_DEFAULT 如其名所述，如果这个ForeignKey设置了DEFAULT，则关联的对象删除时设置这个外键为DEFAULT值。
1.1.1.5 models.SET 在关联的对象删除时，设置为一个指定的值。这个参数可以接受一个可以赋值给这个 ForeignKey 的对象或者一个可调用对象。
官方例子如下。</description></item><item><title>轻量级 django 阅读笔记：最小的 django 应用</title><link>https://nnnewb.github.io/blog/p/%E8%BD%BB%E9%87%8F%E7%BA%A7-django-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%9C%80%E5%B0%8F%E7%9A%84-django-%E5%BA%94%E7%94%A8/</link><pubDate>Sun, 03 Mar 2019 12:26:00 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/%E8%BD%BB%E9%87%8F%E7%BA%A7-django-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%9C%80%E5%B0%8F%E7%9A%84-django-%E5%BA%94%E7%94%A8/</guid><description>Intro 找不到工作十分难受，在家看书，恰巧翻到这本《轻量级 Django》，看起来还蛮有意思的，做个读书笔记。
1. 最小的 Django App Django 是个重量级框架，所谓最小指的是写最少的代码，理解一个 Django App 的最小组成元素。
作为开场，先创建一个 app.py 文件，作为整个 Django App 存储的地方。
1.1 django.conf.settings 书中使用 django.core.management.execute_from_command_line 作为启动 Django app 的手段。
execute_from_command_line，就是通过 django startproject的方式创建的manage.py内的主要内容，这种方式启动必须要配置settings才行。
在一个常规方式创建的 Django App 中，settings.py是一个独立的 python 模块，Django通过DJANGO_SETTINGS_MODULE这个环境变量来确定配置信息存储位置。
但是换一种方式，django.conf.settings.configure()可以手动完成配置。
看代码。
from django.conf import settings settings.configure(DEBUG=True, ROOT_URLCONF=__name__, ) 每一个 keyword argument 都和 settings.py这个模块内的名字相同，去除所有不必要的元素之后，剩下的就是DEBUG和ROOT_URLCONF了。
阅读源码可知configure只能被调用一次。
# 摘自 django.conf.settings.configure 源码 # Django 版本号: # VERSION = (2, 1, 7, &amp;#39;final&amp;#39;, 0) def configure(self, default_settings=global_settings, **options): &amp;#34;&amp;#34;&amp;#34; Called to manually configure the settings.</description></item><item><title>sqlalchemy 各种表关系</title><link>https://nnnewb.github.io/blog/p/sqlalchemy-%E5%90%84%E7%A7%8D%E8%A1%A8%E5%85%B3%E7%B3%BB/</link><pubDate>Fri, 01 Mar 2019 15:52:00 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/sqlalchemy-%E5%90%84%E7%A7%8D%E8%A1%A8%E5%85%B3%E7%B3%BB/</guid><description>注意事项 ForeignKey db.ForeginKey的参数是&amp;lt;表名&amp;gt;.&amp;lt;键名&amp;gt;，而不是&amp;lt;类名&amp;gt;.&amp;lt;字段名&amp;gt;，务必注意这个区别。
back_populates 和 backref 在多对多关系中使用的区别 back_populates是更推荐的写法。
多对多关系中使用backref并指定了secondary的话，另一张表关联的relationship字段会使用相同的secondary。
back_populates则需要在两张表的relationship中都写上相同的secondary中间表。
可调用的 secondary secondary参数可以是一个可调用对象，做一些 trick 的时候应该有用。姑且记下。
一对多关系 class Parent(Base): __tablename__ = &amp;#39;parent&amp;#39; id = Column(Integer, primary_key=True) child = relationship(&amp;#34;Child&amp;#34;, back_populates=&amp;#34;parent&amp;#34;) class Child(Base): __tablename__ = &amp;#39;child&amp;#39; id = Column(Integer, primary_key=True) parent_id = Column(Integer, ForeignKey(&amp;#39;parent.id&amp;#39;)) parent = relationship(&amp;#34;Parent&amp;#34;, back_populates=&amp;#34;child&amp;#34;) parent包含多个child的一对多关系。child里写ForeignKey为parent的主键，child里写relationship，parent里同样写relationship，back_populates填充上，完事。
一对一关系 class Parent(Base): __tablename__ = &amp;#39;parent&amp;#39; id = Column(Integer, primary_key=True) child = relationship(&amp;#34;Child&amp;#34;, uselist=False, back_populates=&amp;#34;parent&amp;#34;) class Child(Base): __tablename__ = &amp;#39;child&amp;#39; id = Column(Integer, primary_key=True) parent_id = Column(Integer, ForeignKey(&amp;#39;parent.</description></item><item><title>python3元类深入解读</title><link>https://nnnewb.github.io/blog/p/python3%E5%85%83%E7%B1%BB%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB/</link><pubDate>Thu, 20 Dec 2018 19:46:00 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/python3%E5%85%83%E7%B1%BB%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB/</guid><description>0. intro 元类是 python 里被说烂了的一个东西，然而日常用到的地方实在不多，每次想到都得查一下谷歌，想想干脆在博客留个笔记好了。
元类的主要用途是定制类的产生过程，以便于根据类声明包含的信息来创建出不同的类。
1. type 提到元类不得不说一下 python 的类型系统。
python 的 class 也被视作一个对象，定制一个 class 的构造过程其实就和平时在 class 定义里写__init__没啥区别。
python3 里类的类型是type，type又继承自object，object的父类是自己，构成一个奇怪的闭环。其中，type本身是一个特殊的类，他是自己的实例。
graph TB; type --&amp;gt; |inherite|object; type --&amp;gt; |instance-of| type; object --&amp;gt; |instance-of|type; other-cls --&amp;gt; |instance-of| type; other-cls --&amp;gt; |inherite| object; other-cls-instance --&amp;gt; |instance-of|other-cls; type有两种调用方式，一种是最常用的接受一个对象参数，返回该对象的类型，另一种是不怎么常用的，直接创建一个新的类型。
# usage with one argument type(object) # 返回对象的类型，这里返回的是 `type` # usage with three arguments type(name, bases, attr) # 返回新创建的类型 2. meta class 元类语法如下
class MyClass(basecls1, basecls2, metaclass=MetaClass, named1=arg, named2=arg): .</description></item><item><title>利用 descriptor 实现自己的 property</title><link>https://nnnewb.github.io/blog/p/%E5%88%A9%E7%94%A8-descriptor-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84-property/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/%E5%88%A9%E7%94%A8-descriptor-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84-property/</guid><description>1.概念简介 1.1 property 在 python 代码中，property 是非常常见的一个内置函数。property 可以为一个 python 类的 attribute 设置 getter/setter，可以类比之 C# 的 properties。
见下面的例子。
class A: def __init__(self): self.a = 1 @property() def hello(self): return self.a @hello.setter() def hell(self, value): self.a = value print(A().hello) # output: # 1 obj = A() obj.hello = &amp;#34;hello world&amp;#34; print(obj.hello) # output: # hello world 1.2 descriptor python 中的 descriptor 指的是实现了__get__、__set__、__delete__三个方法之一的类。
当一个 descriptor 类的实例作为其他类的成员时，通过obj.attr语法访问该实例将会调用 descriptor 实例的__get__方法。同理，__set__和__delete__也是相似的逻辑。
先看个例子。
class DescriptorClass: def __get__(self, instance, owner): print(self) print(instance) print(owner) return &amp;#39;some value&amp;#39; class SomeClass: some_attr = DescriptorClass() print(SomeClass().</description></item></channel></rss>