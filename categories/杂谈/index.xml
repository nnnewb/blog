<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>杂谈 on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/categories/%E6%9D%82%E8%B0%88/</link><description>Recent content in 杂谈 on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 21 Apr 2022 10:27:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/categories/%E6%9D%82%E8%B0%88/index.xml" rel="self" type="application/rss+xml"/><item><title>尝鲜keepassxc的ssh集成</title><link>https://nnnewb.github.io/blog/p/keepassxc-ssh-integration/</link><pubDate>Thu, 21 Apr 2022 10:27:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/keepassxc-ssh-integration/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>突发奇想，先前一直把密码存在 keepassxc 里，但 SSH 秘钥是存在 keepassxc 的备注里，用的时候还得先复制出来建个文件，虽然只用折腾一次但还是嫌麻烦。&lt;/p>
&lt;p>于是想到 keepassxc 自带 SSH 集成，于是研究了下怎么用 SSH 集成在 keepassxc 里保存秘钥对，省掉复制出秘钥内容到文件里的过程，还更安全。&lt;/p>
&lt;h2 id="过程">过程&lt;/h2>
&lt;h3 id="平台和选型">平台和选型&lt;/h3>
&lt;p>首先确定 keepassxc 和 ssh 运行的平台，keepassxc 本体是支持 Windows/MacOS/Linux 三端的，ssh 在Windows上倒是有几种不同的选型。&lt;/p>
&lt;p>在 Windows 10 Build 1809 版本之后，Windows 已经内置了 OpenSSH 软件，还在用 PuTTY 的可以省掉 PuTTY 了。&lt;/p>
&lt;p>旧点的 Windows 可以选择 PuTTY 或者装一个基于 MinGW 的 OpenSSH，如 Git-SCM 自带的 OpenSSH 或者 MSYS2、MinGW64 一类。&lt;/p>
&lt;h3 id="原理">原理&lt;/h3>
&lt;p>keepassxc 的 ssh 集成本质是主动往 ssh-agent 添加秘钥，ssh 命令从 ssh-agent 读到秘钥，尝试用秘钥连接服务器。表现出的效果就是和直接把秘钥放在 &lt;code>.ssh/id_rsa&lt;/code> 也没什么区别。&lt;/p>
&lt;p>keepassxc 还支持解锁自动添加和锁定时自动删除，还有超时自动删除，安全性会稍再好一点，可惜 Windows 自带的 OpenSSH 不支持使用秘钥时给用户确认（见 issue &lt;a class="link" href="https://github.com/PowerShell/Win32-OpenSSH/issues/1056" target="_blank" rel="noopener"
>#1056&lt;/a>），导致开启 keepassxc 的确认功能时会添加秘钥失败。&lt;/p>
&lt;p>至于 ssh-agent 的原理就略过不提了，可以理解成一个秘钥代理，ssh 自动问 ssh-agent 有什么秘钥可用，就像保管钥匙的管家。&lt;/p>
&lt;h3 id="配置-openssh">配置 OpenSSH&lt;/h3>
&lt;p>参考 keepassxc 的文档，先启动 Windows 自带的 OpenSSH 的 ssh-agent 服务。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-powershell" data-lang="powershell">&lt;span class="nb">PS &lt;/span>&lt;span class="n">C:&lt;/span>&lt;span class="p">\&lt;/span>&lt;span class="n">Users&lt;/span>&lt;span class="p">\&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nb">Get-Service&lt;/span> &lt;span class="nb">ssh-agent&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="nb">Set-Service&lt;/span> &lt;span class="n">-StartupType&lt;/span> &lt;span class="n">Automatic&lt;/span>
&lt;span class="nb">PS &lt;/span>&lt;span class="n">C:&lt;/span>&lt;span class="p">\&lt;/span>&lt;span class="n">Users&lt;/span>&lt;span class="p">\&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nb">Start-Service&lt;/span> &lt;span class="nb">ssh-agent&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意上面的命令需要 &lt;strong>管理员权限&lt;/strong> 运行。&lt;/p>
&lt;p>就是这样！&lt;/p>
&lt;h3 id="配置-keepassxc">配置 keepassxc&lt;/h3>
&lt;p>之后在 keepassxc 里打开 ssh 集成，选中 OpenSSH 作为代理。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/sshagent-application-settings.png"
width="1601"
height="1218"
srcset="https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/sshagent-application-settings_huf85379ed477f6ac0dbb86a595d8f10b4_56971_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/sshagent-application-settings_huf85379ed477f6ac0dbb86a595d8f10b4_56971_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="sshagent application settings"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="315px"
>&lt;/p>
&lt;p>然后添加一个常规的密码记录，在高级里添加秘钥文件，并在 SSH 里启用：&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/sshagent-entry-settings.png"
width="1758"
height="1374"
srcset="https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/sshagent-entry-settings_huc6b8a73468d62e299570a0a7d6f50725_56080_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/sshagent-entry-settings_huc6b8a73468d62e299570a0a7d6f50725_56080_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="sshagent entry settings"
class="gallery-image"
data-flex-grow="127"
data-flex-basis="307px"
>&lt;/p>
&lt;p>注意勾选 &lt;code>Add key to agent when database is opened/unlocked&lt;/code> 和 &lt;code>Remove key from agent when database is closed/locked&lt;/code>，这两个选项会让 keepassxc 解锁的情况下自动在后台添加 SSH 秘钥到 ssh-agent，同时当你关闭 keepassxc 之后 SSH 就无法再从 ssh-agent 拿到秘钥，体验会更自然。&lt;/p>
&lt;p>如果不勾选这两个选项，也可以手动在设置了 SSH 代理的项目上右击添加到 ssh-agent。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/sshagent-context-menu.png"
width="1758"
height="1265"
srcset="https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/sshagent-context-menu_hu5f860989dfb1f00a09b694a656667942_49439_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/sshagent-context-menu_hu5f860989dfb1f00a09b694a656667942_49439_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="sshagent context menu"
class="gallery-image"
data-flex-grow="138"
data-flex-basis="333px"
>&lt;/p>
&lt;p>这种方式添加到 ssh-agent 的秘钥不会自动从 ssh-agent 删除或自动添加，每次重启都要自己右键添加，比较麻烦。&lt;/p>
&lt;h3 id="检查">检查&lt;/h3>
&lt;p>如何确认配置正确无误？&lt;/p>
&lt;p>可以通过几个方面：&lt;/p>
&lt;ol>
&lt;li>在设置-SSH代理界面，顶部有个绿条，提示 ”SSH代理连接工作正常！“&lt;/li>
&lt;li>在命令行运行&lt;code>ssh-add -l&lt;/code>，会列出你刚添加的秘钥。&lt;/li>
&lt;li>尝试&lt;code>ssh&lt;/code>连接你的服务器，公钥登陆成功。&lt;/li>
&lt;/ol>
&lt;p>如果 “SSH 代理连接工作正常” 没出现的话可能是 ssh-agent 服务没启动或者有问题，可以 &lt;code>stop-service ssh-agent&lt;/code> 停止 &lt;code>ssh-agent&lt;/code> 这个系统服务后再在命令行运行 &lt;code>ssh-agent -d&lt;/code>，输出调试日志，看看具体什么问题。&lt;/p>
&lt;p>如果&lt;code>ssh-add -l&lt;/code>没有输出，也是一样，检查&lt;code>ssh-agent&lt;/code>是否在运行，如果在运行但依然没有，用&lt;code>-d&lt;/code>参数启动 ssh-agent 看看添加秘钥的步骤有什么问题。&lt;/p>
&lt;p>如果 &lt;code>ssh-add -l&lt;/code> 有输出了，但 ssh 连接依然问你要密码，有两种可能：&lt;/p>
&lt;ol>
&lt;li>你的 ssh 秘钥有密码保护，一般是 &lt;code>ssh-keygen&lt;/code> 的时候设置的。&lt;/li>
&lt;li>秘钥被拒绝了。&lt;/li>
&lt;/ol>
&lt;p>有密码保护的秘钥 ssh 命令有提示，注意看 ssh 命令的输出就行。秘钥被拒绝的情况表面很难看出来，可以用 &lt;code>-vvv&lt;/code> 参数再运行 ssh 命令，看命令输出。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/image-20220421101423653.png"
width="1044"
height="157"
srcset="https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/image-20220421101423653_hu955d457efbed342c16ebd2cc7efa854b_176372_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/image-20220421101423653_hu955d457efbed342c16ebd2cc7efa854b_176372_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20220421101423653"
class="gallery-image"
data-flex-grow="664"
data-flex-basis="1595px"
>&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/image-20220421101509008.png"
width="1029"
height="99"
srcset="https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/image-20220421101509008_hufdb8d068113679e23d2947d5c9dd2a58_103423_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/image-20220421101509008_hufdb8d068113679e23d2947d5c9dd2a58_103423_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20220421101509008"
class="gallery-image"
data-flex-grow="1039"
data-flex-basis="2494px"
>&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/image-20220421101612311.png"
width="900"
height="99"
srcset="https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/image-20220421101612311_hu416fe79149793836d529a9d87da9135b_46057_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/keepassxc-ssh-integration/image-20220421101612311_hu416fe79149793836d529a9d87da9135b_46057_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20220421101612311"
class="gallery-image"
data-flex-grow="909"
data-flex-basis="2181px"
>&lt;/p>
&lt;p>如果 &lt;code>will attempt key&lt;/code> 没有出现 &lt;code>ssh-add -l&lt;/code> 列出的秘钥，还可能是因为 &lt;code>.ssh/config&lt;/code> 里，给你要连接的 Host 设置了 &lt;code>IdentitiesOnly yes&lt;/code>。这个设置项会强制 ssh 只使用本地的 &lt;code>.ssh/id_rsa&lt;/code> 等私钥文件。&lt;/p>
&lt;p>另外 &lt;code>.ssh/config&lt;/code> 里可能还指定了别的验证方式也会导致不使用公钥，这就要靠自己检查 &lt;code>.ssh/config&lt;/code> 来排错了。&lt;/p>
&lt;h3 id="配置-git">配置 Git&lt;/h3>
&lt;p>Windows 下还有个坑，在提交博客的时候才发现。 Git-SCM 默认使用的 SSH 命令不是 Windows 自带的 OpenSSH。这会导致 Git 在推送的时候不使用我们添加到 ssh-agent （Windows 自带的 OpenSSH 版 ssh-agent）的秘钥，而是用 Git-SCM 自带的 MinGW 版 OpenSSH，造成推送时提示 &lt;code>Permission Denied (publickey)&lt;/code> 。&lt;/p>
&lt;p>解决办法也很简单，&lt;code>git config --global core.SshCommand &amp;quot;C:/Windows/System32/OpenSSH/ssh.exe&amp;quot;&lt;/code> 把 Windows 自带的 OpenSSH 设置成 Git 默认使用的 ssh 即可。需要注意 &lt;strong>这里的路径用正斜杠&lt;code>/&lt;/code>分隔，不要用反斜杠&lt;code>\&lt;/code>&lt;/strong> 。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>总的来说用 ssh-agent 配合 keepassxc 玩 ssh 还是很舒服的，特别是迁移起来的时候，只要同步和备份 keepassxc 的数据库就完事。&lt;/p>
&lt;p>keepassxc 的附加文件也非常适合把 GPG 之类的秘钥备份起来，换工作机或者自己电脑重装迁移的时候都能省不少心思。&lt;/p></description></item><item><title>2022新年第一篇博客</title><link>https://nnnewb.github.io/blog/p/first-blog-in-2022/</link><pubDate>Wed, 09 Feb 2022 09:24:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/first-blog-in-2022/</guid><description>&lt;h2 id="一">一&lt;/h2>
&lt;p>其实年前还有一篇写了蛮长的，但因为种种原因反正假期内是没继续动笔写完，今天本来打算继续写，但是看了眼开头，还是把全文 ctrl+a delete 了。&lt;/p>
&lt;p>这次就短一点。&lt;/p>
&lt;h2 id="二">二&lt;/h2>
&lt;p>回顾过去，2021年对我而言是怎样的一年？&lt;/p>
&lt;p>当我问自己这个问题，我才发现似乎没有一个能脱口而出的答案。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209093132174.png"
width="870"
height="154"
srcset="https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209093132174_hu312baa1af15bc0284994619b812524f6_3754_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209093132174_hu312baa1af15bc0284994619b812524f6_3754_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20220209093132174"
class="gallery-image"
data-flex-grow="564"
data-flex-basis="1355px"
>&lt;/p>
&lt;p>普普通通地正常工作，顺便也摸摸鱼。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209093249061.png"
width="728"
height="147"
srcset="https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209093249061_huc19f43cf1d7a348ef7c6f534f3f07c4a_8775_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209093249061_huc19f43cf1d7a348ef7c6f534f3f07c4a_8775_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20220209093249061"
class="gallery-image"
data-flex-grow="495"
data-flex-basis="1188px"
>&lt;/p>
&lt;p>偶尔也上GitHub看两眼，有没有什么新鲜玩意儿。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209093447327.png"
width="452"
height="129"
srcset="https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209093447327_hucfe56099574b6d1070a7ba458db01ed2_7134_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209093447327_hucfe56099574b6d1070a7ba458db01ed2_7134_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20220209093447327"
class="gallery-image"
data-flex-grow="350"
data-flex-basis="840px"
>&lt;/p>
&lt;p>学了点没用的逆向技术，demo也勉强凑出9+1个star。不过趁这个机会倒是了解了下x86汇编语言，姑且算是个没什么卵用的进步，主流64位的汇编和arm的汇编还是不懂，x86也只能算是盲人摸象。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209093903198.png"
width="366"
height="123"
srcset="https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209093903198_hu1a597d42e008a51b6b7e3058561fedc4_7207_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209093903198_hu1a597d42e008a51b6b7e3058561fedc4_7207_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20220209093903198"
class="gallery-image"
data-flex-grow="297"
data-flex-basis="714px"
>&lt;/p>
&lt;p>又一个玩具，这类玩具太多了。我水平不够，完成度也低，只能说是写这个的时候就是打发时间。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209094119262.png"
width="256"
height="121"
srcset="https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209094119262_huba5eeb6809b4946e971e1798bbd4c32c_4701_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209094119262_huba5eeb6809b4946e971e1798bbd4c32c_4701_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20220209094119262"
class="gallery-image"
data-flex-grow="211"
data-flex-basis="507px"
>&lt;/p>
&lt;p>本来不是很看得上 dtm 这个项目。不为别的，就是觉得作者 segmentfault 上刷博文宣传自己的框架有种保险推销员的感觉，让人觉得不靠谱。但还是老实去看了代码，毕竟比起 Java 写得 seata 之类的框架，dtm 封装比较薄，源码稍微好读一点。&lt;/p>
&lt;p>实际读起来感觉还是有点混乱，最后照着 dtm 文档的时序图写了个案例，配置了opentelemetry。分布式追踪真的很好用，讲真，要是单体应用也能跟着函数追踪出这样一个图就绝了。我觉得可以拿 python 开刀试试。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209095328828.png"
width="355"
height="131"
srcset="https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209095328828_hu09413e63593e9e88b5002d57426f4aa7_9471_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/first-blog-in-2022/image-20220209095328828_hu09413e63593e9e88b5002d57426f4aa7_9471_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20220209095328828"
class="gallery-image"
data-flex-grow="270"
data-flex-basis="650px"
>&lt;/p>
&lt;p>尝试入门密码学，但数学基础不好，为了搞明白希尔密码用到的矩阵运算翻了半天搜索引擎才写出来。结果还是没继续学下去。2022也许继续看？好歹把传统密码里的DES、AES学完吧，不求能手写，大概能看明白过程就好。要是能再把原理懂个大概就更好了。&lt;/p>
&lt;p>至于别的，也许我能报菜名一样提一大堆名字，但终究骗不了我自己。是，2021一年时间，各种杂七杂八的技术概念和新名词碰了一堆，但杂而不精，几乎没有什么真正吸收、融会贯通的内容。&lt;/p>
&lt;h2 id="三">三&lt;/h2>
&lt;p>工作和生活上还是老一套。&lt;/p>
&lt;p>产品经理走了，于是部门间的矛盾和磨合又来了。我甚至不愿意管这个叫“磨合”，无非是两边一起摆烂罢了。所以还是到此为止，只能期盼好聚好散，2022尝试跳个愿意出更高工资的地方，也许能在中年危机前攒够本钱，下半生是自己做点生意也好，安心打工也好，至少能安顿好一家人，即便不能富足，也得温饱。真心希望这个渺小的愿望可以实现。&lt;/p>
&lt;p>生活上，年底才收到一个坏消息，爷爷病了，可能是肺癌。很难描述听到这个消息的时候我的心情。上初中的时候我的曾祖父去世了，我和曾祖父交流接触很少，但还是有种心里缺了一块的感觉。&lt;/p>
&lt;p>是，人终有一死。但出奇的是我一点也没想什么轻于鸿毛重于泰山。死亡就只是死亡而已，没有意义，什么也没有。时间最终会抚平一切。&lt;/p>
&lt;p>好了。&lt;/p>
&lt;p>2022，还是祝愿爷爷他手术顺利，能活到120岁。&lt;/p>
&lt;h2 id="四">四&lt;/h2>
&lt;p>还是要展望下未来的。&lt;/p>
&lt;p>2022年，很快就要26周岁了，还是单身，一年的收入大概能在广州买一两平米的卫生间，存款不比一间卫生间的价值多多少。有一点焦虑。&lt;/p>
&lt;p>焦虑的原因在于我觉得自己配得上更高的工资，或者说，更好的生活，有看得到希望的未来。但理想和现实的矛盾始终无法解决。&lt;/p>
&lt;p>不说那么多了。&lt;/p>
&lt;p>今年有跳槽的想法，也有考个系统分析师证书的想法，但两者恐怕不好兼顾。还好的是系统分析师考试在5月，这段时间来个百日冲刺，运气好的话有机会拿到证书，再在下半年靠证书跳个更高薪的职位。运气不好的话，今年没考上，下半年跳槽还有悬念，那就明年再说了。&lt;/p>
&lt;p>另外更新简历的时候发现，多写点博客还是挺唬人的。21年下半年几个月写了40篇，2022年继续保持的话起码一年一百篇不过分吧，坚持多写几篇，笔耕不辍。&lt;/p>
&lt;p>最好再参与下知名的开源项目，发几个PR。&lt;/p>
&lt;p>小说也想写，短篇整个十几万字总得有。&lt;/p>
&lt;p>梦想嘛，还是要有的。&lt;/p>
&lt;h2 id="来吧2022">来吧，2022！&lt;/h2></description></item><item><title>记一次API响应时间优化</title><link>https://nnnewb.github.io/blog/p/an-api-response-time-optimize/</link><pubDate>Fri, 31 Dec 2021 18:30:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/an-api-response-time-optimize/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>刚接手管理后台的后端服务，先随便挑个什么东西下手看看。正好注意到一个简单的接口返回时间都蛮长的，于是拿刚从 opentelemetry 的 issue/pr 里抄来的 sqlmw 包装驱动来分析优化下性能。&lt;/p>
&lt;h2 id="0x01-性能分析">0x01 性能分析&lt;/h2>
&lt;h3 id="预判">预判&lt;/h3>
&lt;p>下手前预估下可能存在瓶颈的地方。对于这次下手的接口（&lt;code>get_users&lt;/code>），整个实现也没几行代码，只有两三个查询，数据量也不大，但是耗时有80ms+。&lt;/p>
&lt;p>其他接口有快有慢，并没有表现出同时增加耗时，而且开发服务器架在内网，排除网络原因，大概还是服务本身的存在的问题。于是考虑瓶颈在数据库或代码中，但具体肯定是要看代码去分析的。既然判断是代码里的问题，那下一步就是测量下耗时情况了。&lt;/p>
&lt;p>对于go，&lt;code>pprof&lt;/code>虽然是个不错的主意，但实话说部署在 kubernetes 里，配 &lt;code>pprof&lt;/code> 去拉结果有点麻烦，而且还有点点用不惯。正好这个项目里早就配置了 &lt;code>opentracing&lt;/code>+&lt;code>jaeger&lt;/code>做分布式跟踪，所以就直接抄一下 opentelemetry 的 &lt;a class="link" href="https://github.com/seslattery/otelsql/blob/master/otelsql.go" target="_blank" rel="noopener"
>otelsql&lt;/a> ，把SQL查询的详细耗时情况记录下来，就可以开始分析了。&lt;/p>
&lt;h3 id="opentracing收集数据">opentracing收集数据&lt;/h3>
&lt;p>&lt;code>otelsql&lt;/code> 原理是用 &lt;a class="link" href="https://github.com/ngrok/sqlmw" target="_blank" rel="noopener"
>sqlmw&lt;/a> 在 sql 驱动层级上进行包装&lt;code>sql ==&amp;gt; sqlmw.Driver{mysql.Driver}&lt;/code> 。go的&lt;code>sql&lt;/code>调用&lt;code>sqlmw.Driver&lt;/code>，&lt;code>sqlmw.Driver&lt;/code>调用&lt;code>mysql.Driver&lt;/code>，如此而已，具体不解释。&lt;/p>
&lt;p>从&lt;code>otelsql&lt;/code>借鉴下思路即可，现在 &lt;code>opentracing&lt;/code> 已经和 &lt;code>opencensus&lt;/code> 合并成了 &lt;code>opentelemetry&lt;/code>，但项目也没法说升级就升级，毕竟项目架构设计稀烂，太多地方和 &lt;code>opentracing&lt;/code>、&lt;code>jaeger-client&lt;/code> 强耦合了。把&lt;code>otelsql&lt;/code>里用&lt;code>sqlmw&lt;/code>的部分抄出来，改成&lt;code>opentracing&lt;/code>的方式创建&lt;code>span&lt;/code>完事。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">in&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">sqlInterceptor&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">ConnExecContext&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span> &lt;span class="nx">context&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Context&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">conn&lt;/span> &lt;span class="nx">driver&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ExecerContext&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">query&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">args&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">driver&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">NamedValue&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">driver&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">span&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ctx&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">opentracing&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">StartSpanFromContext&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;ConnExecContext&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">span&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Finish&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nx">span&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">LogKV&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;sql.query&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">query&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">conn&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ExecContext&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ctx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">query&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">args&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如此一来， 当go的&lt;code>sql&lt;/code>库访问数据库的时候，就会在&lt;code>jaeger&lt;/code>里记录一个&lt;code>span&lt;/code>，可以清晰地看到耗时情况。&lt;/p>
&lt;h3 id="分析">分析&lt;/h3>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/an-api-response-time-optimize/image-20211231103911728.png"
width="1166"
height="563"
srcset="https://nnnewb.github.io/blog/blog/p/an-api-response-time-optimize/image-20211231103911728_hu4ca051d63fb418ff00457f384002403d_37132_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/an-api-response-time-optimize/image-20211231103911728_hu4ca051d63fb418ff00457f384002403d_37132_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20211231103911728"
class="gallery-image"
data-flex-grow="207"
data-flex-basis="497px"
>&lt;/p>
&lt;p>收集到耗时情况后开始观察，注意到两个问题：&lt;/p>
&lt;ol>
&lt;li>&lt;code>ConnectorConnect&lt;/code> 在每个请求前出现，每次耗时 2ms 左右。但 &lt;code>sql&lt;/code> 是有连接池的，这里每次执行查询都产生一次连接显然不对劲。&lt;/li>
&lt;li>&lt;code>StmtQueryContext&lt;/code> 出现一个耗时极长的查询，占据接近1/2的请求耗时，这条查询就是主要瓶颈。&lt;/li>
&lt;/ol>
&lt;p>慢查询的SQL如下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">count&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">user&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">role&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">create_timestamp&lt;/span>&lt;span class="o">&amp;gt;?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">create_timestamp&lt;/span>&lt;span class="o">&amp;lt;?&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>是一个简单的 &lt;code>select count(1)&lt;/code> 查询，初步考虑是 &lt;code>where&lt;/code> 里少了索引。&lt;/p>
&lt;h2 id="0x02-优化">0x02 优化&lt;/h2>
&lt;h3 id="索引优化">索引优化&lt;/h3>
&lt;p>既然少索引，那就考虑下加索引。看了下数据库，&lt;code>role&lt;/code>和&lt;code>create_timestamp&lt;/code>字段都没有索引，于是先分别加上了索引，再 &lt;code>explain&lt;/code> ，发现查询类型已经变成了 &lt;code>ref&lt;/code> 。再运行查询，发现耗时依然有 20ms+。&lt;/p>
&lt;p>参考 &lt;a class="link" href="https://dev.mysql.com/doc/refman/5.7/en/multiple-column-indexes.html" target="_blank" rel="noopener"
>multiple-column index&lt;/a> 中的话：&lt;/p>
&lt;blockquote>
&lt;p>MySQL can use multiple-column indexes for queries that test all the columns in the index, or queries that test just the first column, the first two columns, the first three columns, and so on. If you specify the columns in the right order in the index definition, a single composite index can speed up several kinds of queries on the same table.&lt;/p>
&lt;/blockquote>
&lt;p>文档中还说：&lt;/p>
&lt;blockquote>
&lt;p>If a multiple-column index exists on &lt;code>col1&lt;/code> and &lt;code>col2&lt;/code>, the appropriate rows can be fetched directly. If separate single-column indexes exist on &lt;code>col1&lt;/code> and &lt;code>col2&lt;/code>, the optimizer attempts to use the Index Merge optimization (see &lt;a class="link" href="https://dev.mysql.com/doc/refman/5.7/en/index-merge-optimization.html" target="_blank" rel="noopener"
>Section 8.2.1.3, “Index Merge Optimization”&lt;/a>), or attempts to find the most restrictive index by deciding which index excludes more rows and using that index to fetch the rows.&lt;/p>
&lt;/blockquote>
&lt;p>也就是说，如果&lt;code>role&lt;/code>和&lt;code>create_timestamp&lt;/code>分别有索引，&lt;code>mysql&lt;/code>会尝试用 &lt;em>Index Merge Optimization&lt;/em> 算法来优化查询。但如果有多列索引的话，就能直接获取（文档里的场景能直接获取，但上文的 &lt;code>count(1)&lt;/code> 查询应该不行）。&lt;/p>
&lt;p>于是加上多列索引，再&lt;code>explain&lt;/code>，发现查询类型变成了&lt;code>range&lt;/code>，实际执行发现查询耗时降低至 5ms 左右。&lt;/p>
&lt;h3 id="连接池优化">连接池优化&lt;/h3>
&lt;p>go的&lt;code>sql&lt;/code>包自带连接池应该是比较清楚的。原本怀疑是不是对&lt;code>sql.DB&lt;/code>这个结构的用法有问题，但翻了下源码，发现&lt;code>sql.DB.ExecContext&lt;/code>之类的接口都会通过连接池取连接，完成后返回连接池。所以理论上来说都应该走连接池的连接，而不是每次查询都创建——除非连接池里没有可用的连接了。另外也谷歌了一圈，&lt;code>sql.DB&lt;/code> 似乎也没有什么特别的最佳实践，并没有人提到要手动&lt;code>DB.Conn&lt;/code>取连接后自己处理。&lt;/p>
&lt;p>于是初步怀疑下是不是哪里设置了连接池属性出了问题。通过排查源码中设置连接池属性的地方，发现一个自己埋下的坑。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="k">if&lt;/span> &lt;span class="nx">env&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DEBUG&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">mysqldb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">SetMaxIdleConns&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">cfg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">mysql&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ParseDSN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">host&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">cfg&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">mysql&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Config&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nf">StartObverseSQLConnPool&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">cfg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">DBName&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">mysqlDB&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Duration&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Second&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为我司这个项目没有配置 metrics 收集和分析，自然也没收集服务的连接池情况。所以当初入职后遇到一个奇怪的连接池耗尽，服务假死，调用栈全部卡在连接池上的问题时，为了判断是不是出现连接泄露，写了个goroutine去监测连接池里连接获取和释放的情况&amp;hellip;&lt;/p>
&lt;p>为了调试方便，还把&lt;code>SetMaxIdleConns&lt;/code>设置为了0。&lt;/p>
&lt;p>于是初步怀疑就是这个原因导致连接池罢工，将整段调试代码注释掉之后，再次访问接口，响应时间降低至9.8ms。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/an-api-response-time-optimize/image-20211231110219407.png"
width="212"
height="111"
srcset="https://nnnewb.github.io/blog/blog/p/an-api-response-time-optimize/image-20211231110219407_hu55ac2a3a3dacd3b69ab961805df24cc9_3194_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/an-api-response-time-optimize/image-20211231110219407_hu55ac2a3a3dacd3b69ab961805df24cc9_3194_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20211231110219407"
class="gallery-image"
data-flex-grow="190"
data-flex-basis="458px"
>&lt;/p>
&lt;p>最大头的耗时依然是&lt;code>count(1)&lt;/code>查询。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/an-api-response-time-optimize/image-20211231110316414.png"
width="1559"
height="438"
srcset="https://nnnewb.github.io/blog/blog/p/an-api-response-time-optimize/image-20211231110316414_hu2a272a2603430f6072c0c8e118d561d2_28788_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/an-api-response-time-optimize/image-20211231110316414_hu2a272a2603430f6072c0c8e118d561d2_28788_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20211231110316414"
class="gallery-image"
data-flex-grow="355"
data-flex-basis="854px"
>&lt;/p>
&lt;p>默认情况下 IdleConn 只有 2，超时也比较短。实际参数应该根据业务访问情况来安排。我这也没什么好的计算公式。连接池参数有问题会影响单条SQL的基本耗时，请求里三四条查询，每条加上几个ms，整个请求时间就拖长了十几ms。在微服务系统里影响还可能放大，别的服务要是多次调用，积累的时延可能就要上百ms了。&lt;/p>
&lt;h3 id="缓存优化">缓存优化&lt;/h3>
&lt;p>进一步的优化思路就是做缓存。是为了提高服务响应速度，也是为了提高负载能力、减轻查询压力，保护 MySQL 服务。过去年轻无知犯过错，就是考虑性能的时候只关注到了自己写的代码，认为代码跑得快重要——比如把 C 的执行性能吹上天。但事情从来不是这么简单——辩证法说实事求是，要具体问题具体分析。后端从来不是“我的代码”这么简单，如果不能从整个系统的角度出发发现问题，那就算是 CPU 成精了也没辙。&lt;/p>
&lt;p>对于实时性要求不高的接口，将数据缓存一段时间是绝对没问题的。不过因为做缓存是个系统性的事情——要考虑缓存更新的嘛，也不是每个接口都适合缓存，实时性有要求或者查询太复杂的话宁可考虑换成 ES 一类的分布式系统，把压力分摊到更多机器上。当然也意味着要花更多的钱，更难维护。&lt;/p>
&lt;p>我司项目就是个很沙雕的例子，因为最初就没设计缓存，连SQL都在用手工拼接，现在干脆变成了混用 &lt;code>xorm&lt;/code> 和 &lt;code>sql&lt;/code>。虽然也可以考虑下用 &lt;code>sqlmw&lt;/code> 插个缓存，但毕竟没验证过，做第一个吃螃蟹的也意味着要第一个背锅。&lt;/p>
&lt;p>总之，要做那可简单了，直接调 &lt;code>redis&lt;/code> 客户端（已经包装过一个 &lt;code>cachetools&lt;/code>）设置下缓存，给个时限就完了。缓存过期的时候加个 &lt;code>redlock&lt;/code>，让其他客户端先返回旧数据，更新完解锁，所有客户端都返回新数据。&lt;/p>
&lt;p>更系统化的处理，就要考虑下怎么做一个或多个更通用（对业务场景而言更通用，而不是真的对 &lt;em>所有&lt;/em> 场景都通用）的缓存层——在SQL驱动层做缓存？ORM层缓存？在请求/响应中做缓存？业务/数据访问层（如&lt;code>DAO&lt;/code>）做缓存？缓存用什么键？怎么覆盖尽可能多的查询场景？整个重构的工程量如何把握？值不值得？&lt;/p>
&lt;h2 id="结论">结论&lt;/h2>
&lt;p>收集性能数据的主要方式：&lt;/p>
&lt;ul>
&lt;li>metrics&lt;/li>
&lt;li>pprof&lt;/li>
&lt;li>opentracing/opentelemetry&lt;/li>
&lt;/ul>
&lt;p>优化手段：&lt;/p>
&lt;ul>
&lt;li>&lt;code>explain&lt;/code> 分析查询、优化和建立索引&lt;/li>
&lt;li>优化连接池参数&lt;/li>
&lt;li>加缓存&lt;/li>
&lt;/ul>
&lt;p>还有最重要的，&lt;strong>具体问题具体分析&lt;/strong>。&lt;/p></description></item><item><title>一些屁话 2021年11月4日</title><link>https://nnnewb.github.io/blog/p/2021-11-4-diary/</link><pubDate>Thu, 04 Nov 2021 16:06:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/2021-11-4-diary/</guid><description>&lt;h2 id="比烂">比烂&lt;/h2>
&lt;p>不知道什么时候起，对现在的工作失去了激情，连带着对生活也失去了期待。&lt;/p>
&lt;p>上班下班，例行公事，像是个机器人。虽然一直都是这样，从来没有好过。&lt;/p>
&lt;p>似乎也不是——至少在peropero工作的那段时间，还是有些兴奋的。只是确实各方面多少有些合不来，但个人原因还是居多数。毕竟多少已经摸爬滚打了几年下来，一定要说哪个老东家很好或者很差，恐怕都不合适。&lt;/p>
&lt;p>有优点也有缺点是常态，决定能不能持续干下去，最后还是看能不能忍受缺点。&lt;/p>
&lt;p>所以说到底还是比烂，到底万事万物还是比烂。&lt;/p>
&lt;h2 id="做人">做人&lt;/h2>
&lt;p>一个常常出现在脑海里的问题是，我应该做什么样的人？&lt;/p>
&lt;p>然后忽然就有了答案，那就是我不能决定自己成为什么样的人。环境塑造人，经历塑造人，唯独人不能塑造自己，所以说做什么样的人其实是伪命题。&lt;/p>
&lt;p>这么想有些悲观，是机械决定论。人一出生就已经决定了命运，所思所想，悲欢离合，早已经决定，生命就是概率之海的小水花，生或死都没有意义。&lt;/p>
&lt;p>但无论如何吧，至少，还得有一点念想？假装一切都在掌控之中，像是抓住浪潮中的浮木。所以还是得有个什么念想，要做一个什么样的人。&lt;/p>
&lt;p>我怎么想呢。&lt;/p>
&lt;p>做正确的事，也许不正确，也许现在以为是正确，将来又觉得不正确。而即便是这样也做不到。&lt;/p>
&lt;h2 id="时间">时间&lt;/h2>
&lt;p>现在是2021年11月4日，2021年也快要过去了，天气转凉。&lt;/p>
&lt;p>现在总结一年的工作或者生活还有些太早，但如今回头看，这一年也就这样吧。&lt;/p>
&lt;p>事业发展，没有变化。&lt;/p>
&lt;p>人生大事，没有进展。&lt;/p>
&lt;p>健康生活？被痛风折磨，头发肉眼可见地变得稀疏，还好发际线没有太明显的移动。精力虽然有些消退，但并没有什么妨害。&lt;/p>
&lt;p>想要看看还有没有什么提升的机会，发现国家又在教改，成人学历教育明年大概又有什么动作。随便翻了翻招生简章，就看到对25岁以上考生居然有优待。&lt;/p>
&lt;p>再一对自己的，哦豁，不用等明年，今年12月就成了被优待的对象了。&lt;/p>
&lt;p>已经快记不起上学时的光景了，好像所有东西都在飞快地远离。&lt;/p>
&lt;h2 id="变化">变化&lt;/h2>
&lt;p>时间给人带来最明显的变化就是内敛。&lt;/p>
&lt;p>不再轻易喜悦，也不再轻易动怒。&lt;/p>
&lt;p>与其说是沉稳，不如说是更焦虑了，为身边的一切事情焦虑，为自己的能力总是捉襟见肘焦虑。而后又容易放弃，因为总忍不住去对比已知的成本和未知的收益，又或者因为各种内外条件变化而不了了之。&lt;/p>
&lt;p>明知道抱怨没有意义，还是忍不住抱怨，每天都有发泄不完的情绪。&lt;/p>
&lt;h2 id="终">终&lt;/h2>
&lt;p>写了那么多屁话，还是要到这里结束。&lt;/p>
&lt;p>生活还要继续。&lt;/p></description></item><item><title>2021-04-25 无事发生</title><link>https://nnnewb.github.io/blog/p/2021-04-25-%E6%97%A0%E4%BA%8B%E5%8F%91%E7%94%9F/</link><pubDate>Sun, 25 Apr 2021 10:40:30 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/2021-04-25-%E6%97%A0%E4%BA%8B%E5%8F%91%E7%94%9F/</guid><description>&lt;p>4月25日好像也不是什么节日，对我个人来说也没有什么特殊意义。仅仅是普通的一天——如果不算五一调休导致今天明明是周日但还要上班这一点的话。&lt;/p>
&lt;p>想想也挺不可思议的，不知不觉已经到2021年这个在不少科学幻想中的“未来”时代了，光算工作年限，我也干了有四五年的程序了吧。&lt;/p>
&lt;p>从最开始抱着“不写代码还能干啥”到“写代码也挺不错的”，再到现在，“还能写几年代码呢”。&lt;/p>
&lt;p>反思一下这几年，几乎没干出什么成绩，工作一年一换，工作几年下来，也没几个认识、熟悉到可以称之为“朋友”的人。倒不是我孤僻（这么说的人一般都确实孤僻吧），主要是确实没什么主观能动性。&lt;/p>
&lt;p>如今这家公司写写 go，折腾折腾 kubernetes，也算清闲，反倒开始忧心起将来了。&lt;/p>
&lt;p>现在的工作，说好，也就那样。说不好，这个大环境下，但凡没失业，我觉得都算不上不好吧。&lt;/p>
&lt;p>又是疫情，又是新冷战，又是各种各样的奇葩事。当笑话看，看久了也笑不出来了。&lt;/p>
&lt;p>我这人爱看小说，以前也是动画漫画来者不拒，特效大片就饭，总之蛮快乐的。过去还写过同人小说，可惜没得家里支持，最后也就是40万字左右就切了。&lt;/p>
&lt;p>不过起码这段经历算是给我找第一份码农工作加了点助力（大概）。自从开始写代码拿工资，好像写小说这回事就和我没什么关系了的样子。&lt;/p>
&lt;p>不过我还是一直想写的，几乎每次换工作，心里想的都是空闲的时间多了，就会用来做点有意义的事情。比如学学钢琴啊（买了电钢琴吃灰中），比如写写小说啊（也就开了个头），比如学点新技术啊（有倒是有，新工作新技术栈），总之就是自我提升下。&lt;/p>
&lt;p>结果当然是没有的。&lt;/p>
&lt;p>好像从前读书的时候捧着本 C Primer Plus/C++ Primer 看的激情已经完全从身体里消失了一样。不管是什么事情，虽然总是想到，啊，这个想要，那个想要。但一到行动，就完全没了动力。“做了也没用”，“学了也是浪费时间”这种想法就从脑子里冒出来了。&lt;/p>
&lt;p>不能说和家庭完全没关系——但把责任都推给父母、老师，大概也不合适。&lt;/p>
&lt;p>我是相信环境会改变人的，当然人也能发挥主观能动性，改造环境。像是叶子随波逐流进了下水道，不能说是水有错，也不能怪叶子没有奋力闪躲，秋风更是无辜。于是环视四周，最后悲哀地发现只能感叹一句命运无常。&lt;/p>
&lt;p>诸如未来可以改变之类的鸡汤喝了又喝，脑子也有了抗性，不切实际的期待也越来越少，然后发现即使是切实可行的期待也开始落向不切实际的一侧。&lt;/p>
&lt;p>那便不想未来了吧。俗话说，“把握当下”。于是便来上班，对着屏幕，无事可做，等待 call of work。&lt;/p>
&lt;p>那便是这样了吧。&lt;/p>
&lt;p>2021年4月25日，无事发生。&lt;/p></description></item><item><title>关于笔记的考虑</title><link>https://nnnewb.github.io/blog/p/%E5%85%B3%E4%BA%8E%E7%AC%94%E8%AE%B0%E7%9A%84%E8%80%83%E8%99%91/</link><pubDate>Sun, 16 Dec 2018 23:30:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E5%85%B3%E4%BA%8E%E7%AC%94%E8%AE%B0%E7%9A%84%E8%80%83%E8%99%91/</guid><description>&lt;p>使用了两年多的 One Note，但是 One Note 对代码的支持实在是难受，于是数次折腾之后最终还是选择再找个更合适的笔记工具。&lt;/p>
&lt;p>在知乎上搜了一圈之后，大多数笔记工具收费且不论，最严重的问题反而是对笔记能否生存下去的怀疑。&lt;/p>
&lt;p>大多笔记工具用私有格式来处理富文本（比如可用样式排版有限的 HTML），或者其他奇奇怪怪的格式。且不说这些东西导出来怎么办&amp;hellip;..把笔记多地备份本身就够难受了。&lt;/p>
&lt;p>再者，笔记这玩意儿记了自己都不一定看。偶尔想起来翻一下，还要怀疑自己当初写的什么狗屁玩意儿。&lt;/p>
&lt;p>所以经过这么多考虑&amp;hellip;&amp;hellip;还是直接搭个博客最自由且不会太担心保存的问题了。&lt;/p>
&lt;p>比较别的笔记工具可能密码忘了或长时间不登陆，git 天天用（这里应有自嘲），根本离不开。&lt;/p>
&lt;p>所以想了想，还是转移笔记到博客好了。写笔记可能很随便，写博客总要考据两下的。再说，还可以自定义页面效果，对我这种喜欢折腾的人还是蛮对胃口的。&lt;/p>
&lt;p>总而言之，先挂上去了，就这样。&lt;/p></description></item></channel></rss>