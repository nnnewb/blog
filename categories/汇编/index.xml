<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>汇编 on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/categories/%E6%B1%87%E7%BC%96/</link><description>Recent content in 汇编 on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 13 Oct 2021 11:05:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/categories/%E6%B1%87%E7%BC%96/index.xml" rel="self" type="application/rss+xml"/><item><title>nasm汇编手写个PE可执行文件</title><link>https://nnnewb.github.io/blog/p/hand-write-pe-file-with-nasm-assembly/</link><pubDate>Wed, 13 Oct 2021 11:05:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/hand-write-pe-file-with-nasm-assembly/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>主要是虽然有个汇编器 nasm 但是不知道怎么用，啥汇编都是调试器里纸上谈兵。最近碰到个问题，MinGW 可以用参数 &lt;code>-Wl,section-start=&lt;/code> 来修改 section 地址，但 &lt;em>msvc&lt;/em> 没有对应物，就蛋疼。手动改 PE 来添加 section 好像可行，但不知道该怎么做，lief 也不熟悉。&lt;/p>
&lt;p>正好瞎谷歌的时候发现 nasm 可以直接编译出 PE 文件，这就听起来很有意思了。汇编嘛，听着就很底层，很自由，改个 Section 地址不是手到擒来。于是就学学看。&lt;/p>
&lt;p>参考文章附于文末。&lt;/p>
&lt;h2 id="0x01-nasm-基本用法">0x01 nasm 基本用法&lt;/h2>
&lt;h3 id="11-label">1.1 label&lt;/h3>
&lt;p>汇编当然有经典的 &lt;em>label&lt;/em> 和 &lt;em>instruction&lt;/em> 了，&lt;em>instruction&lt;/em> 的参数就叫 &lt;em>operand&lt;/em> 。&lt;/p>
&lt;p>nasm 的 label 语法很简单，任何不是宏和 &lt;em>instruction&lt;/em> 或者伪指令的东西，出现在行首，都会被认作 label。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="nl">lbl1:&lt;/span> &lt;span class="c">; 这是label
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="nf">sub&lt;/span> &lt;span class="no">esp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="no">h&lt;/span>
&lt;span class="nf">jmp&lt;/span> &lt;span class="no">lbl&lt;/span>
&lt;span class="nf">lbl2&lt;/span> &lt;span class="c">; 这也是 label
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">sub&lt;/span> &lt;span class="no">esp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="no">h&lt;/span>
&lt;span class="nf">lbl3&lt;/span> &lt;span class="no">db&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="c">; 这还是 label
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="no">.label4&lt;/span> &lt;span class="c">; 这是本地 label，可以用 .label4 或者全称 lbl3.label4 访问
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="no">.@label5&lt;/span> &lt;span class="c">; 这是特殊 label ，只能在宏里使用，避免干扰本地label
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>label 可以被视作一个数字参与运算，比如说 &lt;code>lbl3-lbl2&lt;/code> 这样算出偏移。或者还可以参数伪指令计算。总之用处很多。&lt;/p>
&lt;h3 id="12-伪指令">1.2 伪指令&lt;/h3>
&lt;p>伪指令是一些并不是真正的 x86 机器指令，但还是被用在了 instruction 域中的指 令，因为使用它们可以带来很大的方便。当前的伪指令有&lt;code>DB&lt;/code>,&lt;code>DW&lt;/code>,&lt;code>DD&lt;/code>,&lt;code>DQ&lt;/code>和 &lt;code>DT&lt;/code>，它们对应的未初始化指令是 &lt;code>RESB&lt;/code>, &lt;code>RESW&lt;/code>,&lt;code> RESD&lt;/code>,&lt;code> RESQ&lt;/code> 和 &lt;code>REST&lt;/code>，&lt;code>INCBIN&lt;/code> 命令，&lt;code>EQU&lt;/code> 命令和 &lt;code>TIEMS&lt;/code> 前缀。&lt;/p>
&lt;p>不复制粘贴了，看文档好吧。&lt;/p>
&lt;h3 id="12-有效地址">1.2 有效地址&lt;/h3>
&lt;p>有效地址是指令的操作数，是对内存的引用。nasm中有效地址的语法非常简单：由一个可计算表达式组成，放在中括号内。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="nl">wordvar:&lt;/span>
&lt;span class="nf">dw&lt;/span> &lt;span class="mi">123&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="no">ax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">wordvar&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c">; [wordvar] 就是取 dw 123 的首地址
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">mov&lt;/span> &lt;span class="no">ax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">wordvar&lt;/span>&lt;span class="err">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c">; wordvar+1 label 参与算术运算，取 dw 123 地址 + 1字节
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">mov&lt;/span> &lt;span class="no">ax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">es&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="no">wordvar&lt;/span>&lt;span class="err">+&lt;/span>&lt;span class="no">bx&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c">; 加上段选择子，寄存器参与运算
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>与上例不一致的表达式都不是 nasm 的有效地址，比如 &lt;code>es:wordvar[bx]&lt;/code> 。&lt;/p>
&lt;p>还可以用 &lt;code>BYTE&lt;/code> &lt;code>WORD&lt;/code> &lt;code>DWORD&lt;/code> &lt;code>NOSPLIT&lt;/code> 等关键字强迫 nasm 产生特定形式的有效地址。比如 &lt;code>[dword eax+3]&lt;/code> 。&lt;/p>
&lt;p>详细还是看文档。&lt;/p>
&lt;h3 id="13-常数">1.3 常数&lt;/h3>
&lt;p>支持的常数类型包括：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>数值&lt;/p>
&lt;ul>
&lt;li>&lt;code>100&lt;/code> 10进制&lt;/li>
&lt;li>&lt;code>100h&lt;/code> 16进制，&lt;code>h&lt;/code>结尾&lt;/li>
&lt;li>&lt;code>0x100&lt;/code> 16进制，&lt;code>0x&lt;/code>开头&lt;/li>
&lt;li>&lt;code>$0100&lt;/code> 16进制，&lt;code>$0&lt;/code>开头&lt;/li>
&lt;li>&lt;code>777q&lt;/code> 8进制，&lt;code>q&lt;/code>结尾&lt;/li>
&lt;li>&lt;code>10010011b&lt;/code> 2进制，&lt;code>b&lt;/code>结尾&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>字符&lt;/p>
&lt;ul>
&lt;li>&lt;code>abcd&lt;/code> 字符型常数，小端序&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>字符串&lt;/p>
&lt;ul>
&lt;li>一般只有伪指令接受，形式如 &lt;code>db 'abcd'&lt;/code> 、&lt;code>db 'a','b','c','d'&lt;/code> 。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>浮点数&lt;/p>
&lt;ul>
&lt;li>反正用不到我也懒得看。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="14-表达式">1.4 表达式&lt;/h3>
&lt;p>和C的差不多，除了+-*/%和位运算，多了个 &lt;code>//&lt;/code> 表示带符号除法，&lt;code>%%&lt;/code> 表示带符号取模。&lt;/p>
&lt;h3 id="15-预处理器">1.5 预处理器&lt;/h3>
&lt;p>预处理器指令以 &lt;code>%&lt;/code> 开头。举几个例子&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="err">%&lt;/span>&lt;span class="nf">define&lt;/span> &lt;span class="no">FOO&lt;/span> &lt;span class="no">BAR&lt;/span>
&lt;span class="err">%&lt;/span>&lt;span class="nf">define&lt;/span> &lt;span class="no">FN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="no">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="no">x&lt;/span>&lt;span class="err">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="err">%&lt;/span>&lt;span class="nf">include&lt;/span> &lt;span class="err">&amp;#34;&lt;/span>&lt;span class="no">xxx.asm&lt;/span>&lt;span class="err">&amp;#34;&lt;/span>
&lt;span class="err">%&lt;/span>&lt;span class="nf">undef&lt;/span> &lt;span class="no">FOO&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其他懒得写了，先知道这几个和C类似的宏就行，更多看文档。&lt;/p>
&lt;h3 id="16-汇编器指令">1.6 汇编器指令&lt;/h3>
&lt;p>提几个会用到的。&lt;/p>
&lt;p>&lt;code>BITS&lt;/code>，指定目标处理器模式，比如 &lt;code>BITS 32&lt;/code> 就是32位模式。现在找16位的环境怕是也难。&lt;/p>
&lt;p>&lt;code>SECTION&lt;/code>，改变正在编写的代码要汇编进的段。要是打算汇编成 &lt;code>obj&lt;/code> 让链接器去链接出新文件会有点用。但是输出格式是 &lt;code>bin&lt;/code> 的时候就没有卵用了。&lt;/p>
&lt;p>&lt;code>EXTERN&lt;/code>，导入外部符号，还是汇编成 &lt;code>obj&lt;/code> 让链接器用的时候会有点用，链接器会搞定链接，输出格式是 &lt;code>bin&lt;/code> 的时候就没卵用。&lt;/p>
&lt;p>&lt;code>GLOBAL&lt;/code>，导出符号，和&lt;code>EXTERN&lt;/code>的应用场景差不多。熟悉C的码农应该能理解。&lt;/p>
&lt;h3 id="17-输出格式">1.7 输出格式&lt;/h3>
&lt;p>几个值得关注的输出格式。&lt;/p>
&lt;p>&lt;code>-f win32&lt;/code> 就是输出成 win32 对象文件 &lt;code>.obj&lt;/code>，之后可以用 &lt;code>gcc&lt;/code> 或者 &lt;code>link.exe&lt;/code> 之类的东西链接。&lt;/p>
&lt;p>&lt;code>-f bin&lt;/code> 输出成二进制文件，你写了啥就输出啥，nasm 就是个翻译官。&lt;code>.COM&lt;/code>和&lt;code>.SYS&lt;/code>都是纯二进制格式的，你要是写这些可能有用。还有操作系统引导程序之类的纯二进制程序，不需要别的什么文件格式的情况。&lt;/p>
&lt;p>&lt;code>-f elf&lt;/code> 你要是写 linux 下的程序就有用。&lt;/p>
&lt;h3 id="18-总结">1.8 总结&lt;/h3>
&lt;p>基本就是这样，更多东西就现查现用好吧。善用谷歌。&lt;/p>
&lt;h2 id="0x02-简单汇编程序">0x02 简单汇编程序&lt;/h2>
&lt;p>先写一个简单的汇编程序，不直接产生可执行文件，而是需要链接器进一步链接。例子需要安装 MinGW。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="nf">section&lt;/span> &lt;span class="no">.data&lt;/span>
&lt;span class="nf">global&lt;/span> &lt;span class="no">HelloWorld&lt;/span>
&lt;span class="nl">HelloWorld:&lt;/span>
&lt;span class="nf">db&lt;/span> &lt;span class="err">&amp;#39;&lt;/span>&lt;span class="no">hello&lt;/span> &lt;span class="no">world&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="c">; 定义一个字符串常量，用于输出
&lt;/span>&lt;span class="c">&lt;/span>
&lt;span class="nf">section&lt;/span> &lt;span class="no">.text&lt;/span>
&lt;span class="nf">global&lt;/span> &lt;span class="no">_main&lt;/span> &lt;span class="c">; _main 就是 C 的 main, 用于让链接器识别出入口点，生成命令行程序
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">extern&lt;/span> &lt;span class="no">_printf&lt;/span> &lt;span class="c">; _printf 就是 C 的 printf, 用于输出 hello world
&lt;/span>&lt;span class="c">&lt;/span>
&lt;span class="nl">_main:&lt;/span>
&lt;span class="nf">push&lt;/span> &lt;span class="no">ebp&lt;/span> &lt;span class="c">; 其实我们自己写就不用啰嗦 push ebp/mov ebp,esp 了, 心里有底就行
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">mov&lt;/span> &lt;span class="no">ebp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">esp&lt;/span>
&lt;span class="nf">push&lt;/span> &lt;span class="no">HelloWorld&lt;/span> &lt;span class="c">; 压入字符串常量的地址做参数
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">call&lt;/span> &lt;span class="no">_printf&lt;/span> &lt;span class="c">; 调用 printf 输出
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">add&lt;/span> &lt;span class="no">esp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span> &lt;span class="c">; 根据 cdecl 约定，完成平栈
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">pop&lt;/span> &lt;span class="no">ebp&lt;/span> &lt;span class="c">; 要返回一个值的话可以再加一行 mov eax, 0 等同于 return 0
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">retn&lt;/span> &lt;span class="c">; 完事
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>编译命令，要安装 MinGW 才有 gcc 可以用。或者其他链接器也可以，GoLink 好像就行，但是我没用过。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">nasm main.asm -f win32 -o main.o
gcc main.o -o main.exe
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>生成的代码放进调试器看看。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/image/nasm%e6%89%8b%e5%86%99%e4%b8%aaPE%e5%8f%af%e6%89%a7%e8%a1%8c%e6%96%87%e4%bb%b6/image-20211013092916141.png"
loading="lazy"
alt="image-20211013092916141"
>&lt;/p>
&lt;p>可以看到我们的汇编代码忠实地出现在调试器里。&lt;/p>
&lt;p>这就是 nasm 的简单用法了，想要拿汇编写一点简单的验证代码是没问题的，也可以手写汇编函数，再链接到 C/C++ 代码里。当然，写 C/C++ 的大佬大概也知道 Visual C++ 支持内嵌汇编，&lt;code>__asm {}&lt;/code> 就行，这也算一种选项。&lt;/p>
&lt;h2 id="0x03-生成二进制代码">0x03 生成二进制代码&lt;/h2>
&lt;p>使用 &lt;code>nasm -f bin&lt;/code> 可以直接从汇编代码生成二进制文件，也就是没有链接这一步。&lt;/p>
&lt;p>当然，没有链接这一步（或者说链接相关信息不由 nasm 管理），&lt;code>global&lt;/code> 和 &lt;code>extern&lt;/code> 都没有意义，在 &lt;code>-f bin&lt;/code> 时汇编器会直接提示错误，不能使用。但相对的，因为 nasm 没自动生成更多信息，我们也对汇编结果有了更强的控制力，也要负担更多责任。&lt;/p>
&lt;h3 id="31-生成-dos-文件头">3.1 生成 DOS 文件头&lt;/h3>
&lt;p>PE 文件格式不再赘述，参考微软的 &lt;a class="link" href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format" target="_blank" rel="noopener"
>PE Format&lt;/a> 文档，或者维基百科的 PE 格式图即可。&lt;/p>
&lt;p>先从生成 PE 文件的文件头开始，填充可执行文件的必要信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="nf">BITS&lt;/span> &lt;span class="mi">32&lt;/span>
&lt;span class="c">; 由编译器生成的 DOS 文件头其实包含了一段输出 This program cannot be run in DOS mode 的代码
&lt;/span>&lt;span class="c">; 我们不需要，这里直接忽略。
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="nl">dos_header:&lt;/span>
&lt;span class="na">.magic&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="s">&amp;#34;MZ&amp;#34;&lt;/span> &lt;span class="c">; dw 伪指令会放置一个双字节 word, 也就是操作数 MZ
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">.cblp&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">90&lt;/span>&lt;span class="no">h&lt;/span> &lt;span class="c">; 90h 就是 0x90
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">.cp&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">3&lt;/span>
&lt;span class="na">.crlc&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.cparhdr&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">4&lt;/span>
&lt;span class="na">.minalloc&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.maxalloc&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="p">-&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;span class="na">.ss&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.sp&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="no">B8h&lt;/span>
&lt;span class="na">.csum&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.ip&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.cs&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.lfarlc&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">40&lt;/span>&lt;span class="no">h&lt;/span>
&lt;span class="na">.ovno&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.res&lt;/span> &lt;span class="no">times&lt;/span> &lt;span class="mi">4&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c">; 伪指令 times 重复 n 次，放置 4 个双字节 word ，值为 0
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">.oemid&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.oeminfo&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.res2&lt;/span> &lt;span class="no">times&lt;/span> &lt;span class="mi">10&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.lfanew&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="no">.next&lt;/span> &lt;span class="c">; 紧随其后的就是 NT 文件头了，所以 lfanew 直接指向自己末尾后
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">.next&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>关于链接器自动生成的文件头，可以参考这篇文章 &lt;a class="link" href="http://blog.marcinchwedczuk.pl/a-closer-look-at-portable-executable-msdos-stub" target="_blank" rel="noopener"
>a closer look at portable executable MS-DOS stub&lt;/a> 。&lt;/p>
&lt;p>反正咱无脑复制了。&lt;/p>
&lt;h3 id="32--生成-pe-文件头">3.2 生成 PE 文件头&lt;/h3>
&lt;p>生成 PE 文件头之前我们要预先考虑几个要素。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>文件如何对齐？&lt;/p>
&lt;p>对齐到 0x400，大部分内容都可以在一个 0x400 里填写完，计算量比较少。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Section 如何对齐？&lt;/p>
&lt;p>对齐到 0x1000，同样是简化计算。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>需要几个 Section？&lt;/p>
&lt;p>一个 &lt;code>.text&lt;/code> 就足够了。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>其余文件头内容，出于简单考虑，包括重定位和 IAT 在内的大部分东西都留空，仅仅写一个什么效果都没有的可执行文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;span class="lnt">65
&lt;/span>&lt;span class="lnt">66
&lt;/span>&lt;span class="lnt">67
&lt;/span>&lt;span class="lnt">68
&lt;/span>&lt;span class="lnt">69
&lt;/span>&lt;span class="lnt">70
&lt;/span>&lt;span class="lnt">71
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="nl">nt_header:&lt;/span>
&lt;span class="nl">pe_signature:&lt;/span>
&lt;span class="na">.sig&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="s">&amp;#34;PE&amp;#34;&lt;/span> &lt;span class="c">; 魔术标识, dd 伪指令填充一个 DWORD, 结果是 PE\0\0
&lt;/span>&lt;span class="c">&lt;/span>
&lt;span class="nl">file_header:&lt;/span>
&lt;span class="na">.machine&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0x014c&lt;/span> &lt;span class="c">; 支持 Intel I386
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">.numberofsections&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0x01&lt;/span> &lt;span class="c">; 本文件包含一个 Section
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">.timedatestamp&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.pointertosymboltable&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.numberofsymbols&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.optheadersize&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="no">$OPT_HEADER_SIZE&lt;/span> &lt;span class="c">; opt_header_size 会在稍后的 optional_header 末尾计算得到
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">.characteristics&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0x102&lt;/span> &lt;span class="c">; 声明本文件是一个32位Windows可执行程序
&lt;/span>&lt;span class="c">&lt;/span>
&lt;span class="nl">optional_header:&lt;/span>
&lt;span class="na">.magic&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0x10b&lt;/span>
&lt;span class="na">.linker_version&lt;/span> &lt;span class="no">db&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>
&lt;span class="na">.sizeof_code&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="no">h&lt;/span> &lt;span class="c">; 共包含 0x1000 字节的代码段
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">.sizeof_initialized_data&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.sizeof_uninitialized_data&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.addressof_entrypoint&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="no">h&lt;/span> &lt;span class="c">; 入口点 RVA
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">.baseof_code&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="no">h&lt;/span> &lt;span class="c">; 代码段 RVA
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">.baseof_data&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="no">h&lt;/span> &lt;span class="c">; 数据段 RVA, 没有数据段就留空了
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">.image_base&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">4000000&lt;/span>&lt;span class="no">h&lt;/span> &lt;span class="c">; 镜像基址 0x04000000, 后面是 6 个 0
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">.section_alignment&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="no">h&lt;/span> &lt;span class="c">; section 对齐到 1000h
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">.file_alignment&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">400&lt;/span>&lt;span class="no">h&lt;/span> &lt;span class="c">; 文件对齐到 400h
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">.os_version&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>
&lt;span class="na">.img_version&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>
&lt;span class="na">.subsystem_version&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>
&lt;span class="na">.win32_ver_value&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.sizeof_img&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">2000&lt;/span>&lt;span class="no">h&lt;/span> &lt;span class="c">; 请求的镜像总大小，文件头到代码段起点共 1000h, 代码段 1000h, 共计 2000h
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">.sizeof_headers&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">400&lt;/span>&lt;span class="no">h&lt;/span> &lt;span class="c">; 文件头大小对齐到了 400h, 我们知道文件头肯定不足 400h, 所以 sizeof_headers 直接填 400h 就行
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">.checksum&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.subsystem&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">2&lt;/span>
&lt;span class="na">.dll_characteristics&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0x400&lt;/span> &lt;span class="c">; 不支持 SEH, 不开启 ASLR
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">.sizeof_stack_reserved&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0x100000&lt;/span>
&lt;span class="na">.sizeof_stack_commit&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0x1000&lt;/span>
&lt;span class="na">.sizeof_heap_reserved&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0x100000&lt;/span>
&lt;span class="na">.sizeof_heap_commit&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0x1000&lt;/span>
&lt;span class="na">.loeader_flags&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="na">.numberof_rva_and_sizes&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="no">h&lt;/span> &lt;span class="c">; 后续有 16 个 Data Directories
&lt;/span>&lt;span class="c">&lt;/span>
&lt;span class="nl">data_directories:&lt;/span>
&lt;span class="nf">times&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="no">h&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c">; 所有的 data directories 填充 0
&lt;/span>&lt;span class="c">&lt;/span>
&lt;span class="c">; 通过伪指令 equ ，给 $OPT_HEADER_SIZE 赋值为 (当前地址 - optional_header标签)
&lt;/span>&lt;span class="c">; 也就是整个 optional_header 的大小
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="nf">$OPT_HEADER_SIZE&lt;/span> &lt;span class="no">equ&lt;/span> &lt;span class="no">$&lt;/span> &lt;span class="p">-&lt;/span> &lt;span class="no">optional_header&lt;/span>
&lt;span class="nl">section_table:&lt;/span>
&lt;span class="nl">.text:&lt;/span>
&lt;span class="nf">db&lt;/span> &lt;span class="err">&amp;#34;&lt;/span>&lt;span class="no">.text&lt;/span>&lt;span class="err">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c">; section name
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="c">; 注意对齐到了 8 字节，不足部分 0 填充, 不能超出
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="no">h&lt;/span> &lt;span class="c">; virtual size
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="c">; Section 使用的内存大小
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">1000&lt;/span>&lt;span class="no">h&lt;/span> &lt;span class="c">; virtual address
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="c">; Section 的起始点 RVA
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">400&lt;/span>&lt;span class="no">h&lt;/span> &lt;span class="c">; sizeof raw data
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="c">; 我们知道对齐到了 400h 且代码肯定比这少, 所以 raw data 必然有 400h 大小
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="no">code&lt;/span> &lt;span class="c">; pointer to raw data
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="c">; 用 label 告诉汇编器 raw data 的偏移
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c">; pointer to relocations
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c">; pointer to linenum
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c">; number of relocations
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">dw&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c">; number of linenum
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="no">dd&lt;/span> &lt;span class="mi">0x60000020&lt;/span> &lt;span class="c">; characteristics
&lt;/span>&lt;span class="c">&lt;/span> &lt;span class="c">; 含义是：代码段 - 可读
&lt;/span>&lt;span class="c">&lt;/span>
&lt;span class="nf">align&lt;/span> &lt;span class="mi">400&lt;/span>&lt;span class="no">h&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">db&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="c">; align 伪指令，不足的部分填充0, 对齐到 400h
&lt;/span>&lt;span class="c">; 相对文件头到这里, 肯定是不足 400h 的, align 伪指令会填充到满 400h 为止。
&lt;/span>&lt;span class="c">; 这样一来, 整个文件头大小, 正好就是 400h
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="32-编写汇编代码">3.2 编写汇编代码&lt;/h3>
&lt;p>文件头定义完成后，就可以开始写汇编代码了。正常这时候还要处理导入表，但我们跳过了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="nl">code:&lt;/span>
&lt;span class="nl">.start:&lt;/span>
&lt;span class="nf">xor&lt;/span> &lt;span class="no">eax&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">eax&lt;/span>
&lt;span class="nf">retn&lt;/span>
&lt;span class="nf">align&lt;/span> &lt;span class="mi">400&lt;/span>&lt;span class="no">h&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="no">db&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="c">; 同样，再次对齐到 400h ，把代码段的剩余部分填充成 0
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>到这里，整个 PE 文件的内容就填写完毕了。&lt;/p>
&lt;p>文件头的绝大多数字段并不是我们关注的对象，计算偏移和对齐是最蛋疼的。&lt;/p>
&lt;h3 id="33-关于对齐的坑">3.3 关于对齐的坑&lt;/h3>
&lt;blockquote>
&lt;p>There are additional restrictions on image files if the SectionAlignment value in the optional header is less than the page size of the architecture. For such files, the location of section data in the file must match its location in memory when the image is loaded, so that the physical offset for section data is the same as the RVA.&lt;/p>
&lt;/blockquote>
&lt;p>微软文档里指出，在 Section 对齐的大小小于体系结构指定的页大小（4K）的时候，会有个额外限制，要求 Section 数据在文件中的偏移 &lt;strong>必须&lt;/strong> 对应在内存中的 RVA 。也就是说，如果 Section 对齐为 1 字节，&lt;code>VirtualAddress&lt;/code> 指定为 1000h，那 Section 数据必须存放在文件的 1000h 偏移处，否则生成的可执行文件会出现“不是有效的Win32应用程序”错误。&lt;/p>
&lt;h3 id="34-其他坑">3.4 其他坑&lt;/h3>
&lt;p>建议不要参考单独的某几篇文章，多找些相关的文章博客和文档，互相对照着看。PE格式错误不会有具体的提示，我也没找到什么好用的工具去检查到底哪儿有错，只能建议多用用 CFF Explorer 和 lief、pefile 这些能检查文件格式的库了，要是这些都不行那就看看16进制编辑器什么的吧，比如 HexWorkshop。IDA 在这儿没啥用。&lt;/p>
&lt;p>另外我还发现1字节对齐的时候，x32dbg 调试会看不到汇编代码，在内存布局里进入自己的PE文件后只能看到PE头，但没有反汇编。不过调试器还是可以正常单步调试和查看寄存器。&lt;/p>
&lt;h3 id="35-编译">3.5 编译&lt;/h3>
&lt;p>上面的汇编代码用 nasm 即可编译，不需要其他编译或链接工具了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">nasm pe.asm -f bin -o pe.exe
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/image/nasm%e6%89%8b%e5%86%99%e4%b8%aaPE%e5%8f%af%e6%89%a7%e8%a1%8c%e6%96%87%e4%bb%b6/image-20211013104216658.png"
loading="lazy"
alt="image-20211013104216658"
>&lt;/p>
&lt;p>也可以放进调试器看看。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/image/nasm%e6%89%8b%e5%86%99%e4%b8%aaPE%e5%8f%af%e6%89%a7%e8%a1%8c%e6%96%87%e4%bb%b6/image-20211013104451137.png"
loading="lazy"
alt="image-20211013104451137"
>&lt;/p>
&lt;p>可以看到，代码段正确出现在 4001000h 这个地址上（基址+1000h），内容也符合我们写的汇编代码。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/image/nasm%e6%89%8b%e5%86%99%e4%b8%aaPE%e5%8f%af%e6%89%a7%e8%a1%8c%e6%96%87%e4%bb%b6/image-20211013104646905.png"
loading="lazy"
alt="image-20211013104646905"
>&lt;/p>
&lt;p>在内存布局窗口也能看到。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>这是个对 PE 文件格式有所了解后的一个简单应用，原先是只会拿其他编程语言去读 PE 文件头的内容，现在学会了用汇编器去写一个简单的 PE 文件。之所以是汇编器去写，而不是拿 C/C++/Python 去写，还是因为我菜而且懒。好了跳过关于我菜的话题吧。&lt;/p>
&lt;p>参考文档（不分先后）：&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="http://blog.marcinchwedczuk.pl/a-closer-look-at-portable-executable-msdos-stub" target="_blank" rel="noopener"
>http://blog.marcinchwedczuk.pl/a-closer-look-at-portable-executable-msdos-stub&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format" target="_blank" rel="noopener"
>https://docs.microsoft.com/en-us/windows/win32/debug/pe-format&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://reverseengineering.stackexchange.com/questions/11758/how-do-you-calculate-address-start-size-of-pe-section-like-rdata-data" target="_blank" rel="noopener"
>https://reverseengineering.stackexchange.com/questions/11758/how-do-you-calculate-address-start-size-of-pe-section-like-rdata-data&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="http://www.phreedom.org/research/tinype/" target="_blank" rel="noopener"
>http://www.phreedom.org/research/tinype/&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://stackoverflow.com/questions/17456372/create-and-use-sections-for-pe-file-in-assembly-nasm" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/17456372/create-and-use-sections-for-pe-file-in-assembly-nasm&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://bitcodersblog.wordpress.com/2017/05/10/win32-in-nasm-part-1/" target="_blank" rel="noopener"
>https://bitcodersblog.wordpress.com/2017/05/10/win32-in-nasm-part-1/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>大部分代码其实是来自 tinype，被我调来调去改了很多。自己动手折腾一遍远比走马观花看一遍收获更多，有些实践问题不跟着抄一次改一改是不会发现的。有言道“实践出真知”，虽然说现在有些沙雕把生活经验当成真理导致一帮人捧书本一帮人捧经验，搞得啥事情都非黑即白&amp;hellip;把伟人的话当成互相攻讦的武器。&lt;/p>
&lt;p>淦，好好的学习，结果总结的时候越想越气。&lt;/p>
&lt;p>果然，“人类的悲欢并不相通，我只觉得他们吵闹。”&lt;/p></description></item><item><title>32位 Windows x86 汇编语言学习</title><link>https://nnnewb.github.io/blog/p/assembly-learning-note/</link><pubDate>Thu, 09 Sep 2021 16:14:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/assembly-learning-note/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>最近迷上了 Crack Me，入门无果。老是看到有大佬发52pojie又有哪个佬把什么黄油给手撕了，心痒痒。干脆也正正经经地去学一下好了。&lt;/p>
&lt;p>这当然也算是程序员本职的正经知识（心虚而且超大声）。&lt;/p>
&lt;h2 id="常规知识和速记">常规知识和速记&lt;/h2>
&lt;p>笔记内容是关于 8086/x86 汇编。&lt;/p>
&lt;p>x86体系结构下内存和寄存器都是小端序。小端序指低位在右，高位在左。如&lt;code>0x1&lt;/code>的小端序表示是&lt;code>0000 0001&lt;/code>。&lt;/p>
&lt;p>8比特能表示2位16进制数（&lt;code>0xFF&lt;/code>，也就是&lt;code>255&lt;/code>），16比特能表示4位16进制数（&lt;code>0xFFFF&lt;/code>，&lt;code>65535&lt;/code>），32比特能表示8位16进制数（&lt;code>0XFFFFFFFF&lt;/code>，&lt;code>4294967295&lt;/code>）。&lt;/p>
&lt;p>数据类型：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>助记符&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>dword&lt;/code>&lt;/td>
&lt;td>双字（double word），32比特整型数据。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>word&lt;/code>&lt;/td>
&lt;td>字，16比特整型数据。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>byte&lt;/code>&lt;/td>
&lt;td>字节，8比特整型数据。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>常用的16进制数记法：&lt;/p>
&lt;ul>
&lt;li>&lt;code>0x2A&lt;/code>，前缀&lt;code>0x&lt;/code>&lt;/li>
&lt;li>&lt;code>2AH&lt;/code>，后缀&lt;code>H&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="寄存器">寄存器&lt;/h2>
&lt;h3 id="通用寄存器">通用寄存器&lt;/h3>
&lt;p>参考：&lt;a class="link" href="https://zh.wikibooks.org/wiki/X86_%E6%B1%87%E7%BC%96/X86_%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener"
>x86汇编 - 维基百科&lt;/a>&lt;/p>
&lt;p>参考：&lt;a class="link" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/x64-architecture" target="_blank" rel="noopener"
>x64体系结构 - windows hardware&lt;/a>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>64位寄存器&lt;/th>
&lt;th>32位寄存器&lt;/th>
&lt;th>16位寄存器&lt;/th>
&lt;th>8位寄存器&lt;/th>
&lt;th>用途&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>RAX&lt;/code>或&lt;code>R0&lt;/code>&lt;/td>
&lt;td>&lt;code>EAX&lt;/code>&lt;/td>
&lt;td>&lt;code>AX&lt;/code>&lt;/td>
&lt;td>&lt;code>AL&lt;/code>和&lt;code>AH&lt;/code>&lt;/td>
&lt;td>Accumlator，累加寄存器，用于算术运算。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>RBX&lt;/code>或&lt;code>R3&lt;/code>&lt;/td>
&lt;td>&lt;code>EBX&lt;/code>&lt;/td>
&lt;td>&lt;code>BX&lt;/code>&lt;/td>
&lt;td>&lt;code>BL&lt;/code>和&lt;code>BH&lt;/code>&lt;/td>
&lt;td>Base，基址寄存器，指向数据块基址（段模式存于段寄存器&lt;code>DS&lt;/code>）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>RCX&lt;/code>或&lt;code>R1&lt;/code>&lt;/td>
&lt;td>&lt;code>ECX&lt;/code>&lt;/td>
&lt;td>&lt;code>CX&lt;/code>&lt;/td>
&lt;td>&lt;code>CL&lt;/code>和&lt;code>CH&lt;/code>&lt;/td>
&lt;td>Counter，用于用于移/环指令及循环（没懂）。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>RDX&lt;/code>或&lt;code>R2&lt;/code>&lt;/td>
&lt;td>&lt;code>EDX&lt;/code>&lt;/td>
&lt;td>&lt;code>DX&lt;/code>&lt;/td>
&lt;td>&lt;code>DL&lt;/code>和&lt;code>DH&lt;/code>&lt;/td>
&lt;td>Data，用于数学运算和IO操作。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>RSI&lt;/code>或&lt;code>R6&lt;/code>&lt;/td>
&lt;td>&lt;code>ESI&lt;/code>&lt;/td>
&lt;td>&lt;code>SI&lt;/code>&lt;/td>
&lt;td>&lt;code>SIL&lt;/code>&lt;/td>
&lt;td>Source Index，指向指令流操作中的源。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>RDI&lt;/code>或&lt;code>R7&lt;/code>&lt;/td>
&lt;td>&lt;code>EDI&lt;/code>&lt;/td>
&lt;td>&lt;code>DI&lt;/code>&lt;/td>
&lt;td>&lt;code>DIL&lt;/code>&lt;/td>
&lt;td>Destination Index，指向指令流操作中的目标。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>RBP&lt;/code>或&lt;code>R5&lt;/code>&lt;/td>
&lt;td>&lt;code>EBP&lt;/code>&lt;/td>
&lt;td>&lt;code>BP&lt;/code>&lt;/td>
&lt;td>&lt;code>BPL&lt;/code>&lt;/td>
&lt;td>Stack Base Pointer，指向栈的基地址。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>RSP&lt;/code>或&lt;code>R4&lt;/code>&lt;/td>
&lt;td>&lt;code>ESP&lt;/code>&lt;/td>
&lt;td>&lt;code>SP&lt;/code>&lt;/td>
&lt;td>&lt;code>SPL&lt;/code>&lt;/td>
&lt;td>Stack Pointer，指向栈顶的地址。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>R8&lt;/code>&lt;/td>
&lt;td>&lt;code>R8D&lt;/code>&lt;/td>
&lt;td>&lt;code>R8W&lt;/code>&lt;/td>
&lt;td>&lt;code>R8B&lt;/code>&lt;/td>
&lt;td>无别名。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>R9&lt;/code>&lt;/td>
&lt;td>&lt;code>R9D&lt;/code>&lt;/td>
&lt;td>&lt;code>R9W&lt;/code>&lt;/td>
&lt;td>&lt;code>R9B&lt;/code>&lt;/td>
&lt;td>无别名。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>R10&lt;/code>&lt;/td>
&lt;td>&lt;code>R10D&lt;/code>&lt;/td>
&lt;td>&lt;code>R10W&lt;/code>&lt;/td>
&lt;td>&lt;code>R10B&lt;/code>&lt;/td>
&lt;td>无别名。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>R11&lt;/code>&lt;/td>
&lt;td>&lt;code>R11D&lt;/code>&lt;/td>
&lt;td>&lt;code>R11W&lt;/code>&lt;/td>
&lt;td>&lt;code>R11B&lt;/code>&lt;/td>
&lt;td>无别名。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>R12&lt;/code>&lt;/td>
&lt;td>&lt;code>R12D&lt;/code>&lt;/td>
&lt;td>&lt;code>R12W&lt;/code>&lt;/td>
&lt;td>&lt;code>R12B&lt;/code>&lt;/td>
&lt;td>无别名。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>R13&lt;/code>&lt;/td>
&lt;td>&lt;code>R13D&lt;/code>&lt;/td>
&lt;td>&lt;code>R13W&lt;/code>&lt;/td>
&lt;td>&lt;code>R13B&lt;/code>&lt;/td>
&lt;td>无别名。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>R14&lt;/code>&lt;/td>
&lt;td>&lt;code>R14D&lt;/code>&lt;/td>
&lt;td>&lt;code>R14W&lt;/code>&lt;/td>
&lt;td>&lt;code>R14B&lt;/code>&lt;/td>
&lt;td>无别名。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>R15&lt;/code>&lt;/td>
&lt;td>&lt;code>R15D&lt;/code>&lt;/td>
&lt;td>&lt;code>R15W&lt;/code>&lt;/td>
&lt;td>&lt;code>R15B&lt;/code>&lt;/td>
&lt;td>无别名。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>后续还是用 32 位寄存器的名字称呼这些寄存器。&lt;/p>
&lt;p>通用寄存器的用途并不是绝对的，程序可以根据自己的需要将通用寄存器挪作它用。&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>16位寄存器本身是32位寄存器的低16位。32位寄存器的高16位没有单独的助记符。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>16位寄存器又可以单独分成两个8位寄存器使用。其中如&lt;code>AH&lt;/code>形式的寄存器表示&lt;code>AX&lt;/code>高位8比特，&lt;code>AL&lt;/code>则表示低位8比特。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="edi-和-esi">EDI 和 ESI&lt;/h3>
&lt;p>关于&lt;code>EDI&lt;/code>和&lt;code>ESI&lt;/code>这两个寄存器的用途可以参考 &lt;a class="link" href="https://stackoverflow.com/questions/1856320/purpose-of-esi-edi-registers" target="_blank" rel="noopener"
>stack overflow 的这篇问答&lt;/a>。摘一段例子，下面的C代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">srcp&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">srcidx&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">argv&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以被编译成下面的汇编语句：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="nf">mov&lt;/span> &lt;span class="no">edx&lt;/span>&lt;span class="p">,[&lt;/span>&lt;span class="no">ebp&lt;/span>&lt;span class="err">+&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="no">c&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="no">ecx&lt;/span>&lt;span class="p">,[&lt;/span>&lt;span class="no">edx&lt;/span>&lt;span class="err">+&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">*&lt;/span>&lt;span class="no">ebx&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="no">ebp&lt;/span>&lt;span class="err">+&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">*&lt;/span>&lt;span class="no">edi-54&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="no">ecx&lt;/span>
&lt;span class="nf">inc&lt;/span> &lt;span class="no">edi&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>ebp+0c&lt;/code>包含了&lt;code>argv&lt;/code>内容，&lt;code>ebx&lt;/code>就是&lt;code>j&lt;/code>，&lt;code>edi&lt;/code>就是&lt;code>srcidx&lt;/code>。&lt;/p>
&lt;h3 id="段寄存器">段寄存器&lt;/h3>
&lt;p>现代操作系统采用内存分页模式，把所有段寄存器指向同址来禁用内存分段模式。然而&lt;code>FS&lt;/code>和&lt;code>GS&lt;/code>依然用于内存分段模式，用于线程内数据存取。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>段寄存器助记符&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>SS&lt;/code>&lt;/td>
&lt;td>Stack Segment，栈段&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>CS&lt;/code>&lt;/td>
&lt;td>Code Segment，代码段&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>DS&lt;/code>&lt;/td>
&lt;td>Data Segment，数据段&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ES&lt;/code>&lt;/td>
&lt;td>Extra Segment，额外数据段&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>FS&lt;/code>&lt;/td>
&lt;td>更额外的数据段&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>GS&lt;/code>&lt;/td>
&lt;td>更额外的数据段&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>x86一共有6个段寄存器，所有段寄存器都是16比特位宽。&lt;/p>
&lt;p>关于段寄存器用途和计算放在主存一节中。&lt;/p>
&lt;h3 id="指令指针-eip">指令指针 EIP&lt;/h3>
&lt;p>IP 寄存器全称是 Instruction Pointer 寄存器，保存总是保存下一指令的地址。&lt;/p>
&lt;p>x86实模式下使用段内存管理，可寻址1MB内存空间，采用基址（段寄存器）左移4位加上偏移量，相当于20比特位宽地址总线。实模式下EIP可以和CS代码段寄存器结合求取下一指令的具体地址。&lt;/p>
&lt;h3 id="标志寄存器">标志寄存器&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>助记符&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>CF&lt;/code>&lt;/td>
&lt;td>Carry Flag，进位或借位溢出时记为1，否则0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>PF&lt;/code>&lt;/td>
&lt;td>Parity Flag，运算结果最低字节有偶数个1位时记为1，否则0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>AF&lt;/code>&lt;/td>
&lt;td>Auxiliary Flag，BCD码算术运算中进位或借位溢出，即运算结果第三位发生进借位时记1，否则0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ZF&lt;/code>&lt;/td>
&lt;td>Zero Flag，运算结果为0时记1，否则0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>SF&lt;/code>&lt;/td>
&lt;td>Sign Flag，记运算结果最高位（符号位）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>TF&lt;/code>&lt;/td>
&lt;td>Trap Flag，单步调试记1，否则0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>IF&lt;/code>&lt;/td>
&lt;td>Interrupt Enable Flag，是否允许响应中断&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>DF&lt;/code>&lt;/td>
&lt;td>Direction Flag，串方向标记，指示串指令从高地址向低地址还是低地址向高地址处理。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>OF&lt;/code>&lt;/td>
&lt;td>Overflow Flag，指示算术运算是否溢出。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>IOPL&lt;/code>&lt;/td>
&lt;td>I/O Privilege Level，I/O特权级，2比特宽，&lt;code>CPL&lt;/code>小于等于&lt;code>IOPL&lt;/code>才允许访问I/O地址空间。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>NT&lt;/code>&lt;/td>
&lt;td>Nested Task Flag，当前任务链接上衣任务时置1，否则0。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>RF&lt;/code>&lt;/td>
&lt;td>Resume Flag，控制处理器对除障异常的响应。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>VM&lt;/code>&lt;/td>
&lt;td>Virtual-8086 Mode Flag，虚拟8086模式标志，置1时进入虚拟8086模式，清0返回保护模式。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>AC&lt;/code>&lt;/td>
&lt;td>Alignment Check Flag，该标志以及在CR0寄存器中的AM位置1时将允许内存引用的对齐检查，以上两个标志中至少有一个被清零则禁用对齐检查。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>VIF&lt;/code>&lt;/td>
&lt;td>Virtual interrupt flag，该标志是IF标志的虚拟镜像(Virtual image)，与VIP标志结合起来使用。使用这个标志以及VIP标志，并设置CR4控制寄存器中的VME标志就可以允许虚拟模式扩展(virtual mode extensions)。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>VIP&lt;/code>&lt;/td>
&lt;td>Virtual interrupt pending flag，该位置1以指示一个中断正在被挂起，当没有中断挂起时该位清零。与VIF标志结合使用。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ID&lt;/code>&lt;/td>
&lt;td>Identification flag，程序能够设置或清除这个标志指示了处理器对CPUID指令的支持。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="主存">主存&lt;/h2>
&lt;h3 id="运行模式和地址模型">运行模式和地址模型&lt;/h3>
&lt;p>x86 CPU 运行模式主要考虑&lt;strong>实模式&lt;/strong>和&lt;strong>保护模式&lt;/strong>，以及特殊的&lt;strong>虚拟8086模式&lt;/strong>。&lt;/p>
&lt;p>实模式有自己的独特地址空间模型，下可视作16位CPU+20比特无保护地址空间，使用段寄存器和通用16位通用寄存器组合寻址，算法&lt;code>base&amp;lt;&amp;lt;4+offset&lt;/code>。最大可寻址1MB。&lt;/p>
&lt;p>虚拟8086模式用于在保护模式下运行实模式程序，并不是真正的CPU模式，CPU实际还是运行在保护模式。一些程序利用虚拟8086模式可以实现在保护模式下运行实模式程序，如 dosbox、dosemu 。&lt;/p>
&lt;p>保护模式下可以用&lt;strong>逻辑地址&lt;/strong>访问主存，逻辑地址又称&lt;strong>远指针&lt;/strong>（&lt;code>far ptr&lt;/code>），逻辑地址由段选择器加上偏移寻址组成。运行于 IA-32 体系的程序，段选择器最多可以选择 2^14^-1 个段，每个段可以长达 2^32^ 字节。&lt;/p>
&lt;h3 id="nearfarhuge-指针">near/far/huge 指针&lt;/h3>
&lt;p>near 指针是给定段内用16比特表示的偏移值，最大访问地址空间64KB。&lt;/p>
&lt;p>far 指针是32比特表示的偏移值，在16位架构下可以访问段外的内存，32/64位架构下则依然是段内。&lt;/p>
&lt;p>huge指针和far指针大小相同，大体目标就是在16位限制下访问更大的地址空间。&lt;/p>
&lt;h3 id="平坦内存模型线性内存模型">平坦内存模型/线性内存模型&lt;/h3>
&lt;p>参考：&lt;a class="link" href="https://en.wikipedia.org/wiki/Flat_memory_model" target="_blank" rel="noopener"
>flat memory model - wiki&lt;/a>&lt;/p>
&lt;p>平坦内存模型也叫线性内存模型，定义是程序中的内存在同一个连续的地址空间中，不需要通过分段或分页机制间接取址。（从操作系统或硬件角度来说，可能依然有分页或分段，但对用户程序来说无感知）。&lt;/p>
&lt;h3 id="intel-内存模型">Intel 内存模型&lt;/h3>
&lt;p>下述内存模型是实模式下的，保护模式下更近似于线性模型。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>模型&lt;/th>
&lt;th>数据段指针&lt;/th>
&lt;th>代码段指针&lt;/th>
&lt;th>定义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Tiny&lt;/td>
&lt;td>near&lt;/td>
&lt;td>near&lt;/td>
&lt;td>CS=DS=SS&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Small&lt;/td>
&lt;td>near&lt;/td>
&lt;td>near&lt;/td>
&lt;td>DS=SS&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Medium&lt;/td>
&lt;td>near&lt;/td>
&lt;td>far&lt;/td>
&lt;td>DS=SS，多个代码段&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Compact&lt;/td>
&lt;td>far&lt;/td>
&lt;td>near&lt;/td>
&lt;td>一个代码段，多个数据段&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Large&lt;/td>
&lt;td>far&lt;/td>
&lt;td>far&lt;/td>
&lt;td>多个代码段和数据段&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Huge&lt;/td>
&lt;td>huge&lt;/td>
&lt;td>far&lt;/td>
&lt;td>多个代码段和数据段，单个数组可能超过64KB&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>在Tiny模型下，所有段寄存器指针指向相同的段。&lt;/li>
&lt;li>在所有DS=SS的模型里，数据段指针总是near。&lt;/li>
&lt;li>栈总是限制在最高64KB。&lt;/li>
&lt;/ul>
&lt;h2 id="函数">函数&lt;/h2>
&lt;h3 id="栈">栈&lt;/h3>
&lt;p>参考：&lt;a class="link" href="https://www.zhihu.com/question/36103513" target="_blank" rel="noopener"
>栈的增长方向？ - 知乎&lt;/a>&lt;/p>
&lt;p>讨论对象是 Windows x86 32位程序。栈从高位向低位增长，需要注意看栈视图的地址是高地址在上还是低地址在上，被调用方的栈帧总是在调用方的增长方向上。&lt;/p>
&lt;p>例如下面的汇编指令。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="nf">push&lt;/span> &lt;span class="no">eax&lt;/span> &lt;span class="c">; 把eax当参数入栈 esp=75f888
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="no">push&lt;/span> &lt;span class="no">eax&lt;/span> &lt;span class="c">; 把eax当参数入栈 esp=75f884
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="no">push&lt;/span> &lt;span class="no">eax&lt;/span> &lt;span class="c">; 把eax当参数入栈 esp=75f880
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="no">call&lt;/span> &lt;span class="no">example.fn&lt;/span> &lt;span class="c">; 调用
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="no">add&lt;/span> &lt;span class="no">esp&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0xc&lt;/span> &lt;span class="c">; 调用方清栈，cdecl调用约定
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>执行call指令，跳转到被调用函数时，栈上会压入函数的返回地址。&lt;/p>
&lt;h3 id="栈指针-frame-pointer">栈指针 frame pointer&lt;/h3>
&lt;p>栈指针可以通过编译参数 &lt;code>-fomit-frame-pointer&lt;/code> 或 &lt;code>/Oy-&lt;/code> 来关闭。&lt;/p>
&lt;p>在有栈指针（frame pointer）的情况下，每个函数开头会做一个&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="nf">push&lt;/span> &lt;span class="no">ebp&lt;/span>
&lt;span class="nf">mov&lt;/span> &lt;span class="no">ebp&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="no">esp&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>的动作，这个动作做完后，新栈帧的栈底就是 ebp 了，ebp正好指向旧栈帧基地址，在ebp下（和栈增长方向相反）就是函数返回地址和调用方给的实参。&lt;/p>
&lt;p>在函数返回前，又会做一个&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="nf">pop&lt;/span> &lt;span class="no">ebp&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>来完成平栈。&lt;/p>
&lt;p>下面就是被调函数执行完函数开头的指令后的栈。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>地址（栈向下增长）&lt;/th>
&lt;th>内容含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>[ebp+0x10]&lt;/code>&lt;/td>
&lt;td>第3个参数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[ebp+0xc]&lt;/code>&lt;/td>
&lt;td>第2个参数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[ebp+0x8]&lt;/code>&lt;/td>
&lt;td>第1个参数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[ebp+0x4]&lt;/code>&lt;/td>
&lt;td>函数的返回地址&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[ebp]&lt;/code>&lt;/td>
&lt;td>上一个栈帧基地址，此时&lt;code>esp&lt;/code>和&lt;code>ebp&lt;/code>相同。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>关闭栈指针的情况下，函数不会在开头保存ebp了，对函数参数的引用也会改为相对esp的偏移。&lt;/p>
&lt;h3 id="调用约定">调用约定&lt;/h3>
&lt;p>先讨论 cdecl 调用约定，函数调用的一般过程是：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="nf">push&lt;/span> &lt;span class="mi">0x0&lt;/span> &lt;span class="c">; 压栈参数 0
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="no">push&lt;/span> &lt;span class="no">example.50be50&lt;/span> &lt;span class="c">; 压栈参数 &amp;#34;%d&amp;#34;
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="no">call&lt;/span> &lt;span class="no">example._printf&lt;/span> &lt;span class="c">; 调用 printf(&amp;#34;%d&amp;#34;, 0)
&lt;/span>&lt;span class="c">&lt;/span>&lt;span class="no">add&lt;/span> &lt;span class="no">esp&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0x8&lt;/span> &lt;span class="c">; cdecl 约定下，调用者清栈
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>stdcall&lt;/code>调用约定和&lt;code>cdecl&lt;/code>调用约定的区别在于&lt;code>stdcall&lt;/code>是被调用方清栈：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="nf">ret&lt;/span> &lt;span class="mi">0x8&lt;/span> &lt;span class="c">; ret 有一个的可选参数，指示要从栈上弹出多少空间。相当于是先 add esp,0x8 再 ret
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>cdecl&lt;/code>是大部分编译器包括微软VC++默认的调用约定，&lt;code>stdcall&lt;/code>是所有 Windows API 的调用约定。&lt;/p>
&lt;h3 id="name-mangling">name mangling&lt;/h3>
&lt;p>好像没有广泛使用的译名，可以叫名字修饰、名字重整或改编，意会吧。&lt;/p>
&lt;p>对于有使用c/c++编程经验的人可能已经见过很多链接错误：&lt;/p>
&lt;ul>
&lt;li>undefined reference to &amp;hellip;&lt;/li>
&lt;li>无法解析的外部符号 &amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>如果注意过提示中的符号名应该会发现这些符号名称都不是代码里写的函数名称，而是经过了变形的。&lt;/p>
&lt;p>&lt;code>cdecl&lt;/code>调用约定下，name mangling 的规则是在符号前加下划线。比如C库的&lt;code>printf&lt;/code>函数，经过name mangling后是&lt;code>_printf&lt;/code>。&lt;/p>
&lt;p>&lt;code>stdcall&lt;/code>调用约定下，name mangling 的规则是在符号前加下划线，符号后加 &lt;em>@参数长度&lt;/em>。需要注意的是对于C中的变长参数 variadic function，是不能用 &lt;code>stdcall&lt;/code> 调用约定的。&lt;/p>
&lt;p>用函数 &lt;code>int fn(int a, int b)&lt;/code> 举例，认为 int 是 4 字节长，此时&lt;code>cdecl&lt;/code>下叫&lt;code>_fn&lt;/code>，&lt;code>stdcall&lt;/code>下叫&lt;code>_fn@8&lt;/code>。&lt;/p></description></item></channel></rss>