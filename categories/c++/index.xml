<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c++ on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/categories/c++/</link><description>Recent content in c++ on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 15 Feb 2022 17:11:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/categories/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>CPU缓存、缺页和伪共享</title><link>https://nnnewb.github.io/blog/p/cpu-cache-page-fault-and-false-sharing/</link><pubDate>Tue, 15 Feb 2022 17:11:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/cpu-cache-page-fault-and-false-sharing/</guid><description>前言 看B树的时候发现对缓存还是不够了解，但 cache line 又很神奇。要是有些比较吃CPU的代码改一下结构和访问方式啥的就能白嫖个50%性能提升那岂不是美哉。结合下面的参考文章大概聊一下。
Gallery of Processor Cache Effects 缓存行 介绍 首先，缓存行不是“行”，这是对 cache line 的直译，cache line 和 cache block 是同义的，忽略这个“行”字即可。
cache line 指的是 CPU 高速缓存（L1~L3）中的一个缓存块，通常大小在 32/64/128 bytes ，现在常见的应该是 64 bytes 。cache line 之所以重要，是因为这是 CPU 访问主存的必经之路，频繁访问主存数据的场合，或者并发编程时，cache line 的影响还是不容忽视的。
简单的基准测试 光是说 cache line 多重要没有卵用，写个 demo 看看 cache line 的影响更直观。来一个最简单不过的单链表遍历。
#include &amp;lt;chrono&amp;gt;#include &amp;lt;cstddef&amp;gt;#include &amp;lt;functional&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;iterator&amp;gt;#include &amp;lt;ostream&amp;gt;#include &amp;lt;string&amp;gt; using namespace std; using namespace std::chrono; typedef struct _data { struct _data *next; int value; } mydata; void time_it(const std::string name, function&amp;lt;void(void)&amp;gt; fn) { auto start = system_clock::now(); fn(); auto stop = system_clock::now(); cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34;: &amp;#34; &amp;lt;&amp;lt; duration_cast&amp;lt;milliseconds&amp;gt;(stop - start).</description></item><item><title>编译LIEF的各种姿势</title><link>https://nnnewb.github.io/blog/p/how-to-compile-lief-on-windows/</link><pubDate>Fri, 08 Oct 2021 16:25:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/how-to-compile-lief-on-windows/</guid><description>前言 惯例得有个前言。
LIEF是一个二进制文件分析和操作库，官方推荐的是 Python 版本，确实更好用，就是类型的问题有点多，而且没附送 .pyi 导致不大好写。而C++版本就没这问题，C++版本有自己的问题=，=
一个是官方提供下载的SDK是静态链接的，用到SDK的程序必须指定 /MT 不然编译器就会抱怨运行库不匹配。虽然看issue里已经有人解决了（-DLIEF_USE_CRT_{DEBUG,RELEASE}=MD/MT），但CI还是老样子，反正直接下载的SDK用起来就蛋疼，vcpkg 全都是 /MD 链接的，没法配合用。
更别提 MinGW 了，就没官方的SDK。
以上就是问题，解决问题的最简单办法就是自己编译了。
0x01 Visual C++ 工具链 msbuild 代码下载下来之后，用 CMake 去编译。下面的命令都是 Powershell 下的，注意折行用的是反引号 backquote，就是波浪号那个键，和 bash 用 反斜杠不一样。直接复制到命令行是跑不起来的。
cmake .. -G &amp;#34;Visual Studio 2019&amp;#34; # Generator，你的工具链，可以用 cmake --help 来看看有哪些可用的 -A Win32 # 选择 Visual C++ 工具链的情况下可以用 -A Win32 选择编译32位代码，或者 Win64 -DCMAKE_BUILD_TYPE=Debug # 常用的 Debug/Release/RelWithDebInfo -DLIEF_PYTHON_API=off # 不编译 Python 模块，这样就不用装 Python 了 -DLIEF_USE_CRT_DEBUG=MD # 使用 /MD 链接 msvcrt.dll 而不是 libcmt 这儿有个坑，用 Visual Studio 这个 Generator 的时候，虽然指定了 CMAKE_BUILD_TYPE，但实际没什么卵用，还得在编译的时候给参数 --config Debug 才会真的按 Debug 编译。</description></item><item><title>在C++中嵌入Python解释器</title><link>https://nnnewb.github.io/blog/p/%E5%9C%A8c-%E4%B8%AD%E5%B5%8C%E5%85%A5python%E8%A7%A3%E9%87%8A%E5%99%A8/</link><pubDate>Fri, 07 Feb 2020 21:59:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E5%9C%A8c-%E4%B8%AD%E5%B5%8C%E5%85%A5python%E8%A7%A3%E9%87%8A%E5%99%A8/</guid><description>先不说废话，项目地址：https://github.com/nnnewb/CQPy 。欢迎给个 Star 什么的。
背景 想给最近在玩的酷 Q 写个插件，发现没有合适的直接使用 Python 的解决方案。
Richard Chien 提供了一个比较通用的插件，CQHttp。CQHttp本体是用 C++ 编写的插件，将酷 Q 的回调包装成 HTTP 请求转发至指定的地址，支持http和websocket两种协议。
不过由于个人想折腾折腾的想法，打算试试把 Python 解释器直接嵌入到 C++ 里得了。
整个思路如下。
graph LR; CQP[酷Q] --事件回调--&amp;gt; dll[插件DLL]; dll --事件回调--&amp;gt; python[Python脚本]; python --调用API--&amp;gt; dll; dll --调用API--&amp;gt; CQP; 依赖 为了简化操作 Python 接口，我没有使用 Python 自带的 C API，而是pybind11，使用vcpkg管理依赖。
安装命令：
vcpkg install pybind11:x86-windows 0x1 编译 DLL 我使用 CMake 作为编译系统，因此可以很简单地写一个编译出 DLL 的 CMakeLists.txt
cmake_minimum_required(VERSION 3.15)project(top.weak-ptr.cqpy LANGUAGES CXX VERSION 0.1.0)include_directories(src)aux_source_directory(src SOURCES)set(CMAKE_CXX_STANDARD 17)# 引入 pybind11 find_package(pybind11 CONFIG REQUIRED)# 添加 target set(OUT_NAME &amp;#34;app&amp;#34;)add_library(${OUT_NAME} SHARED ${SOURCES})set_target_properties(${OUT_NAME} PROPERTIES LINKER_LANGUAGE CXX)target_link_libraries(${OUT_NAME} PRIVATE pybind11::embed)源代码使用 MSVC 和 MinGW 编译，另外再处理下源码编码的问题和宏。</description></item><item><title>GameHollywood 面试笔记</title><link>https://nnnewb.github.io/blog/p/gamehollywood-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</link><pubDate>Tue, 26 Jun 2018 17:22:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/gamehollywood-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</guid><description>Intro 面试的职位是 C++后端开发工程师，主要聊的还是 C++。在过程中自我感觉面得还行，至少没上次那么蠢。
聊的内容主要集中在 STL 和线程安全、资源管理的层面。
惯例的，填完面试信息表并简历一起上交，然后等面试官来客套完，就开始聊技术了。
注意，面试官的提问并非原话，有修饰和脑补。
0. 预热：你用哪个版本的 C++？ 客套话什么的就略了。
面试官：&amp;hellip;行，那我们就聊聊 C++吧。你常用哪个版本的 C++？
我：我比较常用的是 C++11。
C++版本这个问题面试里应该不多见，不过作为引入的话题还行，标准之神会瞑目的。
对于C++版本这个词，很大概率上大家说的应该就是 C++标准委员会WG21制定的 C++标准了，最新版本的标准文档是 C++17 定稿N4659，制定中的 C++20 标准文档可以访问WG21/docs/papers/2018查阅。
需要注意的是，如果答成了我用 VC6之类的骚话，很大概率会留下不好的映像——或者对方也是忠实的 VC6 神教教徒的话，达成共识也说不定。
闲话少叙。
1. 起手式：std::shared_ptr 面试官：说说std::shared_ptr是怎么实现的？一般怎么去使用它？
答：shared_ptr是通过引用计数实现的，它可以作为容器元素，在程序里传递 blabal&amp;hellip;..而且shared_ptr不是线程安全的，它不能跨线程传递，要额外做一层包装 blabla&amp;hellip;&amp;hellip;
正巧最近有想写一篇智能指针相关的博客，面试官的第一问就提到了。
说到智能指针，就必须提一下 RAII 了。
1.1 异常安全和 RAII std::shared_ptr和其他智能指针类型都在&amp;lt;memory&amp;gt;头文件里定义，主要的作用是实现自动化的资源管理，基于RAII的理念设计和实现。
RAII指的是获取资源即初始化，英文全写是Resource Acquisition Is Initialization，属于一种面向对象编程语言中常见的惯用法。
它的思路是这样子的：初始化即获取资源，离开作用域就自动销毁。
RAII 解决的问题是，当异常发生时，如何确保资源释放。这是个异常安全的问题。
常见的非 RAII 风格代码里，如果要确保资源被正确释放，就要用try {} catch() {} finally {}块捕获异常，然后执行资源释放的代码，再将异常重新抛出。</description></item><item><title>可重入和异步安全</title><link>https://nnnewb.github.io/blog/p/%E5%8F%AF%E9%87%8D%E5%85%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E5%AE%89%E5%85%A8/</link><pubDate>Sun, 24 Jun 2018 22:48:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E5%8F%AF%E9%87%8D%E5%85%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E5%AE%89%E5%85%A8/</guid><description>这篇博客主要记录的是关于可重入性的相关定义，以及关于并发安全的思考。
可重入性 在不同语言中，由于语言标准以及运行期环境规定的不同，可重入性的具体定义可能有所不同。这里聊的是 C++语言中的可重入性。
所谓可重入性（reetrant），指的是同时具备并发安全和中断安全的特征，这是目前为止我对可重入性的认识，也是这篇博客在写下时给可重入性下的定义。
这个认知可能并不准确，因为在wiki上的定义是这样的。
若一个程序或子程序可以「在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错」，则称其为可重入（reentrant 或 re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合設計時預期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。
但是在很多中文博客里，聊到可重入性的时候往往也会把并发安全混为一谈。实际上来说的话&amp;hellip;&amp;hellip;一个可重入的函数，常常也是并发安全的。
那么先从并发安全讲起吧。
并发安全性和可重入性 所谓并发安全已经是老生常谈了。
以一段非常简单的代码为例，我们打算初始化一个对象，这个对象被两个线程共享。
void initialize(Something** someshit) { if(!*someshit) { *someshit = createSomeShit(); } } 显而易见，如果线程在执行到特定环节时发生了切换
void initialize(Something** someshit) { if(!*someshit) { // &amp;lt;-------- 线程切换 // 线程2() { // initialize(something); // } // 线程切换 ---------&amp;gt; *someshit = createSomeShit(); } } 那么 createSomeShit这段代码就会被执行两次。
显然这和我们预期的行为不符。
这里要聊的不是并发，而是&amp;hellip;&amp;hellip;可重入性。所以我们再看看这个函数能否被重入。
按照 wiki 提供的定义，函数可重入指的是
在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错。
符合吗？不。为什么？因为同样在那个线程切换的位置上中断，然后再另一段代码里再次执行这个函数，也会触发同样的问题，导致createSomeShit被执行两次。
void initialize(Something** someshit) { if(!</description></item><item><title>鲸鱼游戏面试笔记</title><link>https://nnnewb.github.io/blog/p/%E9%B2%B8%E9%B1%BC%E6%B8%B8%E6%88%8F%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</link><pubDate>Wed, 20 Jun 2018 19:15:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E9%B2%B8%E9%B1%BC%E6%B8%B8%E6%88%8F%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</guid><description>Intro 简单介绍下面试的前置情况。
面试的公司是鲸鱼游戏，职位是后端开发工程师，开发语言 C++。
这篇博文主要是为了记录面试中发现的自身不足。
这次面试里，因为面试约得比较匆忙，所以基本没做任何准备。讲道理的说我是有点盲目自信了，毕竟 C/C++是我的第一语言来着，本来以为考察语言的部分不会有什么问题，但没想到因为紧张而错漏百出。
那么接下来就直接进入正题，以下是对面试中遇到的问题重新思考后的回答和想法。
下面面试官的提问并非原话，有经过脑补润色。
起手式：面向对象 面试官：讲讲面向对象，继承，还有多态。我们都知道程序设计有两种常见的范式，面向过程和面向对象，讲讲面向对象给我们带来了什么好处？
实话说第一问就已经有点出乎意料，但想想其实还是在意料之中。初级职位更注重于基础概念和技能，中高级职位可能会在数据结构和并发一类的问题上更深入。
答：抽象，归类 blabla&amp;hellip;易于维护 blabla&amp;hellip;
全错。
现在回忆起来，面试官想问的其实只有一点，就是那句封装。
封装是面向对象的核心概念之一。
封装使代码成为一个黑箱，让我们不必关注它的实现，而是关注它的行为和接口。
这产生了面向接口编程的概念，我们不再关注封装后的对象内部的逻辑，我们给封装后的对象以输入，然后从封装后的对象里取出数据。
封装并不只是一系列接口的集合，更包含了数据和状态，它就是一个微型化的服务，调用者告诉它去做什么事，而不关心它怎么做。
第二招：继承 面试官：讲讲继承。
我：代码复用，blabla&amp;hellip;&amp;hellip;
代码复用，这是核心。
代码复用是继承最主要的作用，大家都知道。面试官并没有在这方面继续深入，所以能答出代码复用其实已经差不多了。
除非再抠上语言相关的语法细节：多继承和单继承。
多继承 C++ 采用了多继承模型，即一个子类可以有多个父类。
Father ------| |====&amp;gt; child Mother ------| 多继承可以允许一些特殊的编程范式。比如说mixin模式。但是多继承也存在其固有的复杂性，主要表现在运行时多态上。
举几个多继承上常见的问题。
父类成员冲突 典型场景如下
class ParentA { public: void func(){} }; class ParentB { public: void func(){} }; class Child: public ParentA,ParentB {}; int main() { Child c; c.</description></item></channel></rss>