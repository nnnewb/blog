<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>密码学 on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/</link><description>Recent content in 密码学 on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 16 Nov 2021 11:31:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/index.xml" rel="self" type="application/rss+xml"/><item><title>密码学入门03 - 古典密码#3</title><link>https://nnnewb.github.io/blog/p/cryptography-introduction-03/</link><pubDate>Tue, 16 Nov 2021 11:31:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/cryptography-introduction-03/</guid><description>前言 学习一下 Hill 密码。
0x01 数学基础 参考了 数学乐 。没有详细介绍矩阵的意义，但基本运算规则之类的讲得很清楚好懂。
1.1 矩阵 一个矩阵就是n行m列的数字表格，含义暂不考虑，只学习下矩阵的表示方法、运算规则，不然有点难读懂 Hill 密码的规则。
一个有 m 行，n 列的矩阵 A 的书写形式如下。 $$ A=\begin{bmatrix} a_{11} &amp;amp; a_{12} &amp;amp; \dots &amp;amp; a_{1n} \\ a_{21} &amp;amp; a_{22} &amp;amp; \dots &amp;amp; a_{2n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{m1} &amp;amp; a_{m2} &amp;amp; \dots &amp;amp; a_{mn} \end{bmatrix} $$
1.2 矩阵加法/减法 矩阵加减法规则如下。设有矩阵 A、B 如下。 $$ A=\begin{bmatrix} a_{11} &amp;amp; a_{12} &amp;amp; \dots &amp;amp; a_{1n} \\ a_{21} &amp;amp; a_{22} &amp;amp; \dots &amp;amp; a_{2n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{m1} &amp;amp; a_{m2} &amp;amp; \dots &amp;amp; a_{mn} \end{bmatrix},B=\begin{bmatrix} b_{11} &amp;amp; b_{12} &amp;amp; \dots &amp;amp; b_{1n} \\ b_{21} &amp;amp; b_{22} &amp;amp; \dots &amp;amp; b_{2n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ b_{m1} &amp;amp; b_{m2} &amp;amp; \dots &amp;amp; b_{mn} \end{bmatrix} $$ 则计算 A±B 的规则如下。 $$ A±B=\begin{bmatrix} a_{11}±b_{11} &amp;amp; a_{12}±b_{12} &amp;amp; \dots &amp;amp; a_{1n}±b_{1n} \\ a_{21}±b_{21} &amp;amp; a_{22}±b_{22} &amp;amp; \dots &amp;amp; a_{2n}±b_{2n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{m1}±b_{m1} &amp;amp; a_{m2}±b_{m2} &amp;amp; \dots &amp;amp; a_{mn}±b_{mn} \end{bmatrix} $$ 性质：</description></item><item><title>密码学入门02 - 古典密码#2</title><link>https://nnnewb.github.io/blog/p/cryptography-introduction-02/</link><pubDate>Thu, 11 Nov 2021 16:53:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/cryptography-introduction-02/</guid><description>前言 从单表代替密码开始，继续学习古典密码。
0x01 playfair 密码 playfair 这个词乍一听我甚至有点迷惑，啥意思，公平竞赛吗。之后才知道原来是人名。
概述 playfair 密码是最著名的多字母代替密码，它把明文中的字母对转换成密文的字母对，每次加密输入两个字母，输出两个字母。
playfair 算法基于一个由密钥词构成的 5x5 字母矩阵，将密钥词去除重复字母后，和字母表剩余的字母按左至右、上至下的顺序填充进表里。
举例来说，用 pojie 作为密钥词。
- - - - - p o j i e a b c d f g/h k l m n q r s t u v w x y z 需要注意的是字母表有26个字母，但 playfair 的字母矩阵只有 25 个空格。出现字母表不是 5 的整数倍的情况时可以选择将多出来的字母视作同一个，或者去掉不常用的字母，使其正好填满矩阵。比如图中的g/h，好孩子不要学哦。常见的情况是i/j或者去掉z或q。</description></item><item><title>密码学入门01 - 古典密码#1</title><link>https://nnnewb.github.io/blog/p/cryptography-introduction-01/</link><pubDate>Thu, 11 Nov 2021 11:35:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/cryptography-introduction-01/</guid><description>前言 本文是学习《密码编码学与网络安全》一书的笔记，关于传统加密技术一章。
0x01 对称密码模型 对称加密，也称传统加密或单钥加密，是20世纪70年代公钥密码产生之前唯一的加密类型。迄今为止，它仍是使用最广泛的加密类型。
对称加密方案有5个基本成分：
明文：原始可以理解的消息或数据，是算法的输入。 加密算法：加密算法对明文进行各种代替和变换。 密钥：密钥也是加密算法的输入。密钥独立于明文和算法。算法根据所用的特定密钥而产生不同的输出。算法所用的确切代替和变换也依靠密钥。 密文：作为算法的输出，看起来完全随机而杂乱的消息，依赖于明文和密钥。对于给定的消息，不同密钥产生不同的密文，密文看上去是随机的数据流并且其意义是不可理解的。 解密算法：本质上是加密算法的逆运算。输入密文和密钥，输出原始明文。 image-20211110140236382
传统密码的安全使用要满足两个要求：
加密算法必须是足够强的。即使攻击者拥有一定数量的密文和产生这些密文的明文，他也不能破译密文或发现密钥。 发送者和接收者必须在某种安全的形式下获得密钥并保证密钥安全。如果有人发现密钥，并知道算法，就能解读使用该密钥加密的所有通信。 我们假设基于已知密文和加密/解密算法而破译消息是不实际的，我们不需要算法保密，仅需要密钥保密。如果密钥是由信息的发送方产生的，那么它要通过某种安全信道发送到接收方；另一种是由第三方生成密钥后再安全地分发给发送方和接收方。
// 明文X，共 m 个元素 byte[m] X = {X1,X2,X3,X4,...,Xm}; // 密钥K，共 j 个元素 byte[j] K = {K1,K2,K3,K4,...,Kj}; // 加密算法E，以明文和密钥为输入，输出密文 Y byte[n] Y = E(X, K); // 解密算法D，以密文和密钥为输入，输出明文 X byte[] X = D(Y, K); 1.1 密码编码学 密码编码系统有三个独立特征：
转换明文为密文的运算类型。所有的加密算法都基于两个原理：代替和置换。代替是将明文中的每个元素（如位、字母、位组或字母组）映射成另一个元素；置换是将明文中的元素重新排列。上述运算的基本要求是不允许有信息丢失（所有运算都是可逆的）。大多密码体制也称为乘积密码系统，都使用了多层代替和置换。 所用的密钥数。如果发送方和接收方使用相同的密钥，这种密码就称为对称密码、单密钥密码或传统密码。如果发收双方使用不同的密钥，这种密码就称为非对称密码、双钥或公钥密码。 处理明文的方法。分组密码每次处理输入的一组元素，相应地输出一组元素。流密码则是连续地处理输入元素，每次输出一个元素。 攻击密码系统的典型目标是恢复使用的密钥，而不仅仅恢复出单个密文对应的明文。攻击传统密码有两种通用的方法。
密码分析学：密码分析学攻击依赖于算法的性质、明文的一般特征或某些明密文对。这种攻击形式企图利用算法的特征来推导出特定的明文或使用的密钥。 穷举攻击：攻击者对一条密文尝试所有可能的密钥，直到把它转化为可读的有意义的明文。平均而言，获得成功至少要尝试所有可能的密钥的一半。 基于密码分析者知道的信息的多少，概括密码攻击的几种类型如下。
攻击类型 攻击者已知的信息 唯密文攻击 加密算法；密文； 已知明文攻击 加密算法；密文；与待解密密文同一密钥加密的一个或多个明密文对； 选择明文攻击 加密算法；密文；分析者选择的明文，以及对应的（使用和待解密密文同一密钥）加密的密文； 选择密文攻击 加密算法；密文；分析者选择的密文，以及对应的（使用和待解密密文同一密钥）的解密明文； 选择文本攻击 加密算法；密文；分析者选的明文，以及对应的密文；分析者选择的密文，以及对应的明文，使用和待解密密文同一密钥。 唯密文攻击最容易防范，但很多情况下分析者可以得到更多的信息。比如 postscript 格式加密的文件总是以相同的格式开头，电子金融消息往往有标准化的文件头或者标志，类似的例子还有很多，这些都是已知明文攻击的例子。有这些知识的分析者就可以从转换明文的方法入手来推导出密钥。</description></item></channel></rss>