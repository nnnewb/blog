<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/categories/golang/</link><description>Recent content in golang on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 01 Mar 2022 12:30:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/categories/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>go-kit 笔记</title><link>https://nnnewb.github.io/blog/p/go-kit-note/</link><pubDate>Tue, 01 Mar 2022 12:30:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/go-kit-note/</guid><description>前言 初步看了下 gokit 的案例 stringsvc和apigateway，记录一下对 gokit 的映像。
gokit定位 Go kit is a programming toolkit for building microservices (or elegant monoliths) in Go. We solve common problems in distributed systems and application architecture so you can focus on delivering business value.
Go has emerged as the language of the server, but it remains underrepresented in so-called &amp;ldquo;modern enterprise&amp;rdquo; companies like Facebook, Twitter, Netflix, and SoundCloud. Many of these organizations have turned to JVM-based stacks for their business logic, owing in large part to libraries and ecosystems that directly support their microservice architectures.</description></item><item><title>gRPC-Gateway 用作多个 gRPC 服务的网关</title><link>https://nnnewb.github.io/blog/p/grpc-gateway-used-as-multiple-grpc-server-gateway/</link><pubDate>Wed, 23 Feb 2022 17:30:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/grpc-gateway-used-as-multiple-grpc-server-gateway/</guid><description>前言 众所周知，API网关是微服务架构的重要组件，起到一个整流过滤的作用。虽然 gRPC-Gateway 要啥没啥，和 API 网关的模式也扯不上太多关系，但总之先起个高调。
然后就是真正遇到的问题了。在旧的架构里，gRPC-Gateway 的用法，是对每个需要暴露 HTTP 服务的 gRPC 服务都起一个对应的 gRPC-Gateway 。最早的做法是 gRPC-Gateway 服务单独作为一个 POD ，gRPC 服务实现也单独一个 POD 。后来我改成了 Gateway 和 服务在同一个 POD 内，起两个 container 。
之前的做法都存在一个问题，就是 gRPC-Gateway 要分配少量的 CPU 和内存配额，虽然每个 gRPC-Gateway 服务分到的内存和CPU都很少，但架不住服务多，内存和 CPU 的配额都占用了不少，实际用到的少得可怜，大部分配额都是浪费。
下面具体分析下怎么把 gateway 单独提取成一个 POD，给所有 gRPC 服务当网关，同时保持负载均衡发挥作用，提供无缝扩容。
实现网关 官方demo // Create a client connection to the gRPC server we just started // This is where the gRPC-Gateway proxies the requests conn, err := grpc.DialContext( context.</description></item><item><title>protogen代码生成</title><link>https://nnnewb.github.io/blog/p/protogen-code-generation/</link><pubDate>Mon, 21 Feb 2022 16:32:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/protogen-code-generation/</guid><description>前言 最大的问题其实是 proto 直接生成的 swagger 不好用，过去的 gRPC 写法只在服务端，客户端没享受到静态类型定义的接口的快乐，而且手工写的文档还有一堆很无语的问题，整个系统维护起来蛋疼无比。
后来解决办法也简单，代码生成，缺什么生成什么，先后经历了用 go + proto解析写改成用 typescript 写，再改回 go + protogen，一番折腾下来最后还是用 protogen 最简单舒服。
这篇博客主要就是介绍下 protogen 配上 go 模板能做到的事情。
protogen介绍 protogen的官方文档在这里，protogen是google官方protoc-gen-go插件使用的支持库，代码托管在github.com/protocolbuffers/protobuf-go 。可以通过 protoc-gen-go 的 main 包代码 初窥门径。
不过在开始前，还得先了解下 protoc 插件是怎么工作的。从官方文档other languages and plugins摘录如下。
protoc, the Protocol Buffers Compiler, can be extended to support new languages via plugins. A plugin is just a program which reads a CodeGeneratorRequest protocol buffer from standard input and then writes a CodeGeneratorResponse protocol buffer to standard output.</description></item><item><title>基于栈的虚拟机</title><link>https://nnnewb.github.io/blog/p/stack-based-virtual-machine-for-minilang/</link><pubDate>Mon, 13 Dec 2021 16:20:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/stack-based-virtual-machine-for-minilang/</guid><description>前言 之前写了个s表达式求值器，很简陋，直接在抽象语法树上执行。只是这样的话其实还没啥意思，所以再试试改进成在基于栈的虚拟机上执行。
0x01 虚拟机模型 首先得承认对这些语言层级的虚拟机不熟，基本是随便设计的。
对象模型 虚拟机指令操作的目标是 对象 ，包括内建的对象和用户定义的对象，虚拟机指令操作的基本单位也是对象。
目前关注的是内建的对象，简单抽象出了几个基本类型。
type Object interface { TypeName() string } type UInt uint64 func (u UInt) TypeName() string { return &amp;#34;UInt&amp;#34; } type Float float64 func (f Float) TypeName() string { return &amp;#34;Float&amp;#34; } type Boolean bool func (b Boolean) TypeName() string { return &amp;#34;boolean&amp;#34; } type String string func (s String) TypeName() string { return &amp;#34;string&amp;#34; } type Symbol string func (s Symbol) TypeName() string { return &amp;#34;symbol&amp;#34; } type Nil struct{} func (n Nil) TypeName() string { return &amp;#34;nil&amp;#34; } 省略了一部分，领会精神即可。上面定义的 Symbol 类型其实就是 #ident 这种语法元素，目的是保持语义上的简洁。</description></item><item><title>一个s表达式求值器</title><link>https://nnnewb.github.io/blog/p/a-s-exp-evaluator/</link><pubDate>Thu, 09 Dec 2021 17:11:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/a-s-exp-evaluator/</guid><description>前言 翻没看过的藏书的时候找出一本《SICP》的 PDF（PS：已经买了正版书），想起曾经拿 Rust 写玩具解释器，结果现在连 Rust 本身都已经快忘光了。
所以就当怀旧，写个很简单的玩具，s表达式求值器。
技术栈 语言选择了 Go，用 gocc 生成 Parser/Lexer 。虽然说手写+调试 Lexer/Parser 也是挺快乐的，但毕竟只是怀旧重温下当年愣头青的自己，不想花太多时间。
词法定义 简单解释下 gocc 定义词法元素的 DSL 是怎么回事。gocc 的这个 DSL 是类似于 EBNF 的语法（自称）， _letter: 'a'-'z' 就是一条产生式，:前面是产生式的名称，后面是模式。
产生式名称也有特殊含义。
! 开头的产生式会被 Lexer 忽略。 _ 开头的产生式叫做 regDefId，可以理解成给后面的模式定义的别名。 a-z小写字母开头的是 token，也就是一般说的词法元素定义了。 值得注意的是 token 不能被用作其他词法元素产生式的模式部分，但 regDefId 可以，所以要注意要复用的规则应该定义成下划线开头。
比如说下面的例子。
// example 1 letter: &amp;#39;a&amp;#39;-&amp;#39;z&amp;#39;; identifier: letter; // Error! // example 2 _letter: &amp;#39;a&amp;#39;-&amp;#39;z&amp;#39;; identifier: _letter; // OK 下面是求值器的词法元素定义。
!whitespace: &amp;#39; &amp;#39; | &amp;#39;\t&amp;#39; | &amp;#39;\r&amp;#39; | &amp;#39;\n&amp;#39;; !</description></item><item><title>信号量 vs 互斥锁</title><link>https://nnnewb.github.io/blog/p/%E4%BF%A1%E5%8F%B7%E9%87%8F-vs-%E4%BA%92%E6%96%A5%E9%94%81/</link><pubDate>Thu, 26 Aug 2021 00:00:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E4%BF%A1%E5%8F%B7%E9%87%8F-vs-%E4%BA%92%E6%96%A5%E9%94%81/</guid><description>看 go-patterns/semaphore.md at master · tmrts/go-patterns (github.com) 时产生了疑问，信号量为啥长得和互斥锁没啥区别呢。于是就谷歌了一圈，重温下一些关于并发的知识，对比信号量 semaphore 和互斥锁 mutex 。
互斥锁 mutex 以 pthread 自带的互斥锁为例，提供了三种不同类型的互斥锁：
PTHREAD_MUTEX_NORMAL ，普通的互斥锁，不支持死锁检测（does not detect deadlock），不支持递归加锁（relock without first unlocking it 会导致死锁），不检测解锁线程，解锁一个未加锁的互斥锁是未定义行为（undefined behavior）。 PTHREAD_MUTEX_ERRORCHECK，带错误检查的互斥锁，不支持递归加锁（会返回错误），解锁其他线程的互斥锁会返回错误，解锁未加锁的互斥锁会返回错误。 PTHREAD_MUTEX_RECURSIVE，递归加锁（relock with out unlocking it）会成功，解锁时需要调用解锁的次数和加锁时调用加锁的次数相同。解锁其他线程的互斥锁会返回错误。解锁未加锁的互斥锁会返回错误。 PTHREAD_MUTEX_DEFAULT，默认互斥锁类型，对这一类型的互斥锁递归加锁时行为是未定义的，解锁未加锁的互斥锁行为是未定义的，解锁其他线程的互斥锁行为是未定义的。这一类型的互斥锁通常映射为另外几种互斥锁之一。 可以比较清楚地看出，互斥锁有三个基本特征：
是否可重复加锁 是否可解锁未加锁的互斥锁 是否可解锁被其他人加锁的互斥锁 最严格的 PTHREAD_MUTEX_ERRORCHECK 类型互斥锁，对此定义是 NO、NO、NO 。
互斥锁的基本使用方式和使用场景有点像厕所的坑位：
抢坑位，锁门 你懂的 解锁，出门 其中有隐含的信息包括：
坑位是提前选择好的，你只能抢一个坑位，不能抢多个坑位。 坑位在使用期间是独占的，你不能和别人分享一个坑位。 只有你自己能解锁坑位，谁也不想办事儿的时候有人闯进来吧？ 而递归加锁这一特殊场景，我寻思吧，有点难拿坑位比喻。反正也不重要，就别管了。
信号量 semaphore 信号量本质上是一个整型值，不细分什么类型了。还是用 pthread 举例吧，依据 POSIX 标准。
对信号量的操作可以先简单分5种。
sem_init(sem,pshared,value)，初始化一个信号量，可以指定要不要在 fork() 创建的进程间共享，还可以指定信号量初始值。 sem_wait(sem)，等待信号量，信号量等于0时阻塞，其他线程通过sem_post唤醒。 sem_post(sem)，发送信号量，唤醒阻塞在sem_wait的线程。 sem_getvalue(sem,valp)，获取信号量当前值。 sem_destroy(sem)，销毁信号量。 信号量的主要特征就是它的值：</description></item><item><title>面试题之 goroutine 运行顺序</title><link>https://nnnewb.github.io/blog/p/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B-goroutine-%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/</link><pubDate>Wed, 04 Aug 2021 10:37:24 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B-goroutine-%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/</guid><description>不是我做的沙雕面试题，在 segmentfault 上看到的。
原题 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;sync&amp;#34; ) func main() { runtime.GOMAXPROCS(1) wg := sync.WaitGroup{} wg.Add(10) for i := 0; i &amp;lt; 5; i++ { go func() { fmt.Println(&amp;#34;A:&amp;#34;, i) wg.Done() }() } for i := 0; i &amp;lt; 5; i++ { go func(num int) { fmt.Println(&amp;#34;B:&amp;#34;, num) wg.Done() }(i) } wg.Wait() } 问：代码输出结果是什么？
胡乱分析 第一眼进去看到 runtime.GOMAXPROCS(1) ，初步怀疑是又在考什么 GMP 面试题了。
但凡说到 Go 面试好像就一定要考一下 goroutine 调度和 GMP 模型，招进来又只让你写 curd 。搞得面试跟考试背书一样。</description></item><item><title>从零实现一个容器</title><link>https://nnnewb.github.io/blog/p/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8/</link><pubDate>Mon, 31 May 2021 16:16:52 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8/</guid><description>前言 自从看了cocker项目的 ppt 之后就有点念念不忘的意思了，实现一个 docker 或 docker 的类似物看起来并不是做不到的事情。
于是就动手试一试。
核心技术 namespace 命名空间包装全局系统资源，让在命名空间中的进程看起来就像是有自己独立隔离的全局资源一样。命名空间中的全局资源对命名空间中的其他进程都是可见的，但对命名空间外的进程不可见。命名空间用途之一就是实现容器。
Linux provides the following namespaces: Namespace Constant Isolates Cgroup CLONE_NEWCGROUP Cgroup root directory IPC CLONE_NEWIPC System V IPC, POSIX message queues Network CLONE_NEWNET Network devices, stacks, ports, etc. Mount CLONE_NEWNS Mount points PID CLONE_NEWPID Process IDs User CLONE_NEWUSER User and group IDs UTS CLONE_NEWUTS Hostname and NIS domain name 几个命名空间的 API
clone setns unshare 不得不说 man 7 namespaces 对 namespace 的解释已经非常到位了。</description></item><item><title>go 的 defer 语句</title><link>https://nnnewb.github.io/blog/p/go-%E7%9A%84-defer-%E8%AF%AD%E5%8F%A5/</link><pubDate>Tue, 05 Jan 2021 10:01:48 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/go-%E7%9A%84-defer-%E8%AF%AD%E5%8F%A5/</guid><description>昨天对项目做了个小重构，主要是对以前手写的 stmt.Close 没处理返回值的问题、还有各种该记录日志的地方没记日志等等，做了下处理。
老实说这事儿做着做着还有种奇妙的快感，类似于看高压水枪清污视频的感觉。哈哈，也亏领导不管事，代码也不 Review ，测试=摆设。
这不一上班就发现好多问题，幸好只推送到内网。
笑中带泪.gif
0x01 问题描述 问题倒是挺简单的，看下面的代码。
stmt := db.Prepare(query) defer SilentLogError(stmt.Close(), &amp;#34;stmt close failed&amp;#34;) row := stmt.QueryRow(params...) defer row.Close() if err = row.Scan(vars...); err != nil { return nil, err } return vars, nil 那么，请问上面的代码有什么问题呢？
标题都说了 defer 了，那问题肯定是出在 defer 这一行上。
0x02 defer 的求值 简单的结论就是: defer f() 的参数在 defer 这一行求值
具体到上面的例子，defer f(i()) 这样的形式，可以先分成三个部分。
defer 本身的执行时机 i() 的求值时机 f() 的求值时机 把这三部分排一下序:
i() defer defer 把参数求值后包装成一个新函数延迟执行</description></item><item><title>go语言实战之解密ons脚本</title><link>https://nnnewb.github.io/blog/p/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E4%B9%8B%E8%A7%A3%E5%AF%86ons%E8%84%9A%E6%9C%AC/</link><pubDate>Sun, 16 Dec 2018 23:44:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E4%B9%8B%E8%A7%A3%E5%AF%86ons%E8%84%9A%E6%9C%AC/</guid><description>Intro ons 是一个开放源代码的视觉小说引擎，以简单实用出名。本博用 golang 来解密 ons 引擎的.dat和.nt2脚本，主要实践目标是异步解密输出。
算法 .dat的加密非常简单，一次异或。密码是0x84。
可以用 go 非常简单粗暴地写出以下代码。
for i := 0; i &amp;lt; len(buf); i++ { buf[i] ^= 0x84 } .nt2的加密同样简单，一次异或，密码是0x85 &amp;amp; 0x97。
可以用 go 非常粗暴地写出以下代码。
for i := 0; i &amp;lt; len(buf); i++ { buf[i] = (buf[i] ^ (0x85 &amp;amp; 0x97)) - 1 } 异步读文件 go 方式比较多，ioutil或者bufio或者os都有文件模块。这里采用bufio套os.Open的方式读文件。
func readFile(p string, outChannel chan []byte) { // 只读方式打开文件 file, err := os.OpenFile(p, os.O_RDONLY, 0644) if err !</description></item></channel></rss>