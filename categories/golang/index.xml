<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/categories/golang/</link><description>Recent content in golang on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 04 Aug 2021 10:37:24 +0000</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/categories/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>面试题之 goroutine 运行顺序</title><link>https://nnnewb.github.io/blog/p/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B-goroutine-%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/</link><pubDate>Wed, 04 Aug 2021 10:37:24 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B-goroutine-%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/</guid><description>不是我做的沙雕面试题，在 segmentfault 上看到的。
原题 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;sync&amp;#34; ) func main() { runtime.GOMAXPROCS(1) wg := sync.WaitGroup{} wg.Add(10) for i := 0; i &amp;lt; 5; i++ { go func() { fmt.Println(&amp;#34;A:&amp;#34;, i) wg.Done() }() } for i := 0; i &amp;lt; 5; i++ { go func(num int) { fmt.Println(&amp;#34;B:&amp;#34;, num) wg.Done() }(i) } wg.Wait() } 问：代码输出结果是什么？
胡乱分析 第一眼进去看到 runtime.GOMAXPROCS(1) ，初步怀疑是又在考什么 GMP 面试题了。
但凡说到 Go 面试好像就一定要考一下 goroutine 调度和 GMP 模型，招进来又只让你写 curd 。搞得面试跟考试背书一样。</description></item><item><title>从零实现一个容器</title><link>https://nnnewb.github.io/blog/p/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8/</link><pubDate>Mon, 31 May 2021 16:16:52 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8/</guid><description>前言 自从看了cocker项目的 ppt 之后就有点念念不忘的意思了，实现一个 docker 或 docker 的类似物看起来并不是做不到的事情。
于是就动手试一试。
核心技术 namespace 命名空间包装全局系统资源，让在命名空间中的进程看起来就像是有自己独立隔离的全局资源一样。命名空间中的全局资源对命名空间中的其他进程都是可见的，但对命名空间外的进程不可见。命名空间用途之一就是实现容器。
Linux provides the following namespaces: Namespace Constant Isolates Cgroup CLONE_NEWCGROUP Cgroup root directory IPC CLONE_NEWIPC System V IPC, POSIX message queues Network CLONE_NEWNET Network devices, stacks, ports, etc. Mount CLONE_NEWNS Mount points PID CLONE_NEWPID Process IDs User CLONE_NEWUSER User and group IDs UTS CLONE_NEWUTS Hostname and NIS domain name 几个命名空间的 API
clone setns unshare 不得不说 man 7 namespaces 对 namespace 的解释已经非常到位了。</description></item><item><title>go 的 defer 语句</title><link>https://nnnewb.github.io/blog/p/go-%E7%9A%84-defer-%E8%AF%AD%E5%8F%A5/</link><pubDate>Tue, 05 Jan 2021 10:01:48 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/go-%E7%9A%84-defer-%E8%AF%AD%E5%8F%A5/</guid><description>昨天对项目做了个小重构，主要是对以前手写的 stmt.Close 没处理返回值的问题、还有各种该记录日志的地方没记日志等等，做了下处理。
老实说这事儿做着做着还有种奇妙的快感，类似于看高压水枪清污视频的感觉。哈哈，也亏领导不管事，代码也不 Review ，测试=摆设。
这不一上班就发现好多问题，幸好只推送到内网。
笑中带泪.gif
0x01 问题描述 问题倒是挺简单的，看下面的代码。
stmt := db.Prepare(query) defer SilentLogError(stmt.Close(), &amp;#34;stmt close failed&amp;#34;) row := stmt.QueryRow(params...) defer row.Close() if err = row.Scan(vars...); err != nil { return nil, err } return vars, nil 那么，请问上面的代码有什么问题呢？
标题都说了 defer 了，那问题肯定是出在 defer 这一行上。
0x02 defer 的求值 简单的结论就是: defer f() 的参数在 defer 这一行求值
具体到上面的例子，defer f(i()) 这样的形式，可以先分成三个部分。
defer 本身的执行时机 i() 的求值时机 f() 的求值时机 把这三部分排一下序:
i() defer defer 把参数求值后包装成一个新函数延迟执行</description></item><item><title>go语言实战之解密ons脚本</title><link>https://nnnewb.github.io/blog/p/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E4%B9%8B%E8%A7%A3%E5%AF%86ons%E8%84%9A%E6%9C%AC/</link><pubDate>Sun, 16 Dec 2018 23:44:00 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E4%B9%8B%E8%A7%A3%E5%AF%86ons%E8%84%9A%E6%9C%AC/</guid><description>Intro ons 是一个开放源代码的视觉小说引擎，以简单实用出名。本博用 golang 来解密 ons 引擎的.dat和.nt2脚本，主要实践目标是异步解密输出。
算法 .dat的加密非常简单，一次异或。密码是0x84。
可以用 go 非常简单粗暴地写出以下代码。
for i := 0; i &amp;lt; len(buf); i++ { buf[i] ^= 0x84 } .nt2的加密同样简单，一次异或，密码是0x85 &amp;amp; 0x97。
可以用 go 非常粗暴地写出以下代码。
for i := 0; i &amp;lt; len(buf); i++ { buf[i] = (buf[i] ^ (0x85 &amp;amp; 0x97)) - 1 } 异步读文件 go 方式比较多，ioutil或者bufio或者os都有文件模块。这里采用bufio套os.Open的方式读文件。
func readFile(p string, outChannel chan []byte) { // 只读方式打开文件 file, err := os.OpenFile(p, os.O_RDONLY, 0644) if err !</description></item></channel></rss>