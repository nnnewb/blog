<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>unity3d on weakptr's 笔记</title><link>https://uniqptr.gitee.io/categories/unity3d/</link><description>Recent content in unity3d on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 17 Dec 2018 02:29:00 +0000</lastBuildDate><atom:link href="https://uniqptr.gitee.io/categories/unity3d/index.xml" rel="self" type="application/rss+xml"/><item><title>unity3d 键盘控制移动</title><link>https://uniqptr.gitee.io/p/unity3d-%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E7%A7%BB%E5%8A%A8/</link><pubDate>Mon, 17 Dec 2018 02:29:00 +0000</pubDate><guid>https://uniqptr.gitee.io/p/unity3d-%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E7%A7%BB%E5%8A%A8/</guid><description>void HandleKeyboardAction() { var horizontal = Input.GetAxis(&amp;#34;Horizontal&amp;#34;) * PlayerMotionScaleLevel * Time.deltaTime; var vertical = Input.GetAxis(&amp;#34;Vertical&amp;#34;) * PlayerMotionScaleLevel * Time.deltaTime; var motion = transform.rotation * new Vector3(horizontal, 0, vertical); var mag = motion.magnitude; motion.y = 0; Player.transform.position += motion.normalized * mag; } 极其简单的做法，获取到键盘移动的轴之后，用摄像机的旋转四元数乘一下，即可得到旋转后的向量，加上去就 ok 了。
需要注意的是这里用摄像机的四元数旋转要求摄像机必须只在 x 和 y 两个轴旋转。
先备份一下三维向量的数量值，这是为了能保证摄像机向上和向下看时，平面 x 和 z 轴上的分量不会过小，保持一致的移动速度。
用四元数旋转完成后，去除 y 轴的值，使目标只在当前平面上移动。再用算出来的向量的单位向量乘上之前备份的数量值，得到平面上移动的偏移向量。
最后，算出新的位置坐标。</description></item><item><title>Unity3D 键盘控制物体平面移动（操作相对于摄像机方向）</title><link>https://uniqptr.gitee.io/p/unity3d-%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E7%89%A9%E4%BD%93%E5%B9%B3%E9%9D%A2%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%AF%B9%E4%BA%8E%E6%91%84%E5%83%8F%E6%9C%BA%E6%96%B9%E5%90%91/</link><pubDate>Sat, 03 Nov 2018 18:57:00 +0000</pubDate><guid>https://uniqptr.gitee.io/p/unity3d-%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E7%89%A9%E4%BD%93%E5%B9%B3%E9%9D%A2%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%AF%B9%E4%BA%8E%E6%91%84%E5%83%8F%E6%9C%BA%E6%96%B9%E5%90%91/</guid><description>Intro 目标是实现目标随摄像机方向的不同而进行不同方向移动——而且，目标不需要随摄像机一起旋转。
使用摄像机的四元数旋转 void HandleKeyboardAction() { var horizontal = Input.GetAxis(&amp;#34;Horizontal&amp;#34;) * PlayerMotionScaleLevel * Time.deltaTime; var vertical = Input.GetAxis(&amp;#34;Vertical&amp;#34;) * PlayerMotionScaleLevel * Time.deltaTime; var motion = transform.rotation * new Vector3(horizontal, 0, vertical); var mag = motion.magnitude; motion.y = 0; Player.transform.position += motion.normalized * mag; } 极其简单的做法，获取到键盘移动的轴之后，用摄像机的旋转四元数乘一下，即可得到旋转后的向量，加上去就 ok 了。
需要注意的是这里用摄像机的四元数旋转要求摄像机必须只在 x 和 y 两个轴旋转。
先备份一下三维向量的数量值，这是为了能保证摄像机向上和向下看时，平面 x 和 z 轴上的分量不会过小，保持一致的移动速度。
用四元数旋转完成后，去除 y 轴的值，使目标只在当前平面上移动。再用算出来的向量的单位向量乘上之前备份的数量值，得到平面上移动的偏移向量。
最后，算出新的位置坐标，赋值，完事儿。</description></item><item><title>Unity3d 摄像机跟随旋转的方案</title><link>https://uniqptr.gitee.io/p/unity3d-%E6%91%84%E5%83%8F%E6%9C%BA%E8%B7%9F%E9%9A%8F%E6%97%8B%E8%BD%AC%E7%9A%84%E6%96%B9%E6%A1%88/</link><pubDate>Sat, 03 Nov 2018 18:20:00 +0000</pubDate><guid>https://uniqptr.gitee.io/p/unity3d-%E6%91%84%E5%83%8F%E6%9C%BA%E8%B7%9F%E9%9A%8F%E6%97%8B%E8%BD%AC%E7%9A%84%E6%96%B9%E6%A1%88/</guid><description>Intro 主要想探讨的是如何令摄像机随鼠标操作进行旋转和移动，摄像机跟随的脚本官方就有 Example。
方案：独立的角度变量 主要的特点是使用独立的角度变量，每次处理鼠标移动操作都会创建一个新的Quaternion用于计算。
先看 Demo。
public class PlayerControls : MonoBehaviour { public GameObject Player; public float Distance; //public float CameraRepositionSpeed; public float MouseMotionScaleLevel; public bool ReverseAxisY; public float PitchMaximum; public float PitchMinimum; private float _CurrentCameraAngleAroundX; private float _CurrentCameraAngleAroundY; private Vector3 _PositionTarget; // Use this for initialization void Start() { } // Update is called once per frame void Update() { _CurrentCameraAngleAroundX += Input.GetAxis(&amp;#34;Mouse Y&amp;#34;) * MouseMotionScaleLevel * Time.</description></item></channel></rss>