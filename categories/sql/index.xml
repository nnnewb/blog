<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sql on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/categories/sql/</link><description>Recent content in sql on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 09 Jul 2021 09:29:22 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/categories/sql/index.xml" rel="self" type="application/rss+xml"/><item><title>MySQL XA 事务和分布式事务处理模型：2阶段提交</title><link>https://nnnewb.github.io/blog/p/mysql-xa-distributed-transaction-processing-model-2pc/</link><pubDate>Fri, 09 Jul 2021 09:29:22 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/mysql-xa-distributed-transaction-processing-model-2pc/</guid><description>&lt;p>关于 MySQL XA 事务和 2PC（两阶段提交）分布式事务处理模型（&lt;em>Distributed Transaction Processing, DTP Model&lt;/em>）的学习笔记。&lt;/p>
&lt;!-- more -->
&lt;h2 id="事务">事务&lt;/h2>
&lt;h3 id="分布式事务xa">分布式事务XA&lt;/h3>
&lt;h4 id="介绍">介绍&lt;/h4>
&lt;p>MySQL内建分布式事务支持（&lt;code>XA&lt;/code>），参考文档列出如下&lt;/p>
&lt;ul>
&lt;li>[MySQL Manual - XA](&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_xa" target="_blank" rel="noopener"
>MySQL :: MySQL 8.0 Reference Manual :: MySQL Glossary&lt;/a>)&lt;/li>
&lt;li>[MySQL Manual - XA Transaction](&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/xa.html" target="_blank" rel="noopener"
>MySQL :: MySQL 8.0 Reference Manual :: 13.3.8 XA Transactions&lt;/a>)&lt;/li>
&lt;li>[MySQL Manual - XA Transaction Statements](&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/xa-statements.html" target="_blank" rel="noopener"
>MySQL :: MySQL 8.0 Reference Manual :: 13.3.8.1 XA Transaction SQL Statements&lt;/a>)&lt;/li>
&lt;li>[MySQL Manual - XA Transaction State](&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/xa-states.html" target="_blank" rel="noopener"
>MySQL :: MySQL 8.0 Reference Manual :: 13.3.8.2 XA Transaction States&lt;/a>)&lt;/li>
&lt;/ul>
&lt;p>XA 事务在 InnoDB 引擎中可用。MySQL XA 事务实现基于 X/Open CAE 文档 《Distributed Transaction Processing: The XA Specification》。这份文档由 &lt;em>Open Group&lt;/em> 发布，可以在 &lt;a class="link" href="http://www.opengroup.org/public/pubs/catalog/c193.htm" target="_blank" rel="noopener"
>http://www.opengroup.org/public/pubs/catalog/c193.htm&lt;/a> 访问。当前 XA 实现的局限可以在 &lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/xa-restrictions.html" target="_blank" rel="noopener"
>Section 13.3.8.3, “Restrictions on XA Transactions”&lt;/a> 查看。&lt;/p>
&lt;p>&amp;hellip;&lt;/p>
&lt;p>XA 事务是全局事务关联的一组事务性动作，要么全部成功，要么全部回滚。本质上，这是让 ACID 属性“提升了一层”，让多个ACID事务可以作为一个全局操作的一部分执行，使得这个全局操作也具备ACID属性。（对于非分布式事务，应用如果对读敏感，则&lt;code>SERIALIZABLE&lt;/code>更推荐。&lt;code>REPEATABLE READ&lt;/code> 在分布式事务中并不是很有效。）&lt;/p>
&lt;h4 id="事务模型">事务模型&lt;/h4>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/image/MySQL-XA-and-2PC-DTP-model/%e4%ba%8b%e5%8a%a1%e6%a8%a1%e5%9e%8b.webp"
loading="lazy"
alt="DTM"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>**AP：**用户程序&lt;/li>
&lt;li>**RMs：**数据库&lt;/li>
&lt;li>**TM：**事务管理器&lt;/li>
&lt;/ul>
&lt;p>用户程序不用介绍。&lt;/p>
&lt;p>根据 Open Group 在 Distributed Transaction Processing Model 中的定义，一个典型的 RM 可以是一个支持事务的数据库（DBMS）。&lt;/p>
&lt;p>TM 则是协调整个二阶段提交过程的中介。AP从TM获得XID，完成 &lt;code>XA START&lt;/code> 到 &lt;code>XA END&lt;/code> ，然后告知 TM 就绪。TM提取本次事务的所有XID，向RMs发出&lt;code>XA PREPARE&lt;/code>请求，如果失败则对每个 XID 发出 &lt;code>XA ROLLBACK&lt;/code> ，成功则继续发出 &lt;code>XA COMMIT&lt;/code> 。&lt;/p>
&lt;p>需注意的是，&lt;code>XA PREPARE&lt;/code> 失败可以通知其他事务回滚，但&lt;code>XA COMMIT&lt;/code> 失败则只能等待数据库恢复，再行重试。&lt;code>XA PREPARE&lt;/code>一旦成功，则&lt;code>XA COMMIT&lt;/code> 一定成功（或者说必须成功）。&lt;/p>
&lt;p>TM 实现要求自身崩溃后必须能清理恢复，防止出现XA事务死锁。&lt;/p>
&lt;ul>
&lt;li>继续 PREPARE 需要提交的事务&lt;/li>
&lt;li>继续 ROLLBACK 未完成 ROLLBACK 的事务&lt;/li>
&lt;li>继续 COMMIT 未能 COMMIT 的事务
&lt;ul>
&lt;li>未能 COMMIT 成功则需要重试直到成功&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>几个 TM 角色（或整套方案）的实现：&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://github.com/seata/seata/" target="_blank" rel="noopener"
>seata/seata: Seata is an easy-to-use, high-performance, open source distributed transaction solution. (github.com)&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://open.unionpay.com/tjweb/product/detail?proId=43" target="_blank" rel="noopener"
>UPSQL Proxy-技术产品- 中国银联开放平台 (unionpay.com)&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://cloud.tencent.com/product/dcdb/" target="_blank" rel="noopener"
>分布式数据库TDSQL MySQL版_企业级分布式数据库解决方案 - 腾讯云 (tencent.com)&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="基本用法">基本用法&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-mysql" data-lang="mysql">&lt;span class="n">XA&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">{&lt;/span>&lt;span class="n">START&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="n">BEGIN&lt;/span>&lt;span class="err">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">xid&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="n">RESUME&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="n">XA&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">END&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">xid&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">SUSPEND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="k">FOR&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MIGRATE&lt;/span>&lt;span class="p">]]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="n">XA&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PREPARE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">xid&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="n">XA&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">COMMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">xid&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ONE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PHASE&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="n">XA&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ROLLBACK&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">xid&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="n">XA&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RECOVER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="k">CONVERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">XID&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>XA START&lt;/code> 后跟随的 &lt;code>JOIN&lt;/code>和&lt;code>RESUME&lt;/code>子句没有任何效果。&lt;/p>
&lt;p>&lt;code>XA END&lt;/code> 后跟随的 &lt;code>SUSPEND&lt;/code> 和 &lt;code>FOR MIGRATE&lt;/code> 子句也没有任何效果。&lt;/p>
&lt;p>任何&lt;code>XA&lt;/code>语句都以&lt;code>XA&lt;/code>关键字开头，大多&lt;code>XA&lt;/code>语句都需要&lt;code>xid&lt;/code>值。&lt;code>xid&lt;/code> 是 &lt;strong>XA事务的标识符&lt;/strong> ，它确定语句应用到哪个XA事务上。&lt;/p>
&lt;p>&lt;code>xid&lt;/code>值可以由客户端指定或 MySQL 服务器生成。&lt;/p>
&lt;p>一个&lt;code>xid&lt;/code>值有一到三个部分：&lt;/p>
&lt;pre>&lt;code>xid: gtrid [, bqual [, formatID ]]
&lt;/code>&lt;/pre>&lt;p>&lt;code>gtrid&lt;/code> 是&lt;strong>全局事务标识符&lt;/strong> ，&lt;code>bqual&lt;/code> 是&lt;strong>分支修饰符&lt;/strong>，&lt;code>formatID&lt;/code>是一个标记 &lt;code>gtrid&lt;/code> 和 &lt;code>bqual&lt;/code> 格式的数字。&lt;/p>
&lt;p>&lt;code>gtrid&lt;/code> 和 &lt;code>bqual&lt;/code> 必须是字符串字面量，最多不超过 64 &lt;strong>字节&lt;/strong> 长。&lt;code>gtrid&lt;/code> 和 &lt;code>bqual&lt;/code> 可以以多种方式指定，可以用引号包围的字符串（&lt;code>'ab'&lt;/code>）；十六进制字符串（&lt;code>X'6162'&lt;/code>，&lt;code>0x6162&lt;/code>）；或者二进制值（&lt;code>b'nnn'&lt;/code>）。&lt;/p>
&lt;p>&lt;code>formatID&lt;/code> 必须是一个无符号整数。&lt;/p>
&lt;p>&lt;code>gtrid&lt;/code> 和 &lt;code>bqual&lt;/code> 值在 MySQL 服务器的底层 XA 支持程序中被解释为字节。不过，服务器在解释包含XA语句的SQL时，可能设置了特定字符集。安全起见，最好将 &lt;code>gtrid&lt;/code> 和 &lt;code>bqual&lt;/code> 写作十六进制字符串形式。&lt;/p>
&lt;p>&lt;code>xid&lt;/code> 值通常是由事务管理器生成。一个事务管理器产生的&lt;code>xid&lt;/code>必须与另一个事务管理器产生的&lt;code>xid&lt;/code>不同。一个给定的事务管理器必须能在 &lt;code>XA RECOVER&lt;/code> 返回的 &lt;code>xid&lt;/code> 列表中识别出属于自己的 &lt;code>xid&lt;/code> 。&lt;/p>
&lt;p>&lt;code>XA START xid&lt;/code> 以指定的 &lt;code>xid&lt;/code> 开启一个新 XA 事务。每个 XA 事务必须包含一个唯一的 &lt;code>xid&lt;/code> ，&lt;code>xid&lt;/code> 不能正在被另一个 XA 事务使用。唯一性通过 &lt;code>gtrid&lt;/code> 与 &lt;code>bqual&lt;/code> 评估。该 XA 事务的后续 XA 语句都必须指定&lt;code>XA START&lt;/code>中指定的 &lt;code>xid&lt;/code>。如果使用XA语句但没有指定一个对应XA事务的&lt;code>xid&lt;/code>，则产生一个错误。&lt;/p>
&lt;p>多个XA事务可以是同一个全局事务的组成部分。在同一个全局事务中所有XA事务的&lt;code>xid&lt;/code>必须使用同一个 &lt;code>gtrid&lt;/code> 值。因此，&lt;code>gtrid&lt;/code> 必须全局唯一以避免混淆。全局事务中XA事务&lt;code>xid&lt;/code> 的 &lt;code>bqual&lt;/code> 部分必须互不相同。（要求 &lt;code>bqual&lt;/code> 不同是当前MySQL实现的限制，并不是XA规范的一部分。）&lt;/p>
&lt;p>&lt;code>XA RECOVER&lt;/code> 语句返回 MySQL 服务器中处于 &lt;code>PREPARED&lt;/code> 状态的 XA 事务信息。输出中每一行都是一个服务器上的 XA 事务，不论是哪个客户端启动的事务。&lt;/p>
&lt;p>执行 &lt;code>XA RECOVER&lt;/code> 需要 &lt;code>XA_RECOVER_ADMIN&lt;/code> 特权。这个特权需求是为了防止用户发现其他不属于自己的事务&lt;code>xid&lt;/code>，不影响XA事务的正常提交和回滚。&lt;/p>
&lt;p>&lt;code>XA RECOVER&lt;/code> 输出类似下面这样&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-mysql" data-lang="mysql">&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">XA&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RECOVER&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="o">+----------+--------------+--------------+--------+&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">formatID&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">gtrid_length&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">bqual_length&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="o">+----------+--------------+--------------+--------+&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">abcdef&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="o">+----------+--------------+--------------+--------+&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>&lt;code>formatID&lt;/code> 是 &lt;code>xid&lt;/code> 中的 &lt;code>formatID&lt;/code> 部分&lt;/li>
&lt;li>&lt;code>gtrid_length&lt;/code> 是 &lt;code>xid&lt;/code> 中 &lt;code>gtrid&lt;/code> 部分的长度（字节单位）&lt;/li>
&lt;li>&lt;code>bqual_length&lt;/code> 是 &lt;code>xid&lt;/code> 中 &lt;code>bqual&lt;/code> 部分的长度（字节单位）&lt;/li>
&lt;/ul>
&lt;p>XID值可能包含不可打印的字符。&lt;code>XA RECOVER&lt;/code> 允许一个可选的 &lt;code>CONVERT XID&lt;/code> 子句，以便客户端可以请求十六进制格式的 XID 值。&lt;/p>
&lt;h4 id="事务状态">事务状态&lt;/h4>
&lt;p>一个 XA 事务经历以下状态&lt;/p>
&lt;ol>
&lt;li>使用&lt;code>XA START&lt;/code>启动的XA事务，进入&lt;code>ACTIVE&lt;/code>状态。&lt;/li>
&lt;li>一个处于&lt;code>ACTIVE&lt;/code>状态的XA事务，可以发出SQL语句填充事务，然后发出&lt;code>XA END&lt;/code>语句。&lt;code>XA END&lt;/code>语句令XA事务进入&lt;code>IDLE&lt;/code>状态。&lt;/li>
&lt;li>一个处于&lt;code>IDLE&lt;/code>状态的XA事务，可以发出&lt;code>XA PREPARE&lt;/code>语句或&lt;code>XA COMMIT ... ONE PHASE&lt;/code>语句。
&lt;ul>
&lt;li>&lt;code>XA PREPARE&lt;/code> 语句令XA事务进入&lt;code>PREPARED&lt;/code> 状态。&lt;code>XA RECOVER&lt;/code> 语句此时可以发现并列出此事务的 XID。&lt;code>XA RECOVER&lt;/code> 可以列出所有处于 &lt;code>PREPARED&lt;/code> 状态的 XA 事务的 XID。&lt;/li>
&lt;li>&lt;code>XA COMMIT ... ONE PHASE&lt;/code> 准备并提交XA事务。&lt;code>xid&lt;/code>不会列出在&lt;code>XA RECOVER&lt;/code>中，因为XA事务实际在执行语句后就结束了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>一个处于&lt;code>PREPARED&lt;/code>状态的XA事务，可以发出&lt;code>XA COMMIT&lt;/code>语句来提交并结束XA事务，或发出&lt;code>XA ROLLBACK&lt;/code>来回滚并结束事务。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/image/MySQL-XA-and-2PC-DTP-model/xa-state-transition-diagram.png"
loading="lazy"
alt="image-20210831105435330"
>&lt;/p>
&lt;p>下面是一个简单的XA事务例子，作为一个全局事务，插入一个行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-mysql" data-lang="mysql">&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">XA&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">START&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;xatest&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="n">Query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OK&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rows&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">affected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">00&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sec&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">mytable&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="n">Query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OK&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">row&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">affected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">04&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sec&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">XA&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">END&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;xatest&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="n">Query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OK&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rows&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">affected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">00&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sec&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">XA&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">PREPARE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;xatest&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="n">Query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OK&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rows&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">affected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">00&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sec&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">XA&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">COMMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;xatest&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="n">Query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OK&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">rows&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">affected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">00&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sec&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在给定客户端连接的上下文中，XA事务和本地事务彼此互斥。举例来说，如果&lt;code>XA START&lt;/code>发出并启动了一个XA事务，此时不能再启动一个本地事务直到XA事务被提交或回滚。反过来说，如果一个本地事务已经通过&lt;code>START TRANSACTION&lt;/code>启动，则不能执行任何XA语句直到本地事务被提交或回滚。&lt;/p>
&lt;p>如果一个XA事务在&lt;code>ACTIVE&lt;/code>状态，则不能发出任何产生隐式提交的语句（如 &lt;code>create table&lt;/code>），因为这违反了XA协议，导致不能回滚XA事务。尝试执行这类语句会导致一个错误：&lt;/p>
&lt;pre>&lt;code>ERROR 1399 (XAE07): XAER_RMFAIL: The command cannot be executed
when global transaction is in the ACTIVE state
&lt;/code>&lt;/pre>&lt;h4 id="xa-事务实验">XA 事务实验&lt;/h4>
&lt;p>准备数据库&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-mysql" data-lang="mysql">&lt;span class="k">create&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">database&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">not&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">exists&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">test&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">create&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">not&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">exists&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">test123&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">bigint&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">primary&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kp">auto_increment&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">varchar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">not&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="no">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>启动一个 XA 事务，插入表，最后提交。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-mysql" data-lang="mysql">&lt;span class="n">xa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;this-is-gtrid&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s1">&amp;#39;this-is-bqual&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">test123&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">values&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;distributed transaction!&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="n">xa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;this-is-gtrid&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s1">&amp;#39;this-is-bqual&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">-- 准备
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">xa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">prepare&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;this-is-gtrid&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s1">&amp;#39;this-is-bqual&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">-- 应该看到上一步 prepare 的 xa 事务
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">xa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">recover&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">-- 提交 xa 事务。
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">xa&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">commit&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;this-is-gtrid&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s1">&amp;#39;this-is-bqual&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c1">-- 或者 rollback
&lt;/span>&lt;span class="c1">-- xa rollback &amp;#39;this-is-gtrid&amp;#39;,&amp;#39;this-is-bqual&amp;#39;;
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行完成后，可以发现表中多了一条记录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-mysql" data-lang="mysql">&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">from&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">test123&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>MySQL 24小时入门笔记 - 4</title><link>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-4/</link><pubDate>Sat, 23 Jun 2018 22:34:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-4/</guid><description>&lt;h2 id="创建表">创建表&lt;/h2>
&lt;h3 id="create-table">CREATE TABLE&lt;/h3>
&lt;p>&lt;code>CREATE TABLE&lt;/code>的作用是创建表。不多说，先创建个简单的学生表。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">char&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">primary&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里没写 &lt;code>ENGINE=InnoDB&lt;/code>，因为这是新 MariaDB 的默认值。&lt;/p>
&lt;p>那么进入正题，&lt;code>CREATE TABLE&lt;/code>的语法如下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">表名&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">列名&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">类型&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">约束和其他属性&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">列名&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">类型&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">约束和其他属性&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">....&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">其他表配置&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>很容易看出，括号里面写的是表的相关配置，包括列定义，主键定义，索引定义等等。&lt;/p>
&lt;h3 id="默认值">默认值&lt;/h3>
&lt;p>在创建表时可以指定默认值，有默认值的列在插入时可以不填。&lt;/p>
&lt;p>语法如下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">表&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">列&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">类型&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DEFAULT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">值&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>即可为一个列设定默认值。&lt;/p>
&lt;h3 id="非空">非空&lt;/h3>
&lt;p>非空约束非常常见。比如说，我们要记录学生信息，包括学号、成绩、姓名，那么学生姓名能不能留空呢？显然不行，因为没有姓名的记录让谁看都是一脸懵逼，这破坏了一条记录的完整性。&lt;/p>
&lt;p>创建非空约束的语法如下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">表&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">列&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">类型&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这就创建了非空约束。非空约束下，插入数据时不能不填写这个列。&lt;/p>
&lt;p>如果需要要求可空，那么这样做。但一般不用特地写，很多&lt;code>DBMS&lt;/code>的列默认创建就是可空的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">表&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">列&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">类型&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="修改表">修改表&lt;/h2>
&lt;h3 id="alter-table">ALTER TABLE&lt;/h3>
&lt;p>&lt;code>ALTER TABLE&lt;/code>可以修改表定义，添加删除列，修改约束，等等。&lt;/p>
&lt;h3 id="添加列">添加列&lt;/h3>
&lt;p>举例，在一个只有学号和姓名两个列的学生表加入一个新的成绩列，代码如下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">ADD&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>语法基本是这样。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">表名&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">ADD&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">列名&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">类型&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">其他属性和约束&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>后面列的定义写法基本和&lt;code>CREATE TABLE&lt;/code>时差不多。&lt;/p>
&lt;h3 id="删除列">删除列&lt;/h3>
&lt;p>和添加列差不多，但删除的关键字&lt;strong>不是&lt;/strong>&lt;code>DELETE&lt;/code>，而是&lt;code>DROP&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">表名&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">DROP&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">列名&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="添加外键约束">添加外键约束&lt;/h3>
&lt;p>外键约束其实保证的是&lt;strong>引用完整性&lt;/strong>，外键约束的列的值必须引用了一个有效的行，或者是&lt;code>NULL&lt;/code>。&lt;/p>
&lt;p>举例来说，我们先有两个表。&lt;/p>
&lt;p>学生表&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>id&lt;/th>
&lt;th>name&lt;/th>
&lt;th>class&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>student 1&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>student 2&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>student 3&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>班级表&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>id&lt;/th>
&lt;th>level&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>Lv5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>Lv4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>Lv3&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>为了让学生表的&lt;code>class&lt;/code>关联到班级表的&lt;code>id&lt;/code>，我们要这样做。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">ADD&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">CONSTRAINT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">fk_students_classes&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">FOREIGN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">class&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">REFERENCES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">classes&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>语法基本是这样子的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">ALTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">保存外键的表&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">ADD&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">CONSTRAINT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">外键约束的名字，一般&lt;/span>&lt;span class="n">fk开头&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">FOREIGN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="err">外键名&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">REFERENCES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">引用的表名&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="err">引用的键名&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>比较复杂。&lt;/p>
&lt;h3 id="删除表">删除表&lt;/h3>
&lt;p>那么终于到了期待已久的删库跑路阶段。&lt;/p>
&lt;p>删除表的语法非常简单，那么从一开始活到现在的这所学校终于干不下去了，校长决定遣散学生。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">DROP&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>人走光了。&lt;/p>
&lt;h3 id="重命名表">重命名表&lt;/h3>
&lt;p>校长决定把学校改成夜总会，于是他写道：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">RENAME&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">school&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">night_club&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要是换行有这么容易就好了&amp;hellip;&amp;hellip;（你敢说回车看看）&lt;/p></description></item><item><title>MySQL 24小时入门笔记 - 3</title><link>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-3/</link><pubDate>Sat, 23 Jun 2018 21:51:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-3/</guid><description>&lt;h2 id="插入">插入&lt;/h2>
&lt;h3 id="insert">INSERT&lt;/h3>
&lt;p>&lt;code>INSERT&lt;/code>用法非常简单。现在我们有表&lt;code>students&lt;/code>如下。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>列名&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>约束&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>id&lt;/td>
&lt;td>int&lt;/td>
&lt;td>primary key&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>name&lt;/td>
&lt;td>char(16)&lt;/td>
&lt;td>NOT NULL&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>向里面插入一条学号为&lt;code>1&lt;/code>，姓名为&lt;code>学姐&lt;/code>的学生，只需要写如下&lt;code>SQL&lt;/code>语句。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;学姐&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>语法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">表&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">列值&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="err">列值&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,...);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中&lt;code>INSERT&lt;/code>语句有一个简单的变体，能比较明确地指明将值交付给哪个列。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;学妹&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样写相当于指明了&lt;code>1&lt;/code>应该是&lt;code>id&lt;/code>，&lt;code>'学妹'&lt;/code>应该是&lt;code>name&lt;/code>。&lt;/p>
&lt;p>插入多条也很简单，只要在&lt;code>VALUES&lt;/code>后面跟更多小括号包围的值集合就行了，记得拿括号分隔，下面给个例子。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;学渣&amp;#39;&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;学霸&amp;#39;&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;学神&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="insert-select">INSERT SELECT&lt;/h3>
&lt;p>这个写法比较有意思，从一个表查询出数据，并插入另一个表。&lt;/p>
&lt;p>举个例子来说，我们有两个班级表，分别叫&lt;code>学渣班&lt;/code>和&lt;code>补习班&lt;/code>，一旦学渣成绩烂到一定程度，那么我们就要把他分配到补习班里去强制补习。&lt;/p>
&lt;p>怎么做呢？看下面啦。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">补习班&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">学渣班&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">学渣班&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">学渣班&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">学渣班&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>值得注意的是，&lt;code>INSERT&lt;/code> 填充补习班表时用的并不是你&lt;code>SELECT&lt;/code>的列名，而是&lt;code>SELECT&lt;/code>后列名的顺序，来对应到要&lt;code>INSERT&lt;/code>的表的列上。&lt;/p>
&lt;p>其他的写法和&lt;code>SELECT&lt;/code>相同。&lt;/p>
&lt;h2 id="修改">修改&lt;/h2>
&lt;h3 id="update">UPDATE&lt;/h3>
&lt;p>&lt;code>UPDATE&lt;/code>语句的作用是修改现存行的数据，非常值得注意的是用&lt;code>UPDATE&lt;/code>语句时一定要小心写&lt;code>WHERE&lt;/code>子句，不然就等着删库跑路吧。&lt;/p>
&lt;p>依然举个实际栗子，学号为&lt;code>10&lt;/code>的学生成绩由于作弊而被取消了，我们要更新他的成绩为 0 分，这真是个悲伤的故事:P&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">UPDATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>语法是这样的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">UPDATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">表名&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">列名&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">新值&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">条件&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>更新多条的话是这样的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">UPDATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">表名&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">列&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">新值&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">列&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">新值&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">列&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">新值&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">条件&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>千万小心，如果没有 &lt;code>WHERE&lt;/code>子句的话，指定的列会全部被设置成这个值。这样一来，所有的学生都变成了 0 分&amp;hellip;&amp;hellip;你会被手撕了的。&lt;/p>
&lt;/blockquote>
&lt;h2 id="删除">删除&lt;/h2>
&lt;h3 id="delete">DELETE&lt;/h3>
&lt;p>&lt;code>DELETE&lt;/code>的作用是删除行，同样的，万分注意&lt;code>WHERE&lt;/code>子句一定要正确编写，不然真的要删库跑路了。&lt;/p>
&lt;p>同样以之前那位作弊的同学为例，很遗憾，他又一次作弊被抓住了，传说中的高科技 AR 技术作弊眼镜也没能让他逃过监考员的火眼金睛，于是他被退学了&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>另一个悲伤的故事:P&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">DELETE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>语法是这样子的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">DELETE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">表名&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">条件&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果不写&lt;code>WHERE&lt;/code>的话&amp;hellip;&amp;hellip;找个好点的新工作吧，不要再去写&lt;code>SQL&lt;/code>了，ORM 多好。&lt;/p>
&lt;blockquote>
&lt;p>注意，不写&lt;code>WHERE&lt;/code>子句会删除这个表里的所有行。&lt;/p>
&lt;/blockquote></description></item><item><title>MySQL 24小时入门笔记 - 2</title><link>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/</link><pubDate>Sat, 23 Jun 2018 15:41:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/</guid><description>&lt;h2 id="查询">查询&lt;/h2>
&lt;h3 id="select">SELECT&lt;/h3>
&lt;p>&lt;code>SELECT&lt;/code>是一个特殊的关键字，它的语义是查询，取出结果。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>注意&lt;/strong>：仅为个人理解。&lt;/p>
&lt;/blockquote>
&lt;h3 id="from">FROM&lt;/h3>
&lt;p>&lt;code>FROM&lt;/code>子句，标识要查询的对象的来源，来源可能是多个的。在查询有多个来源表的情况下，称之为联结查询（&lt;code>Join query&lt;/code>）。&lt;/p>
&lt;p>最常见的常规写法是&lt;code>SELECT column FROM table&lt;/code>，表示从特定表取出所有行的特定列。&lt;/p>
&lt;h3 id="where">WHERE&lt;/h3>
&lt;p>&lt;code>WHERE&lt;/code>子句用于过滤查询的行，只有满足条件的行会被查询出来。&lt;/p>
&lt;p>常见的用法有&lt;code>SELECT column FROM table WHERE column &amp;lt;&amp;gt; 0&lt;/code>，表示在&lt;code>table&lt;/code>表中查询&lt;code>column&lt;/code>非空的行，返回这些行的&lt;code>column&lt;/code>。&lt;/p>
&lt;p>其中的二元关系运算符&lt;code>&amp;lt;&amp;gt;&lt;/code>表示不等于，其他常见的关系运算符还有这些。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>运算符&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>=&lt;/code>&lt;/td>
&lt;td>相等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;gt;&lt;/code>&lt;/td>
&lt;td>大于&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;&lt;/code>&lt;/td>
&lt;td>小于&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;gt;=&lt;/code>&lt;/td>
&lt;td>大于等于&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;=&lt;/code>&lt;/td>
&lt;td>小于等于&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>!=&lt;/code>&lt;/td>
&lt;td>不等于&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;&amp;gt;&lt;/code>&lt;/td>
&lt;td>不等于&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>此外还有一些&lt;code>SQL&lt;/code>关键字可以辅助编写判断逻辑。&lt;/p>
&lt;p>&lt;code>SQL&lt;/code>关键字&lt;code>IN&lt;/code>可以用于判断元素是否在集合中。举例，&lt;code>SELECT 1 IN (1,2,3)&lt;/code>，查询&lt;code>1&lt;/code>是否在&lt;code>1,2,3&lt;/code>这个集合中。被判断的集合需要被小括号包围，并且以逗号分隔元素。&lt;/p>
&lt;p>&lt;code>SQL&lt;/code>关键字&lt;code>BETWEEN&lt;/code>可以判断元素是否在一定区间中。举例，&lt;code>SELECT 1 BETWEEN 0 and 10&lt;/code>，查询&lt;code>1&lt;/code>是否在&lt;code>0&lt;/code>到&lt;code>10&lt;/code>的区间内。语法是&lt;code>BETWEEN [low] AND [high]&lt;/code>，区间较小的一端必须在左侧，较大的一端必须在右侧。&lt;/p>
&lt;p>&lt;code>SQL&lt;/code>关键字&lt;code>LIKE&lt;/code>可以用非常简单的通配符来判断元素是否匹配一定的规则。举例，&lt;code>SELECT 'abcabcabc' LIKE '%CAB%'&lt;/code>，判断字符串&lt;code>abcabcabc&lt;/code>是否匹配&lt;code>%CAB%&lt;/code>。值得注意的是，模式串中的&lt;code>%&lt;/code>代表的是匹配 0 或任意多个字符，就像是正则表达式中的&lt;code>*&lt;/code>一样。此外还有&lt;code>_&lt;/code>，下划线，匹配 1 个任意字符。&lt;/p>
&lt;p>&lt;code>MySQL&lt;/code>扩展的&lt;code>REGEXP&lt;/code>可以用正则表达式来匹配元素是否符合模式串。举例，&lt;code>SELECT 'abcabcabc' REGEXP '.*cab.*'&lt;/code>，正则表达式不做赘述，简单的模式串大家都会写。&lt;/p>
&lt;h3 id="order-by">ORDER BY&lt;/h3>
&lt;p>&lt;code>ORDER BY&lt;/code>就像字面意义上说的那样，按照某个列来进行排序。举例来说，我有一个学生表，记录了学号和姓名，我可以按照学号排序。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认排序是升序，也可以通过指定&lt;code>DESC&lt;/code>或者&lt;code>ASC&lt;/code>来决定怎么排。&lt;code>ASC&lt;/code>是升序，&lt;code>DESC&lt;/code>是降序。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="as">AS&lt;/h3>
&lt;p>&lt;code>AS&lt;/code>常见的用法是建立别名。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">column&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id_alias&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">my_table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">table_alias&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">table_alias&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">column&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里出现了一个新的语法细节，&lt;code>table_alias.column&lt;/code>。用点&lt;code>.&lt;/code>连接表名和列名的行为类似于 C++中的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="k">typedef&lt;/span> &lt;span class="n">table_alias&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">my_table&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">auto&lt;/span> &lt;span class="n">id_alias&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SELECT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">table_alias&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">column&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">table_alias&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">column&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>看得出来，&lt;code>table_alias.column&lt;/code>是完全限定了&lt;code>column&lt;/code>是哪个&lt;code>column&lt;/code>，之所以有这种语法，是因为&lt;code>FROM&lt;/code>子句需要支持多个表作为查询来源。到时候可能就会用到&lt;code>table1.column &amp;lt;&amp;gt; 1 AND table2.column &amp;lt;&amp;gt; 2&lt;/code>这样的写法了。&lt;/p>
&lt;p>而查询开头的&lt;code>column AS id_alias&lt;/code>则是标识查询结果列叫做&lt;code>id_alias&lt;/code>，举例如子查询的情况下，便于引用。&lt;/p>
&lt;h3 id="join">JOIN&lt;/h3>
&lt;p>&lt;code>JOIN&lt;/code>的术语叫做&lt;strong>联结&lt;/strong>，使用了&lt;code>JOIN&lt;/code>关键字的查询叫做&lt;strong>联结查询&lt;/strong>。&lt;/p>
&lt;p>联结查询和一般的查询不同的地方是，联结查询的数据来源是多个表。&lt;/p>
&lt;p>最简单的联结查询是内联结查询。&lt;/p>
&lt;p>举例来说，我现在有表&lt;code>students&lt;/code>如下，所有学生根据超能力开发等级分配到多个班级。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>id&lt;/th>
&lt;th>name&lt;/th>
&lt;th>class&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>stu1&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>stu2&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>stu3&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>stu4&lt;/td>
&lt;td>4&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>又有表&lt;code>top_class&lt;/code>，收录了所有接收高等级超能力者的班级，能进入这些班级的学生都是如同能考上&lt;code>985&lt;/code>、&lt;code>211&lt;/code>般恐怖如斯的存在。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>id&lt;/th>
&lt;th>name&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>Lv 5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>Lv 4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>Lv 3&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>现在我们要查询出学生中那些恐怖如斯的存在有哪些。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INNER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">top_class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">top_class&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">class&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>语法&lt;code>JOIN [表] ON [条件]&lt;/code>也很简单啦。在例子中，&lt;code>JOIN&lt;/code>表示要联结表&lt;code>top_class&lt;/code>，&lt;code>ON&lt;/code>表示查询的对象要符合条件&lt;code>top_class.id = students.class&lt;/code>。不好理解？看看伪代码。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="nl">student&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">students&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 先过滤 students 表本身，这个过滤应该由 WHERE 子句完成
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="nl">cls&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">top_class&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 然后联结表 top_class
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">student&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">cls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cls&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 判断 ON students.class = top_class.id
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">results&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">student&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 得出结果
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意，伪代码的查询过程是错误的，为了方便理解 students.class = top_class.id 才这么写。真实数据库实现联结查询的方法应当查阅对应&lt;code>DBMS&lt;/code>的文档。&lt;/p>
&lt;/blockquote>
&lt;p>注意的关键点有&lt;code>ON&lt;/code>很像但不同于&lt;code>WHERE&lt;/code>，在了解&lt;code>LEFT JOIN&lt;/code>和&lt;code>RIGHT JOIN&lt;/code>时会区分。&lt;/p>
&lt;h3 id="left-join">LEFT JOIN&lt;/h3>
&lt;p>&lt;code>LEFT JOIN&lt;/code>又叫&lt;strong>左联结&lt;/strong>，基本思路是写在&lt;code>LEFT JOIN&lt;/code>左边的表满足条件即可作为结果，即使右边的表没有满足条件的条目。&lt;/p>
&lt;p>还是以上文的学园都市数据库为例（我 tm 写了什么&amp;hellip;）&lt;/p>
&lt;p>学生表 &lt;code>students&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>id&lt;/th>
&lt;th>name&lt;/th>
&lt;th>class&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>stu1&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>stu2&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>stu3&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>stu4&lt;/td>
&lt;td>4&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>班级表 &lt;code>top_class&lt;/code>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>id&lt;/th>
&lt;th>name&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>Lv 5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>Lv 4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>Lv 3&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>现在我们查询学生都处在哪些班级，得到班级的名字。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">top_class&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">cls&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LEFT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">top_class&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">top_class&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">class&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查询结果应该是这样子的。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>name&lt;/th>
&lt;th>cls&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>stu1&lt;/td>
&lt;td>Lv 5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>stu2&lt;/td>
&lt;td>Lv 4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>stu3&lt;/td>
&lt;td>Lv 3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>stu4&lt;/td>
&lt;td>&lt;code>NULL&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>注意到了吗？&lt;code>stu4&lt;/code>虽然不是&lt;code>top_class&lt;/code>的学生，但是还是被查询出来了。&lt;/p>
&lt;h3 id="right-join">RIGHT JOIN&lt;/h3>
&lt;p>继续拿学园都市做例子&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>其实是和左联结一个鸟样。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">top_class&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">cls&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">top_class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">RIGHT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">top_class&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">class&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们注意到&amp;hellip;&amp;hellip;我就是把 &lt;code>students&lt;/code>和 &lt;code>top_class&lt;/code>换了个位置。查询结果其实是一样的。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>name&lt;/th>
&lt;th>cls&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>stu1&lt;/td>
&lt;td>Lv 5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>stu2&lt;/td>
&lt;td>Lv 4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>stu3&lt;/td>
&lt;td>Lv 3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>stu4&lt;/td>
&lt;td>&lt;code>NULL&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="cross-join">CROSS JOIN&lt;/h3>
&lt;p>交叉联结，查询结果是联结的表和&lt;code>FROM&lt;/code>的表的笛卡尔积，这么说听的明白不？听不明白就算了，因为交叉联结基本用不到。&lt;/p>
&lt;p>其实就是把两个表的每个行都排列组合一下：&lt;/p>
&lt;ul>
&lt;li>表 A 行 1-表 B 行 1&lt;/li>
&lt;li>表 A 行 1-表 B 行 2&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;li>表 A 行 10-表 B 行 1&lt;/li>
&lt;li>表 A 行 10-表 B 行 2&lt;/li>
&lt;li>表 A 行 10-表 B 行 3&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h3 id="join-自己">JOIN 自己？&lt;/h3>
&lt;p>术语叫自联结，其实也挺好理解的，直接举个例子看看。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>id&lt;/th>
&lt;th>name&lt;/th>
&lt;th>class&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>stu1&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>stu2&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>stu3&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>stu4&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>注意我数据改了哈。&lt;/p>
&lt;/blockquote>
&lt;p>现在要查询出所有和&lt;code>stu1&lt;/code>同一个班级的学生。&lt;/p>
&lt;p>一般我们想怎么查？先查出&lt;code>stu1&lt;/code>是哪个班级的：&lt;code>SELECT class FROM students WHERE name = 'stu1'&lt;/code>，然后查出所有属于这个班级的学生：&lt;code>SELECT name FROM students WHERE class = [上次查出来的班级]&lt;/code>。&lt;/p>
&lt;p>那么&amp;hellip;怎么写成一句话呢？&lt;/p>
&lt;p>这时候自联结就可以上场了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">class&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INNER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">students&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">class&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">class&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;stu1&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查询结果是&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>id&lt;/th>
&lt;th>name&lt;/th>
&lt;th>class&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>stu1&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>stu2&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>基本思路是这样的：&lt;code>FROM&lt;/code>的表是&lt;code>s1&lt;/code>，因此&lt;code>INNER JOIN&lt;/code>查询结果来自&lt;code>s1&lt;/code>而不是&lt;code>s2&lt;/code>。查找&lt;code>s1&lt;/code>表中每个行的&lt;code>class&lt;/code>在&lt;code>s2&lt;/code>表里有没有行具有同样的&lt;code>class&lt;/code>属性，同时，&lt;code>s2&lt;/code>具有和&lt;code>s1&lt;/code>同样&lt;code>class&lt;/code>属性的行还必须有个&lt;code>stu1&lt;/code>的&lt;code>name&lt;/code>。&lt;/p>
&lt;p>分析得知，&lt;code>s2&lt;/code>中有&lt;code>stu1&lt;/code>这个&lt;code>name&lt;/code>的行只有&lt;code>1&lt;/code>，所以&lt;code>s2&lt;/code>表其实长这样。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>id&lt;/th>
&lt;th>name&lt;/th>
&lt;th>class&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>stu1&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>这时候再去看&lt;code>s1&lt;/code>表，&lt;code>s1&lt;/code>表的&lt;code>class&lt;/code>同时存在于&lt;code>s2&lt;/code>表的行只有&lt;code>1&lt;/code>和&lt;code>2&lt;/code>了。&lt;/p>
&lt;h3 id="outer-join">OUTER JOIN&lt;/h3>
&lt;p>其实&lt;code>OUTER JOIN&lt;/code>上面的&lt;code>LEFT JOIN&lt;/code>和&lt;code>RIGHT JOIN&lt;/code>已经讲过了，&lt;code>LEFT JOIN&lt;/code>的完整写法就是&lt;code>LEFT OUTER JOIN&lt;/code>，&lt;code>RIGHT JOIN&lt;/code>就是&lt;code>RIGHT OUTER JOIN&lt;/code>，和&lt;code>INNER JOIN&lt;/code>的区别在于&lt;code>OUTER JOIN&lt;/code>包含了指定表里不满足&lt;code>ON&lt;/code>条件的行。&lt;/p>
&lt;p>这有个知识点，就是&lt;code>ON&lt;/code>条件不过滤指定&lt;code>OUTER JOIN&lt;/code>的表的不满足条件的行，但是&lt;code>WHERE&lt;/code>会过滤。&lt;/p>
&lt;h3 id="union">UNION&lt;/h3>
&lt;p>&lt;code>UNION&lt;/code>关键字的术语是&lt;strong>联合查询&lt;/strong>。&lt;/p>
&lt;p>作用是将多个&lt;code>SELECT&lt;/code>的结果放在一起并返回。&lt;/p>
&lt;p>举个例子&amp;hellip;&amp;hellip;我们要查询全美最好的大学&lt;code>american_top_college&lt;/code>和中国最好的大学&lt;code>chinese_top_college&lt;/code>数据，来决定报考哪个大学（反正都考不上），如果不想写成两句&lt;code>SELECT&lt;/code>，然后手工合并成一个表格的话，那么就用&lt;code>UNION&lt;/code>查询吧。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;american&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">nation&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">american_top_college&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">college_name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">american_top_college&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">score_line&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score_line&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">american_top_college&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">UNION&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;china&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">nation&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">chinese_top_college&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">college_name&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">chinese_top_college&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">score_line&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">score_line&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查询结果&amp;hellip;不展示了。&lt;/p>
&lt;p>还有个细节可能要注意，如果有大学同时是美国大学和中国大学的话，那么为了在联合查询中排除相同的项目，可以使用&lt;code>UNION ALL&lt;/code>而不是&lt;code>UNION&lt;/code>。&lt;/p>
&lt;h3 id="fulltext">FULLTEXT&lt;/h3>
&lt;p>&lt;code>MySQL&lt;/code>支持一种实用的文本索引方式，叫做&lt;strong>全文本搜索&lt;/strong>。大家都知道，正则表达式和简单通配符来查找文本是非常消耗性能的操作，而且难以优化（反正我想不出任何减少查询的优化思路）。&lt;code>MySQL&lt;/code>提供了全文本搜索的属性来帮助索引文本（但是想到中文支持我觉得已经凉的差不多了），快速查询出包含特定词汇之类的行。&lt;/p>
&lt;blockquote>
&lt;p>抱歉我觉得不行。不说别的，中文分词就&amp;hellip;&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;p>跳过了跳过了。&lt;/p></description></item><item><title>MySQL 24小时入门笔记 - 1</title><link>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-1/</link><pubDate>Sat, 23 Jun 2018 02:24:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-1/</guid><description>&lt;h2 id="1-数据库概念">1. 数据库概念&lt;/h2>
&lt;h3 id="11-数据和储存">1.1 数据和储存&lt;/h3>
&lt;p>数据库本质上做的工作是储存和查询数据。理论上而言，&lt;code>MySQL&lt;/code>应该叫做&lt;code>DBMS&lt;/code>，也就是&lt;strong>数据库管理系统&lt;/strong>，而不是&lt;strong>数据库&lt;/strong>。&lt;/p>
&lt;p>&lt;code>DBMS&lt;/code>提供了统一的建立、使用、管理数据库的接口，常见的&lt;code>DBMS&lt;/code>有&lt;code>postgreSQL&lt;/code>、&lt;code>MariaDB&lt;/code>、&lt;code>SQL Server&lt;/code>等。&lt;/p>
&lt;h3 id="12-数据库和schema">1.2 数据库和&lt;code>Schema&lt;/code>&lt;/h3>
&lt;p>通常来说，一个&lt;code>DBMS&lt;/code>会支持多个数据库共存。这里所说的&lt;em>数据库&lt;/em>指的是特定数据库管理系统管理下的&lt;em>数据库&lt;/em>，而不是上一节说的&lt;code>DBMS&lt;/code>。&lt;/p>
&lt;p>而&lt;code>Schema&lt;/code>的中译术语一般叫&lt;strong>模式&lt;/strong>，&lt;code>Schema&lt;/code>描述了数据库的结构，比如说有哪些表，表有哪些字段，字段分别有哪些限制，有哪些声明了的函数，等等。&lt;/p>
&lt;p>通常的&lt;code>DBMS&lt;/code>往往是这样的结构：位于&lt;code>DBMS&lt;/code>管理最顶层的是一个或多个数据库，数据库里存放表，表里以行为单位存放数据。&lt;/p>
&lt;h3 id="13-表列键行">1.3 表、列、键、行&lt;/h3>
&lt;h4 id="131-表">1.3.1 表&lt;/h4>
&lt;p>表的英语术语是&lt;code>Table&lt;/code>。&lt;/p>
&lt;p>用过 Excl 吗？&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>id&lt;/th>
&lt;th>name&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>Mike&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>John&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>直观的表就是一个二维的“表”，有行，有列。&lt;/p>
&lt;h4 id="132-列">1.3.2 列&lt;/h4>
&lt;p>列的术语是 &lt;code>Column&lt;/code>。&lt;/p>
&lt;p>每个列都应该有一个特定的类型（&lt;code>type&lt;/code>），使该列仅仅储存指定类型的数据。&lt;/p>
&lt;h4 id="133-键或者叫码">1.3.3 键&amp;hellip;&amp;hellip;或者叫码&lt;/h4>
&lt;p>键的术语是 &lt;code>Key&lt;/code>。&lt;/p>
&lt;p>通常指的是&lt;code>Primary Key&lt;/code>，也就是主键。主键可以是任意一个列。但是如果列是主键，那么这个列必须每个行都保证不和其他行重复。&lt;/p>
&lt;p>主键也可以是多个列，如果是多个列，那么必须保证这些列的组合不重复。&lt;/p>
&lt;p>举例来说&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>db&lt;/th>
&lt;th>table&lt;/th>
&lt;th>id&lt;/th>
&lt;th>name&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>aa&lt;/td>
&lt;td>aaaaa&lt;/td>
&lt;td>11&lt;/td>
&lt;td>xxxx&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>aa&lt;/td>
&lt;td>bbbbb&lt;/td>
&lt;td>11&lt;/td>
&lt;td>xxxx&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>其中&lt;code>db&lt;/code>和&lt;code>table&lt;/code>还有&lt;code>id&lt;/code>都是主键，只要保证没有两个行同时存在相同的&lt;code>db&lt;/code>/&lt;code>table&lt;/code>/&lt;code>id&lt;/code>就算是满足了主键约束。&lt;/p>
&lt;blockquote>
&lt;p>需要注意的是，多主键的可移植性存疑，不一定其他的&lt;code>DBMS&lt;/code>会支持。&lt;/p>
&lt;/blockquote>
&lt;h4 id="134-行">1.3.4 行&lt;/h4>
&lt;p>行的术语是 &lt;code>Row&lt;/code>。&lt;/p>
&lt;p>每个行都是一条记录（&lt;code>record&lt;/code>），换做对象的概念的话，也可以说，每个表都储存了一个其特有的的&lt;code>Row&lt;/code>对象的集合，&lt;code>Column&lt;/code>一一对应&lt;code>Row&lt;/code>对象的属性。&lt;/p>
&lt;p>比如上文的&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>id&lt;/th>
&lt;th>name&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>Mike&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>John&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>对象概念表达就是&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="k">class&lt;/span> &lt;span class="nc">row&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">id&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">set&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">row&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">table&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="14-sql-是什么">1.4 SQL 是什么&lt;/h2>
&lt;p>&lt;code>SQL&lt;/code>的直译是&lt;strong>结构化查询语言&lt;/strong>，其实就是标准化的数据库查询语言，基本每个&lt;code>DBMS&lt;/code>都支持。&lt;/p>
&lt;p>但是&amp;hellip;&amp;hellip;数据库管理系统对&lt;code>SQL&lt;/code>标准的支持并不是那么上心。其中有性能优化、平台优化之类的原因，也有数据库软件开发商自身的考虑。但总而言之，不要太期待同样的&lt;code>SQL&lt;/code>能在任意&lt;code>DBMS&lt;/code>里都一样跑得欢。&lt;/p></description></item></channel></rss>