<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>mysql on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/categories/mysql/</link><description>Recent content in mysql on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 14 Mar 2022 12:30:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/categories/mysql/index.xml" rel="self" type="application/rss+xml"/><item><title>记一次MySQL JOIN优化</title><link>https://nnnewb.github.io/blog/p/note-of-mysql-join-optimize/</link><pubDate>Mon, 14 Mar 2022 12:30:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/note-of-mysql-join-optimize/</guid><description>前言 长话短说，这个性能问题是上周修一个bug的时候企图偷懒引入的。因为 xorm 在连接查询的时候模型结构必须是和 join 的顺序保持一致，中间还不能有遗漏，不然查询结果填充到结构里的时候就会错位。
而业务里这个条件又是可选的——用户不传的时候不需要 INNER JOIN；但为了让 xorm 开心，同时尽量别把整个函数签名和返回类型都改了把影响范围搞太大，所以就偷了个懒：既然 xorm 要 JOIN ，那就 LEFT JOIN加个恒假的条件呗。于是就顺手写下了下面的代码。
LEFTJOINtblON1&amp;lt;&amp;gt;1没啥问题对吧？我当时也这么想的。
问题 好了，问题来了。先把整个 SQL写下来。
SELECT*FROMaINNERJOINbONa.resource_id=b.idLEFTJOINcON1&amp;lt;&amp;gt;1LEFTJOINdONd.resource_id=a.resource_idLEFTJOINeONe.resource_id=a.resource_idWHEREa.result!=4ANDb.resource_type=2limit10offset0;整个查询的实际耗时是 919ms。
why ?
性能分析 查询慢了第一反应还是是不是没索引，于是先看看 explain 的结果。
id select_type table partitions type possible_keys key key_len ref rows 1 SIMPLE a ALL IDX_a_resource_id 456 1 SIMPLE b eq_ref PRIMARY PRIMARY 8 a.resource_id 1 1 SIMPLE d ref IDX_d_resource_id IDX_d_resource_id 8 a.</description></item><item><title>XA 事务从理论到实践</title><link>https://nnnewb.github.io/blog/p/xa-transaction-theory-to-practice/</link><pubDate>Thu, 16 Dec 2021 15:00:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/xa-transaction-theory-to-practice/</guid><description>前言 有言道，纸上得来终觉浅，绝知此事要躬行。分布式事务的具体方案，看几篇文章就基本有了概念，但实际应用的机会很少。这不有点闲暇，就试试看把理论化作代码，在实践中检验。
#1 案例设计 采用分布式事务经典的转账案例：用户从银行A转账到银行B，银行A扣除余额，银行B增加余额。
XA事务官方规范文档给出的示意图如下。
事务模型
用 XA 事务描述，用户的转账操作发生在AP，AP调用TM注册全局事务后，调用银行A（RM）完成扣款（PREPARE），调用银行B（RM）完成增加余额（PREPARE），然后调用TM提交全局事务，TM回调银行A和B提交本地事务。
图示如下。
xa事务时序图
上面的时序图是读了 github.com/yedf/dtm 代码后胡乱分析出来的，图略去了错误处理的部分。根据这个时序图可以做出一个简单的服务划分设计。
案例服务划分
为了更好地观察服务的交互情况，引入了 Jaeger ，如果是为了简化整个案例代码考虑也可以不要。但大部分时候 Jaeger 应该是没什么存在感的。
nginx 反向代理将 AP 的接口还有 Bank1/Bank2的接口导出给用户访问，实际上案例中没有需要访问 Bank1/Bank2 接口的情况，所以 去掉 nginx 反向代理应该也没什么大关系。
#2 技术栈 所有服务使用docker-compose部署，kubernetes也没问题。
MySQL使用5.7版本，jaeger和nginx最新稳定版。AP/Bank服务都使用 Go 语言编写， 使用 Gin 作为 HTTP 服务框架，OpenTelemetry 跟踪，sqlx 做 ORM。
#3 接口设计 接口url设计有参考 Google APIs 规范，但并不是硬套 RESTful 。
AP服务提供接口
/v1alpha1/transfer 转账接口 Bank服务提供接口
/v1alpha1/trans_in 余额转入 /v1alpha1/trans_out 余额转出 /v1alpha1/tm_callback 事务回调，当AP提交事务或者回滚时，TM回调这个接口并告知需要提交还是回滚 TM服务提供接口</description></item></channel></rss>