<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>javascript on weakptr's 笔记</title><link>https://uniqptr.gitee.io/categories/javascript/</link><description>Recent content in javascript on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 03 Aug 2021 15:52:21 +0000</lastBuildDate><atom:link href="https://uniqptr.gitee.io/categories/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>用 tree-sitter 写一个代码高亮</title><link>https://uniqptr.gitee.io/p/%E7%94%A8-tree-sitter-%E5%86%99%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/</link><pubDate>Tue, 03 Aug 2021 15:52:21 +0000</pubDate><guid>https://uniqptr.gitee.io/p/%E7%94%A8-tree-sitter-%E5%86%99%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/</guid><description>这次用 tree-sitter 写一个简单的代码高亮。
前言 我寻思代码高亮是什么应该没啥可解释的，也有叫“语法高亮”，总之都是一个意思。就是给编辑器里的代码涂上颜色，便于阅读。
一般来说，简单的代码高亮只需要正则表达式就能搞定（比如说关键字高亮，Camel Case 标识符高亮等），不过正则表达式来实现高亮还是有很大的局限性。
举例来说，当我把函数当参数传给另一个函数的时候——
function f() {} function higher(fn) { return () =&amp;gt; fn() != 0; } higher(f); 在 higher(f) 这一行中的 f 不会以函数名的颜色标出。这就引出了一种新基于语义的代码高亮，让编辑器真正“认识”你的代码，并提供更聪明的提示。
开始 还是在 vscode 折腾。
先创建一个 vscode 插件项目，用 yo code 完成。
然后编辑 package.json ，添加你的语言和插件的激活事件。
{ &amp;#34;activationEvents&amp;#34;: [&amp;#34;onLanguage:proto&amp;#34;], &amp;#34;contributes&amp;#34;: { &amp;#34;languages&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;proto&amp;#34;, &amp;#34;extensions&amp;#34;: [&amp;#34;.proto&amp;#34;] } ] } } 然后修改 src/extension.ts，去掉默认创建的 hello world 代码，留一个 console.log，然后 F5 启动，打开一个 .proto 文件，检查插件是否已经激活。
// The module &amp;#39;vscode&amp;#39; contains the VS Code extensibility API // Import the module and reference it with the alias vscode in your code below import * as vscode from &amp;#34;vscode&amp;#34;; // this method is called when your extension is activated // your extension is activated the very first time the command is executed export function activate(context: vscode.</description></item><item><title>玩玩 tree-sitter</title><link>https://uniqptr.gitee.io/p/%E7%8E%A9%E7%8E%A9-tree-sitter/</link><pubDate>Thu, 29 Jul 2021 10:14:36 +0000</pubDate><guid>https://uniqptr.gitee.io/p/%E7%8E%A9%E7%8E%A9-tree-sitter/</guid><description>什么是tree-sitter呢？
tree-sitter 是一个 parser-generator，也是一个增量解析库（incremental parsing library）。它可以为源文件构建完整的语法树，并在源文件被编辑时高效地更新。
快速开始 tree-sitter 本身是一个 parser generator ，使用 javascript 来作为描述语法规则的语言（不像其他，如 yacc 一类的工具，以类似 EBNF 的 DSL 来描述语法规则）。
我们写 tree-sitter 语法规则本质上是类似于写一个 tree-sitter 的语法支持包，可以参考下 tree-sitter/tree-sitter-go: Go grammar for tree-sitter (github.com) 的项目结构。
废话不多说，先写个简单的 demo 跑起来。
mkdir tree-sitter-hello &amp;amp;&amp;amp; cd tree-sitter-hello npm init npm i --save nan npm i --save-dev tree-sitter-cli 初始化好项目目录，在 package.json 里写个简单的命令，方便之后用。
{ &amp;#34;scripts&amp;#34;:{ &amp;#34;test&amp;#34;: &amp;#34;tree-sitter generate &amp;amp;&amp;amp; tree-sitter parse test.txt&amp;#34; } } 现在开始干正事儿，创建一个 grammar.js
module.exports = grammar({ name: &amp;#39;hello&amp;#39;, rules: { source_file: $ =&amp;gt; repeat($.</description></item><item><title>AudioContext 技术和音乐可视化（2）</title><link>https://uniqptr.gitee.io/p/audiocontext-%E6%8A%80%E6%9C%AF%E5%92%8C%E9%9F%B3%E4%B9%90%E5%8F%AF%E8%A7%86%E5%8C%962/</link><pubDate>Thu, 08 Nov 2018 21:41:00 +0000</pubDate><guid>https://uniqptr.gitee.io/p/audiocontext-%E6%8A%80%E6%9C%AF%E5%92%8C%E9%9F%B3%E4%B9%90%E5%8F%AF%E8%A7%86%E5%8C%962/</guid><description>Intro 转载请注明来源，可以在测试博客查看完成效果。
本篇讲述如何从频域数据绘制动态的星空。
一、使用 Canvas 绘图 1.1 位置和大小 绘制背景的第一要务便是把 canvas 元素放置在背景这一层次上，避免遮盖其他元素。
对我而言，个人习惯用 css 来设置大小和位置，用 html 来确定渲染顺序而不是 z-index。
下面是 html 代码。
&amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;canvas id=&amp;#34;background-canvas&amp;#34;&amp;gt;&amp;lt;/canvas&amp;gt; &amp;lt;!-- other elements --&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 下面是 css 代码。
#background-canvas { position: fixed; left: 0; top: 0; width: 100vw; height: 100vh; background-color: black; } fixed确保拖动页面不会令背景也跟随移动。
其余部分我想应该没什么有疑问的地方。
1.2 CanvasContext2D 对于 canvas 元素的绘图操作我想很多人应该接触过。
以绘制圆形为例，使用如下代码。
const canvas = document.getElementById(&amp;#34;background-canvas&amp;#34;); const ctx = canvas.getContext(&amp;#34;2d&amp;#34;); ctx.fillStyle = &amp;#34;#fff&amp;#34;; ctx.beginPath(); ctx.arc(100, 100, 50, 0, Math.</description></item><item><title>AudioContext技术和音乐可视化（1）</title><link>https://uniqptr.gitee.io/p/audiocontext%E6%8A%80%E6%9C%AF%E5%92%8C%E9%9F%B3%E4%B9%90%E5%8F%AF%E8%A7%86%E5%8C%961/</link><pubDate>Wed, 07 Nov 2018 02:48:00 +0000</pubDate><guid>https://uniqptr.gitee.io/p/audiocontext%E6%8A%80%E6%9C%AF%E5%92%8C%E9%9F%B3%E4%B9%90%E5%8F%AF%E8%A7%86%E5%8C%961/</guid><description>Intro 因为自己搭了个博客，一时兴起，就想写个动态的博客背景。毕竟用 django 后端渲染，前端只有 jquery 和 bootstrap 已经够 low 了，虽说极简风格也很棒，但是多少有点亮眼的东西才好办不是吗。
转载注明来源。
为了方便讲解，整个思路分为两个部分：音乐播放和背景绘制。
一、音乐播放 1.1 AudioContext 概述部分懒得自己写，参考 MDN 的描述。
AudioContext接口表示由音频模块连接而成的音频处理图，每个模块对应一个AudioNode。AudioContext可以控制它所包含的节点的创建，以及音频处理、解码操作的执行。做任何事情之前都要先创建AudioContext对象，因为一切都发生在这个环境之中。
1.2 浏览器支持状况 AudioContext标准目前还是草案，不过新 chrome 已经实现了。我使用的 chrome 版本如下。
版本 70.0.3538.77（正式版本） （64 位） 如果发现 console 报错或者其他问题请检查浏览器版本，所有支持的浏览器可以在这个链接查看。
1.3 AudioContext 和音频处理图 关于AudioContext我的了解不是很深入，所以只在需要用到的部分进行概述。
首先，关于音频处理图的概念。
这个名词不甚直观，我用过虚幻，所以用虚幻的Blueprint来类比理解。音频处理图，其实是一系列音频处理的模块，连接构成一张数据结构中的“图”，从一般使用的角度来讲，一个播放音频的图，就是AudioSource -&amp;gt; AudioContext.destination，两个节点构成的图。其中有很多特殊的节点可以对音频进行处理，比如音频增益节点GainNode。
对于音频处理的部分介绍就到这里为止，毕竟真的了解不多，不过从 MDN 的文档看，可用的处理节点还是非常多的，就等标准制订完成了。
1.4 加载音频文件并播放 音频文件加载使用典型的JavaScript接口FileReader实现。
一个非常简单的实例是这样
首先是 html 里写上 input
&amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;input type=&amp;#34;file&amp;#34; accept=&amp;#34;audio/*&amp;#34; onchange=&amp;#34;onInputChange&amp;#34; /&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 然后在 javascript 里读文件内容。
function onInputChange(files) { const reader = new FileReader(); reader.</description></item></channel></rss>