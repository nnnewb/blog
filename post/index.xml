<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/post/</link><description>Recent content in Posts on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 25 Nov 2021 14:31:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/post/index.xml" rel="self" type="application/rss+xml"/><item><title>kubeadm安装实验集群记录</title><link>https://nnnewb.github.io/blog/p/kubernetes-manually-install-by-kubeadm/</link><pubDate>Thu, 25 Nov 2021 14:31:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/kubernetes-manually-install-by-kubeadm/</guid><description>前言 好吧，如果仔细想想就会发现不管是 k3s 还是 ucloud 上的 k8s ，都没有一个是自己手动配置好的。虽说并不是至关重要的，但手动用 kubeadm 装一次 kubernetes 总不会有什么坏处。顺手做个笔记。参考资料列出如下。
https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/ https://mirrors.tuna.tsinghua.edu.cn/help/kubernetes/ https://computingforgeeks.com/deploy-kubernetes-cluster-on-ubuntu-with-kubeadm/ 系统配置 正式安装之前先确认一些系统级配置。
swapoff 简单的做法是 sudo swapoff -a 即可。之后改 fstab 把 swap 分区关掉。
iptables检查桥接流量 用 lsmod | grep bf_netfitler 检查有没有启用 bf_netfilter 模块，如果没有输出的话说明没加载，执行下面的命令。
cat &amp;lt;&amp;lt;EOF | sudo tee /etc/modules-load.d/k8s.conf br_netfilter EOF 会在 /etc/modules-load.d 下添加一个模块自动加载的配置。
cat &amp;lt;&amp;lt;EOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF 再在 /etc/sysctl.d/ 下添加一个配置，允许 iptables 查看桥接流量。
然后用 sysctl 重载配置。</description></item><item><title>密码学入门03 - 古典密码#3</title><link>https://nnnewb.github.io/blog/p/cryptography-introduction-03/</link><pubDate>Tue, 16 Nov 2021 11:31:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/cryptography-introduction-03/</guid><description>前言 学习一下 Hill 密码。
0x01 数学基础 参考了 数学乐 。没有详细介绍矩阵的意义，但基本运算规则之类的讲得很清楚好懂。
1.1 矩阵 一个矩阵就是n行m列的数字表格，含义暂不考虑，只学习下矩阵的表示方法、运算规则，不然有点难读懂 Hill 密码的规则。
一个有 m 行，n 列的矩阵 A 的书写形式如下。 $$ A=\begin{bmatrix} a_{11} &amp;amp; a_{12} &amp;amp; \dots &amp;amp; a_{1n} \\ a_{21} &amp;amp; a_{22} &amp;amp; \dots &amp;amp; a_{2n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{m1} &amp;amp; a_{m2} &amp;amp; \dots &amp;amp; a_{mn} \end{bmatrix} $$
1.2 矩阵加法/减法 矩阵加减法规则如下。设有矩阵 A、B 如下。 $$ A=\begin{bmatrix} a_{11} &amp;amp; a_{12} &amp;amp; \dots &amp;amp; a_{1n} \\ a_{21} &amp;amp; a_{22} &amp;amp; \dots &amp;amp; a_{2n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{m1} &amp;amp; a_{m2} &amp;amp; \dots &amp;amp; a_{mn} \end{bmatrix},B=\begin{bmatrix} b_{11} &amp;amp; b_{12} &amp;amp; \dots &amp;amp; b_{1n} \\ b_{21} &amp;amp; b_{22} &amp;amp; \dots &amp;amp; b_{2n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ b_{m1} &amp;amp; b_{m2} &amp;amp; \dots &amp;amp; b_{mn} \end{bmatrix} $$ 则计算 A±B 的规则如下。 $$ A±B=\begin{bmatrix} a_{11}±b_{11} &amp;amp; a_{12}±b_{12} &amp;amp; \dots &amp;amp; a_{1n}±b_{1n} \\ a_{21}±b_{21} &amp;amp; a_{22}±b_{22} &amp;amp; \dots &amp;amp; a_{2n}±b_{2n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{m1}±b_{m1} &amp;amp; a_{m2}±b_{m2} &amp;amp; \dots &amp;amp; a_{mn}±b_{mn} \end{bmatrix} $$ 性质：</description></item><item><title>密码学入门02 - 古典密码#2</title><link>https://nnnewb.github.io/blog/p/cryptography-introduction-02/</link><pubDate>Thu, 11 Nov 2021 16:53:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/cryptography-introduction-02/</guid><description>前言 从单表代替密码开始，继续学习古典密码。
0x01 playfair 密码 playfair 这个词乍一听我甚至有点迷惑，啥意思，公平竞赛吗。之后才知道原来是人名。
概述 playfair 密码是最著名的多字母代替密码，它把明文中的字母对转换成密文的字母对，每次加密输入两个字母，输出两个字母。
playfair 算法基于一个由密钥词构成的 5x5 字母矩阵，将密钥词去除重复字母后，和字母表剩余的字母按左至右、上至下的顺序填充进表里。
举例来说，用 pojie 作为密钥词。
- - - - - p o j i e a b c d f g/h k l m n q r s t u v w x y z 需要注意的是字母表有26个字母，但 playfair 的字母矩阵只有 25 个空格。出现字母表不是 5 的整数倍的情况时可以选择将多出来的字母视作同一个，或者去掉不常用的字母，使其正好填满矩阵。比如图中的g/h，好孩子不要学哦。常见的情况是i/j或者去掉z或q。</description></item><item><title>密码学入门01 - 古典密码#1</title><link>https://nnnewb.github.io/blog/p/cryptography-introduction-01/</link><pubDate>Thu, 11 Nov 2021 11:35:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/cryptography-introduction-01/</guid><description>前言 本文是学习《密码编码学与网络安全》一书的笔记，关于传统加密技术一章。
0x01 对称密码模型 对称加密，也称传统加密或单钥加密，是20世纪70年代公钥密码产生之前唯一的加密类型。迄今为止，它仍是使用最广泛的加密类型。
对称加密方案有5个基本成分：
明文：原始可以理解的消息或数据，是算法的输入。 加密算法：加密算法对明文进行各种代替和变换。 密钥：密钥也是加密算法的输入。密钥独立于明文和算法。算法根据所用的特定密钥而产生不同的输出。算法所用的确切代替和变换也依靠密钥。 密文：作为算法的输出，看起来完全随机而杂乱的消息，依赖于明文和密钥。对于给定的消息，不同密钥产生不同的密文，密文看上去是随机的数据流并且其意义是不可理解的。 解密算法：本质上是加密算法的逆运算。输入密文和密钥，输出原始明文。 image-20211110140236382
传统密码的安全使用要满足两个要求：
加密算法必须是足够强的。即使攻击者拥有一定数量的密文和产生这些密文的明文，他也不能破译密文或发现密钥。 发送者和接收者必须在某种安全的形式下获得密钥并保证密钥安全。如果有人发现密钥，并知道算法，就能解读使用该密钥加密的所有通信。 我们假设基于已知密文和加密/解密算法而破译消息是不实际的，我们不需要算法保密，仅需要密钥保密。如果密钥是由信息的发送方产生的，那么它要通过某种安全信道发送到接收方；另一种是由第三方生成密钥后再安全地分发给发送方和接收方。
// 明文X，共 m 个元素 byte[m] X = {X1,X2,X3,X4,...,Xm}; // 密钥K，共 j 个元素 byte[j] K = {K1,K2,K3,K4,...,Kj}; // 加密算法E，以明文和密钥为输入，输出密文 Y byte[n] Y = E(X, K); // 解密算法D，以密文和密钥为输入，输出明文 X byte[] X = D(Y, K); 1.1 密码编码学 密码编码系统有三个独立特征：
转换明文为密文的运算类型。所有的加密算法都基于两个原理：代替和置换。代替是将明文中的每个元素（如位、字母、位组或字母组）映射成另一个元素；置换是将明文中的元素重新排列。上述运算的基本要求是不允许有信息丢失（所有运算都是可逆的）。大多密码体制也称为乘积密码系统，都使用了多层代替和置换。 所用的密钥数。如果发送方和接收方使用相同的密钥，这种密码就称为对称密码、单密钥密码或传统密码。如果发收双方使用不同的密钥，这种密码就称为非对称密码、双钥或公钥密码。 处理明文的方法。分组密码每次处理输入的一组元素，相应地输出一组元素。流密码则是连续地处理输入元素，每次输出一个元素。 攻击密码系统的典型目标是恢复使用的密钥，而不仅仅恢复出单个密文对应的明文。攻击传统密码有两种通用的方法。
密码分析学：密码分析学攻击依赖于算法的性质、明文的一般特征或某些明密文对。这种攻击形式企图利用算法的特征来推导出特定的明文或使用的密钥。 穷举攻击：攻击者对一条密文尝试所有可能的密钥，直到把它转化为可读的有意义的明文。平均而言，获得成功至少要尝试所有可能的密钥的一半。 基于密码分析者知道的信息的多少，概括密码攻击的几种类型如下。
攻击类型 攻击者已知的信息 唯密文攻击 加密算法；密文； 已知明文攻击 加密算法；密文；与待解密密文同一密钥加密的一个或多个明密文对； 选择明文攻击 加密算法；密文；分析者选择的明文，以及对应的（使用和待解密密文同一密钥）加密的密文； 选择密文攻击 加密算法；密文；分析者选择的密文，以及对应的（使用和待解密密文同一密钥）的解密明文； 选择文本攻击 加密算法；密文；分析者选的明文，以及对应的密文；分析者选择的密文，以及对应的明文，使用和待解密密文同一密钥。 唯密文攻击最容易防范，但很多情况下分析者可以得到更多的信息。比如 postscript 格式加密的文件总是以相同的格式开头，电子金融消息往往有标准化的文件头或者标志，类似的例子还有很多，这些都是已知明文攻击的例子。有这些知识的分析者就可以从转换明文的方法入手来推导出密钥。</description></item><item><title>运维瞎记 2021年11月11日</title><link>https://nnnewb.github.io/blog/p/blind-op-2021-11-11/</link><pubDate>Thu, 11 Nov 2021 10:19:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/blind-op-2021-11-11/</guid><description>记虚拟机网络未连接 起因 因为Ubuntu server安装时更新的话需要从网络下载，慢的一批，所以安装的时候虚拟机的网络断开了，安装好启动之后才重新链接。
但是&amp;hellip;
连接后进入系统却发现并没有网络（VirtualBox），检查 networkctl 发现 enp0s3 是 off 状态。
原因 别问，不知道。
处理 顺藤摸瓜不求甚解了。
看到 enp0s3 是 off 那就先查查怎么解决。
sudo ip link set enp0s3 up 再检查连接状态。
networkctl status 发现连接进入 downgrade 状态，搜索得知是未分配 IP 地址。
sudo dhclient enp0s3 报了一个奇怪的CMP什么的错误，不管了。再检查下网络。
networkctl 发现 enp0s3 进入 routable 状态，大功告成。
总结 我总结个蛋。</description></item><item><title>一些屁话 2021年11月4日</title><link>https://nnnewb.github.io/blog/p/2021-11-4-diary/</link><pubDate>Thu, 04 Nov 2021 16:06:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/2021-11-4-diary/</guid><description>比烂 不知道什么时候起，对现在的工作失去了激情，连带着对生活也失去了期待。
上班下班，例行公事，像是个机器人。虽然一直都是这样，从来没有好过。
似乎也不是——至少在peropero工作的那段时间，还是有些兴奋的。只是确实各方面多少有些合不来，但个人原因还是居多数。毕竟多少已经摸爬滚打了几年下来，一定要说哪个老东家很好或者很差，恐怕都不合适。
有优点也有缺点是常态，决定能不能持续干下去，最后还是看能不能忍受缺点。
所以说到底还是比烂，到底万事万物还是比烂。
做人 一个常常出现在脑海里的问题是，我应该做什么样的人？
然后忽然就有了答案，那就是我不能决定自己成为什么样的人。环境塑造人，经历塑造人，唯独人不能塑造自己，所以说做什么样的人其实是伪命题。
这么想有些悲观，是机械决定论。人一出生就已经决定了命运，所思所想，悲欢离合，早已经决定，生命就是概率之海的小水花，生或死都没有意义。
但无论如何吧，至少，还得有一点念想？假装一切都在掌控之中，像是抓住浪潮中的浮木。所以还是得有个什么念想，要做一个什么样的人。
我怎么想呢。
做正确的事，也许不正确，也许现在以为是正确，将来又觉得不正确。而即便是这样也做不到。
时间 现在是2021年11月4日，2021年也快要过去了，天气转凉。
现在总结一年的工作或者生活还有些太早，但如今回头看，这一年也就这样吧。
事业发展，没有变化。
人生大事，没有进展。
健康生活？被痛风折磨，头发肉眼可见地变得稀疏，还好发际线没有太明显的移动。精力虽然有些消退，但并没有什么妨害。
想要看看还有没有什么提升的机会，发现国家又在教改，成人学历教育明年大概又有什么动作。随便翻了翻招生简章，就看到对25岁以上考生居然有优待。
再一对自己的，哦豁，不用等明年，今年12月就成了被优待的对象了。
已经快记不起上学时的光景了，好像所有东西都在飞快地远离。
变化 时间给人带来最明显的变化就是内敛。
不再轻易喜悦，也不再轻易动怒。
与其说是沉稳，不如说是更焦虑了，为身边的一切事情焦虑，为自己的能力总是捉襟见肘焦虑。而后又容易放弃，因为总忍不住去对比已知的成本和未知的收益，又或者因为各种内外条件变化而不了了之。
明知道抱怨没有意义，还是忍不住抱怨，每天都有发泄不完的情绪。
终 写了那么多屁话，还是要到这里结束。
生活还要继续。</description></item><item><title>加壳原理08：混淆技术入门</title><link>https://nnnewb.github.io/blog/p/learning-packer-08/</link><pubDate>Wed, 03 Nov 2021 16:54:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-08/</guid><description>前言 本篇尝试学习通过动手写一个 LLVM Pass 来学习编译阶段进行代码混淆的技术。
0x01 环境设置 LLVM 是个相当大的项目，做好环境设置是首先要做的事情。这里选择 msys2 作为首要开发环境，不然光是 MSVC 把 LLVM 源码编译一遍就够呛了。
安装好MSYS2之后安装 clang 工具链（2021年11月3日，clang32工具链默认不在msys2的源里，需要手动改 pacman.conf 加入 clang32 源，这里以 x86_64 的 LLVM 工具链进行实践）。
pacman -Sy mingw-w64-clang-x86_64-toolchain 完成后添加环境变量，把 msys2 安装目录下的 clang64/bin 加入环境变量，方便 VSCode + CMake 找到工具链。另外注意装一个 Ninja，同样加入 Path。
VSCode 里装上微软的 C/C++ 和 clangd，禁用微软 C/C++ 的 Intellisense，实在太慢。
手动编译整个LLVM源码树实在是太费时间了，我选择用MSYS2的工具链。参考这篇文档去配置一个 LLVM 源码树外的 Pass 工程：CMake out of source pass - LLVM 。写一个简单的 CMakeLists.txt ，跟着 Writing an LLVM Pass - LLVM 这篇文档快速实现一个遍历函数的 Pass 。</description></item><item><title>加壳原理07 - 花指令入门</title><link>https://nnnewb.github.io/blog/p/learning-packer-07/</link><pubDate>Sun, 31 Oct 2021 17:14:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-07/</guid><description>前言 个人浅见，一般分析一个程序可以有动态和静态两条路，动态一般指的就是调试或者别的运行时跟踪程序行为的方式了，除了调试器外就是抓取事件、日志、API调用记录、看内存数据等，比如有 Frida，还有内存搜索如CE。静态则是用各种工具在不实际运行程序的前提下，从程序文件里提取有用的信息。
对于运行时的对抗手段很多，毕竟程序都跑起来了，你来我往打擂台嘛。而且在Windows这个闭源平台上，还可以靠不大可能被动手脚的内核来保护自己，Linux上就可能内核都是被魔改过的。
但是对静态分析就没有什么特别好的办法，又要人造的计算机能正确运行，又要人不能理解，就有点矛盾。
广为人知的对抗静态分析的手段有这些：
混淆，把程序逻辑转换成更晦涩但等价的形式。 加花，对抗反汇编引擎，利用反汇编工具的算法缺陷、漏洞来迫使分析者必须花费大量时间处理错误的反汇编结果，让诸如控制流视图之类的工具失效。 混淆和加花的主要区别 在我这 定义为 混淆是变换原程序逻辑，花指令不改变原程序逻辑 。
这些对抗手段主要的目的都是 消磨耐心 和 拖延时间 ，抬高人肉分析的成本。但混淆加花这种手段是无法做到只让机器读懂代码而人读不懂这种效果的。这个结论忘了是哪篇论文里提到的了。
本篇只讲如何对抗反汇编，也就是花指令技术。
0x01 花指令原理 1.1 机器码指令格式 码农日常工作接触的是高级语言（这个概念可能有争议，反正相对汇编、机器码这个层级来说都是高级语言就对了），汇编和机器码这种满是历史尘埃的领域是绝无机会接触的。但要理解花指令，首先要理解汇编代码的二进制表示，才会明白为什么反汇编工具的力量是有极限的。
zHClf
这是 Intel 的 64-ia-32-architectures-software-developer-instruction-set-reference-manual 里的一张图，说明了汇编指令如何以二进制形式保存。可以简单看成3部分，1字节的可选前缀，1-3字节的opcode部分，剩余描述操作数的部分。
几个要素：
指令长度不固定，最短 1 字节，最长可能有 14 （图中全部相加，实际会不会有我就不知道了）。 一条汇编代码里的指令可能对应很多不同的 opcode ，简单到 add 这样的指令也会有很多种不同形式。 熟悉机器码格式在自己构造花指令的时候大概会有用，但实话说 Intel 这手册看得我头痛。所以还是直接快进到花指令原理。
1.2 花指令原理 花指令的英文是 junk code ，也就是垃圾代码。实际上花指令的确是一些不影响程序逻辑的 垃圾 机器码，它存在的唯一意义就是干扰反汇编引擎和人肉分析。
花指令有两种类型：
不可执行的花指令 可执行的花指令 听起来像是废话但实际上构造这两种花指令的难度是完全不一样的。
对于不可执行的花指令，本质上我们做的事情是在跳转指令之后插入一个多字节指令的字节，欺骗反汇编器将这个字节之后的几个字节当成一个多字节指令解释，进而造成后续指令反汇编出错。
而可执行的花指令，本质是将指令的组成部分重新解释执行。像是一个2字节的跳转指令，第二个字节是操作数，但操作数可以是 0xff，也就是带符号的 -1，使 EIP 落在 0xff 这个字节上，将0xff作为指令继续执行。这个过程中0xff既可以被当成数字0xff解释，也被当成了指令来解释。</description></item><item><title>加壳原理06：反调试技术入门</title><link>https://nnnewb.github.io/blog/p/learning-packer-06/</link><pubDate>Wed, 27 Oct 2021 19:50:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-06/</guid><description>前言 反调试技术，往大了说是用尽一切手段防止运行时对程序的非法篡改和窥视，往小了说就是防调试器。反正反调试这件事和各种技术都能搭点边，什么HOOK啦DLL注入啦。真要给涉及到的各方面都说得头头是道，那我这个菜鸡就不叫菜鸡了。
反正涉及的各种技术细节吧，将来都会慢慢学到的。也不急于一时。本篇关注的重点还是在导，引入，了解个大概。看看有什么反调试思路，对付这些反调试技术又有什么 bypass 的手段。
说这么多，其实还是找了篇写得不错的外文文章，抄了然后调试了下案例。
0x01 反调试思路 首先概述一下本篇主要的反调试思路。
1.1 系统API或数据结构 操作系统提供了一些调试标志位，调试器启动的进程会有标识。调试器也可能会为了提供更好的调试体验，修改一些参数，让我们有迹可循。
PEB-&amp;gt;BeingDebugged和IsDebuggerPresent PEB-&amp;gt;NtGlobalFlag PEB-&amp;gt;HEAP-&amp;gt;Flags和PEB-&amp;gt;HEAP-&amp;gt;ForceFlags CheckRemoteDebuggerPresent NtQueryInformationProcess ProcessDebugPort ProcessDebugObjectHandle ProcessDebugFlags ProcessBasicInformation NtSetInformationThread和NtCreateThreadEx 利用 HideFromDebugger 标志位来对调试器隐藏自身。 1.2 SEH、VEH 总的来说，利用 SEH 和 VEH 机制，尝试抛出一些会被调试器处理的中断或异常，同时自己挂一个处理函数，如果异常被调试器捕获了，那自己挂的异常处理函数就不会被调用，借此判断是否有调试器正在调试程序。
TF标志位和INT 1中断 INT 3 中断和 SEH 处理函数，__try __except 或 MinGW 的 __try1 __except1，顺便一提我的SEH实验没成功。但是 VEH 基本没问题。 DBG_PRINTEXCEPTION_WIDE_C和DBG_PRINTEXCEPTION_W，Windows 10 OutputDebugString 利用了这个 Exception 来抛出调试字符串。 EXCEPTION_INVALID_HANDLE 1.3 调试寄存器 GetThreadContext 获取当前上下文，判断 Dr0-Dr3寄存器的值。
1.4 完整性校验 原理是调试器通过临时修改断点处指令为中断来取得程序控制权，可以用CRC校验，或者更简单点，直接逐字节求和，判断代码是否被篡改。</description></item><item><title>加壳原理05：利用图片隐藏</title><link>https://nnnewb.github.io/blog/p/learning-packer-05/</link><pubDate>Thu, 21 Oct 2021 21:17:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-05/</guid><description>前言 完成了简单的压缩壳之后放松下，在52论坛病毒分析区看到过几次把代码隐藏到图片里的做法，也看到过把程序转成图片后训练神经网络来判断有没有恶意的，于是就想，淦，这不是挺好玩的嘛。
0x01 思路 用图片保存程序最简单的做法就是直接把程序每个字节都转成像素，然后输出成灰度图。比较进阶的做法就像是二维码了，大色块，容错校验，图片被压到包浆也能扫出来。但那个有点点难（我菜）最终成果也大到不现实，而且实话说打包到程序里就不用考虑被二次压缩的情况了。所以简单的8bit灰度图就刑。
说到位图肯定有人想到了 BMP ，我记得上学那会儿还跟着网上哪儿找的教程，学着用 ffmpeg 把 Bad Apple 转成位图序列，再转成字符图合并成 HTML，用 js 播放。说起来都是泪。
现在已经成了正经的码农，再折腾 BMP 就没意思了，PNG 就挺好的。
图片可以放到 Section 里——但并没有意义，所以我选择放到资源里。写一个 .rc 文件用 windres 编译出目标文件，再拿 gcc 链接就行了。如此一来并没有 lief 出场的机会，编译好的加载器就是加完壳的程序。
加载器则采用开启 ASLR 的模式，这样程序的节表会比较干净，没有明显特征（虽然也没什么卵用）。
0x02 加载器 2.1 资源介绍 参考微软的文档 Using Resources、Menu and Other Resources。
A resource is binary data that you can add to the executable file of a Windows-based application. A resource can be either standard or defined. The data in a standard resource describes an icon, cursor, menu, dialog box, bitmap, enhanced metafile, font, accelerator table, message-table entry, string-table entry, or version information.</description></item><item><title>加壳原理04 - zlib压缩壳案例</title><link>https://nnnewb.github.io/blog/p/learning-packer-04-zlib-compression-packer-demo/</link><pubDate>Wed, 20 Oct 2021 16:07:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-04-zlib-compression-packer-demo/</guid><description>前言 本文在前一篇基础上，写一个使用 zlib 的压缩壳案例。
0x01 zlib 解压 1.1 概述 关于 zlib 的用法找了这些参考资料：
zlib.net/zpipe.c zlib Usage Example Compress and Decompress a string with zlib 尝试了 zlib、lzo、Windows Compression API，对压缩和解压 API 的基本模式的基本认识大概是这样：
首先，你得有被压缩数据的大小（要么分块压缩，要么有整个压缩后的大小） 然后得有解压后的预期大小，这个能通过 尝试解压 的操作来实现。比如 Windows Compression API 和 lzo 都可以在解压 buffer 传 NULL，尝试取得解压后的大小，再分配好内存解压。 zlib 这样的流式压缩、解压处理文件比较友好，但全程在内存里进行的话，流式解压就会导致大量内存分配 =。= 除非一开始就分配足够的空间，不然一个一个内存块申请和合并会很蛋疼。 1.2 内存布局 压缩后的 .packed 节在头部留出 8 个字节，分别保存压缩后大小和压缩前大小，以便一次分配好内存完成解压。
偏移 大小 内容 0 DWORD 小端序，压缩后大小 4 DWORD 小端序，压缩前大小 8 可变 压缩后的数据 1.</description></item><item><title>加壳原理03 - 支持没有重定位的程序</title><link>https://nnnewb.github.io/blog/p/learning-packer-03-support-no-relocations/</link><pubDate>Wed, 20 Oct 2021 10:25:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-03-support-no-relocations/</guid><description>前言 距离上一篇加壳原理已经过去挺久了，这段时间稍微折腾了一下 nasm，尝试手工制作了 PE32 文件，积累了一些基本的知识吧。
所以现在继续学习加壳——如何对不支持 ASLR 的 PE32 程序进行加壳？
0x01 关于ASLR ASLR是一项内存保护技术，用于防范内存损坏漏洞，比如缓冲区溢出。需要注意的是 ASLR 并不是 解决 了相关威胁，而是让利用相关的漏洞变得更加困难和具有挑战性。
ASLR 的全名是 Address Space Layout Randomization ，地址空间布局随机化技术。一个典型的 PE32 程序在没有 ASLR 支持的情况下， 地址空间布局是确定的：程序镜像总会加载到固定的地址。这个地址会在文件头里指定。攻击者可以利用这一特点来构造恶意数据，让存在内存损坏漏洞的程序按攻击者意图跳过或执行特定逻辑，造成安全威胁。
对应 ASLR 的地址空间布局随机化，程序需要再次编译来支持重定位 Relocation ，别无他法（大概）。
0x02 思路 对于加壳一个没有重定位，不支持 ASLR 的 PE32 程序，假设这个程序的基址是 0x04000000，原先的 VirtualAlloc 方式分配内存是行不通的。加壳后程序若开启 ASLR，则 0x04000000 可能已经存在其他模块，并不能保证这个基址可用。所以加壳后的程序必须也使用 0x04000000 这个基址，而且标记为不支持 ASLR，避免基址已经被其他模块使用造成加载器无法工作。
将加壳后程序的基址设置为固定的 0x04000000 又会产生新的问题：加载器的代码段不能放在 0x04000000 ，否则加载器运行时就会出现被被加载的代码覆盖的情况，导致程序跑飞。所以编译后的加载器所有 Section 都必须有一定的偏移，这个偏移值就是被加载程序的 Section 大小之和（对齐后）。而因此多出来的空间单独分成一个 Section ，正好用来放要加载的程序。
另外，还必须确认文件头大小是否一致，因为我们需要将被加载程序的文件头覆盖加载器的文件头。而最开始预留的空间必须分配为一个 Section，让 Windows 的加载器能顺利加载程序而不报“不是有效的Win32程序”错误。
内存布局示意图如下：
内存布局
所以加载器的加载步骤如下：</description></item><item><title>关于在内存里找kernel32这件事</title><link>https://nnnewb.github.io/blog/p/find-kernel32-in-memory/</link><pubDate>Thu, 14 Oct 2021 16:31:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/find-kernel32-in-memory/</guid><description>前言 总得有个前言。
用 nasm 手工打造了一个 PE 文件后，这个 PE 文件还没什么卵用。如果要动 IAT，又嫌麻烦。网上冲浪找到一篇关于 shellcode 的文章，讲如何在内存里找到 kernel32.dll 并调用 WinExec 函数，于是就想实践一下看看，实际抄代码碰到不少坑。对汇编又熟悉了一点。
0x01 寻找 kernel32 微软有一篇很简短的文章。
The Thread Environment Block (TEB structure) holds context information for a thread.
In the following versions of Windows, the offset of the 32-bit TEB address within the 64-bit TEB is 0. This can be used to directly access the 32-bit TEB of a WOW64 thread. This might change in later versions of Windows</description></item><item><title>nasm汇编手写个PE可执行文件</title><link>https://nnnewb.github.io/blog/p/hand-write-pe-file-with-nasm-assembly/</link><pubDate>Wed, 13 Oct 2021 11:05:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/hand-write-pe-file-with-nasm-assembly/</guid><description>前言 主要是虽然有个汇编器 nasm 但是不知道怎么用，啥汇编都是调试器里纸上谈兵。最近碰到个问题，MinGW 可以用参数 -Wl,section-start= 来修改 section 地址，但 msvc 没有对应物，就蛋疼。手动改 PE 来添加 section 好像可行，但不知道该怎么做，lief 也不熟悉。
正好瞎谷歌的时候发现 nasm 可以直接编译出 PE 文件，这就听起来很有意思了。汇编嘛，听着就很底层，很自由，改个 Section 地址不是手到擒来。于是就学学看。
参考文章附于文末。
0x01 nasm 基本用法 1.1 label 汇编当然有经典的 label 和 instruction 了，instruction 的参数就叫 operand 。
nasm 的 label 语法很简单，任何不是宏和 instruction 或者伪指令的东西，出现在行首，都会被认作 label。
lbl1: ; 这是label sub esp, 4h jmp lbl lbl2 ; 这也是 label sub esp, 4h lbl3 db 1 ; 这还是 label .label4 ; 这是本地 label，可以用 .</description></item><item><title>k3s更新客户端证书的偷懒方法</title><link>https://nnnewb.github.io/blog/p/k3s-renew-client-ca-file-the-lazy-way/</link><pubDate>Mon, 11 Oct 2021 13:58:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/k3s-renew-client-ca-file-the-lazy-way/</guid><description>前言 今天上内网服务器看了眼，准备调试下新代码，结果发现报错 You must logged in to the server (unauthorized) 。翻了半天的 KUBECONFIG 配置，发现啥也没错。换成 /etc/rancher/k3s/k3s.yaml 也不行。于是查了下 journalctl -r -u k3s ，发现日志 x509: certificate has expired or not yet valid: current time ... ，这就明确了是证书过期了。
于是又找了一圈如何给k3s更新证书，搜 how to renew client-ca-file 查出来的方法不是 kubeadm 就是改时间、换证书，总之&amp;hellip;麻烦，而且搜出来的文章可操作性都有点差，真要实践出真知也不能放公司的机器上，搞出点问题还得劝自己心平气和磨上一整天去解决。
于是终于找到个看起来能行的办法：重启。
操作 这个办法可操作性很强——反正情况不会变得更差了。因为办公室的服务器并不能保证24小时不断电，有时候白天上班机器是关机的，重启k3s无论如何不会导致问题变得更差——就算放着不管，过两天说不定也会断电重启下。
确认没人用服务之后直接上手。
sudo systemctl restart k3s 等待重启完成，测试下新的 k3s.yaml 能不能正常用。
export KUBECONFIG=/etc/rancher/k3s/k3s.yaml kubectl cluster-info Kubernetes control plane is running at https://192.168.2.175:6443 CoreDNS is running at https://192.168.2.175:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy Metrics-server is running at https://192.</description></item><item><title>编译LIEF的各种姿势</title><link>https://nnnewb.github.io/blog/p/how-to-compile-lief-on-windows/</link><pubDate>Fri, 08 Oct 2021 16:25:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/how-to-compile-lief-on-windows/</guid><description>前言 惯例得有个前言。
LIEF是一个二进制文件分析和操作库，官方推荐的是 Python 版本，确实更好用，就是类型的问题有点多，而且没附送 .pyi 导致不大好写。而C++版本就没这问题，C++版本有自己的问题=，=
一个是官方提供下载的SDK是静态链接的，用到SDK的程序必须指定 /MT 不然编译器就会抱怨运行库不匹配。虽然看issue里已经有人解决了（-DLIEF_USE_CRT_{DEBUG,RELEASE}=MD/MT），但CI还是老样子，反正直接下载的SDK用起来就蛋疼，vcpkg 全都是 /MD 链接的，没法配合用。
更别提 MinGW 了，就没官方的SDK。
以上就是问题，解决问题的最简单办法就是自己编译了。
0x01 Visual C++ 工具链 msbuild 代码下载下来之后，用 CMake 去编译。下面的命令都是 Powershell 下的，注意折行用的是反引号 backquote，就是波浪号那个键，和 bash 用 反斜杠不一样。直接复制到命令行是跑不起来的。
cmake .. -G &amp;#34;Visual Studio 2019&amp;#34; # Generator，你的工具链，可以用 cmake --help 来看看有哪些可用的 -A Win32 # 选择 Visual C++ 工具链的情况下可以用 -A Win32 选择编译32位代码，或者 Win64 -DCMAKE_BUILD_TYPE=Debug # 常用的 Debug/Release/RelWithDebInfo -DLIEF_PYTHON_API=off # 不编译 Python 模块，这样就不用装 Python 了 -DLIEF_USE_CRT_DEBUG=MD # 使用 /MD 链接 msvcrt.dll 而不是 libcmt 这儿有个坑，用 Visual Studio 这个 Generator 的时候，虽然指定了 CMAKE_BUILD_TYPE，但实际没什么卵用，还得在编译的时候给参数 --config Debug 才会真的按 Debug 编译。</description></item><item><title>加壳原理02 - 简单加壳机</title><link>https://nnnewb.github.io/blog/p/learning-packer-02/</link><pubDate>Tue, 28 Sep 2021 16:57:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-02/</guid><description>前言 对 Windows 程序的加载和运行过程有了基本了解后，手动加载并运行一个PE文件并不成问题。加壳仅仅是在这上面更进一步：把加载程序和被加载的程序合并成一个文件。
这么说可能有点太简单化，大部分的工作其实就在这儿：如何处理被加载的程序？压缩？加密？混淆？加载器（或者叫壳程序）如何反调试？
这里先写一个简单的加壳机，仅仅是把被加载的PE文件作为一个 Section，添加到壳程序里，让壳程序直接从这个 Section 加载并运行。其他花里胡哨的操作都先不整，仅作为证明工作原理的案例。
0x01 壳程序 1.1 思路 和加载一个PE文件不同，既然被加载的程序就在 Section 里，那需要做的只有定位到 Section，然后把 Section 内容当读取进内存的 PE 文件内容处理就好了。
壳程序应该尽量保持轻量，不在原始程序上添加太多东西（加完壳大小翻一倍还多了一堆DLL依赖那谁受得了啊），所以很多标准C库的函数也不能用了，像是memcpy、strcmp 都要自己简单实现一个。
1.2 壳实现 绝大部分内容和之前文章中的 load_PE 一致，入口点修改为 _start，需要注意。
#include &amp;lt;Windows.h&amp;gt;#include &amp;lt;winnt.h&amp;gt; void *load_PE(char *PE_data); void fix_iat(char *p_image_base, IMAGE_NT_HEADERS *p_NT_headers); void fix_base_reloc(char *p_image_base, IMAGE_NT_HEADERS *p_NT_headers); int mystrcmp(const char *str1, const char *str2); void mymemcpy(char *dest, const char *src, size_t length); int _start(void) { char *unpacker_VA = (char *)GetModuleHandleA(NULL); IMAGE_DOS_HEADER *p_DOS_header = (IMAGE_DOS_HEADER *)unpacker_VA; IMAGE_NT_HEADERS *p_NT_headers = (IMAGE_NT_HEADERS *)(((char *)unpacker_VA) + p_DOS_header-&amp;gt;e_lfanew); IMAGE_SECTION_HEADER *sections = (IMAGE_SECTION_HEADER *)(p_NT_headers + 1); char *packed = NULL; char packed_section_name[] = &amp;#34;.</description></item><item><title>加壳原理01 - Windows 程序的加载和运行</title><link>https://nnnewb.github.io/blog/p/learning-packer-01/</link><pubDate>Mon, 27 Sep 2021 14:51:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-01/</guid><description>前言 本文由多篇相关文章翻译整合得来，参考文章和书目文末给出。
0x01 PE文件结构 PE_Format
1.1 从 PE-COFF 格式说起 &amp;hellip; 现在PC平台流行的 可执行文件格式（Executable） 主要是 Windows 下的 PE （Portable Executable） 和 Linux 的 ELF （Executable Linkable Format），它们都是 COFF（Common Object File Format）格式的变种。目标文件就是源代码编译后但未进行链接的那些中间文件（Windows 的 .obj 和 Linux 下的 .o），它和可执行文件的内容和结构很相似，所以一般跟可执行文件一起采用一种格式存储。从广义上看，目标文件与可执行文件的格式其实几乎是一样的，所以我们可以广义地将目标文件与可执行文件看成是同一种类型的文件，在 Windows 下，我们可以统称它们为 PE-COFF 文件格式。在 Linux 下，我们可以将它们统称为 ELF 文件。
&amp;hellip; 不光是 可执行文件 （Windows 的 .exe 和 Linux 下的 ELF 可执行文件）按照可执行文件格式存储。动态链接库（DLL，Dynamic Linking Library） （Windows 的 DLL 和 Linux 下的 .so ）以及静态链接库 （Static Linking Library） （Windows 的 .</description></item><item><title>自娱自乐 crackme-03</title><link>https://nnnewb.github.io/blog/p/crackme-03/</link><pubDate>Fri, 24 Sep 2021 16:58:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/crackme-03/</guid><description>前言 总得有个前言。
一直玩命令行 crackme 看着就没啥意思，来点带界面的。依然是学习用，目标是把汇编和底层和内存这套东西读熟。这次是用 wxwidgets 做的简单 crackme，为了在 CrackME-02 基础上再增加点难度但又不至于太难，这次是 OTP 生成序列号，要求解出生成 OTP 的 SECRET。
源码 越来越长了，贴上来没法看。现在托管到GitHub，包括前面的两个cm。
前两个cm托管的代码编译参数有一点修改，可能造成结果和文章不一致，但大体是一样的，别在意。
源码托管地址：github.com/nnnewb/crackmes
挑战一下C++代码开启优化的Hard模式。
观察 image-20210923104439284
一个输入框，点击try it尝试。失败时提示Wrong，没有别的信息。
静态分析 老规矩先静态分析一波，粗略扫一眼，捋一捋逻辑。用你喜欢的反汇编工具打开，我用Cutter先试试。
因为是GUI程序，直接跳main肯定是不行的。Win32 GUI程序的入口点（程序员视角）在WinMain这个特殊函数，不过真拿Win32API手撸界面我是真没见过了，Win32 GUI程序设计也是玩的事件响应，找到主函数的意义不大。
所以找关键跳这一步只能是从数据段找字符串查引用，或者调试器下合适的访问断点了。
这里直接从数据段找到了字符串，定位到弹出错误对话框的逻辑。
image-20210923105415082
这里有个姿势点是__thiscall，这是个微软自定义的调用约定，点这里看微软的文档。
__thiscall __thiscall的特点是被调用方清栈，this指针通过ecx寄存器传递，其他参数右至左压栈。对于可变长度参数（VAARG）的成员函数会特殊处理，采用cdecl调用约定，this指针最后压栈。
这里简单读一下定位到的几句代码，分析下意图。
0x004064dc 68 34 e8 40 00 push str.Try_again ; 0x40e834 0x004064e1 8d 4d d0 lea ecx, [ebp - 0x30] 0x004064e4 ff 15 e0 33 41 00 call dword [public: void __thiscall wxString::constructor(char const *)] ; 0x4133e0 0x004064ea 68 44 e8 40 00 push str.</description></item><item><title>自娱自乐 crackme-02</title><link>https://nnnewb.github.io/blog/p/crackme-02/</link><pubDate>Wed, 15 Sep 2021 15:43:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/crackme-02/</guid><description>得有个前言 总之上一个 crackme-01 还过得去，稍微加强一点，把密码隐藏起来，不要随便被看到。
0x01 源码 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt; size_t getline(char **lineptr, size_t *n, FILE *stream) { char *bufptr = NULL; char *p = bufptr; size_t size; int c; if (lineptr == NULL) { return -1; } if (stream == NULL) { return -1; } if (n == NULL) { return -1; } bufptr = *lineptr; size = *n; c = fgetc(stream); if (c == EOF) { return -1; } if (bufptr == NULL) { bufptr = malloc(128); if (bufptr == NULL) { return -1; } size = 128; } p = bufptr; while (c !</description></item><item><title>自娱自乐 CrackMe-1</title><link>https://nnnewb.github.io/blog/p/crackme-01/</link><pubDate>Fri, 10 Sep 2021 09:49:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/crackme-01/</guid><description>前言 总之得有个前言。从前有个老和尚（不是，掉光了头发的攻城狮），&amp;hellip;&amp;hellip;
以上略，于是作为萌新含量110%的萌新，出于练手、熟悉下反汇编调试的环境之类的目的，还是自己写crackme来把玩吧。
CM01 介绍 于是这个 CrackMe 就叫 CM01 好了，命令行无界面。适合差不多对这些东西懂个大概或者打算学习的萌新：
反汇编/调试工具 寄存器（主要是 ebp、esp、eip、eax） 函数调用（cdecl） 栈/栈帧 内存模型和寻址 CM01 源码 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt; size_t getline(char **lineptr, size_t *n, FILE *stream) { char *bufptr = NULL; char *p = bufptr; size_t size; int c; if (lineptr == NULL) { return -1; } if (stream == NULL) { return -1; } if (n == NULL) { return -1; } bufptr = *lineptr; size = *n; c = fgetc(stream); if (c == EOF) { return -1; } if (bufptr == NULL) { bufptr = malloc(128); if (bufptr == NULL) { return -1; } size = 128; } p = bufptr; while (c !</description></item><item><title>32位 Windows x86 汇编语言学习</title><link>https://nnnewb.github.io/blog/p/assembly-learning-note/</link><pubDate>Thu, 09 Sep 2021 16:14:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/assembly-learning-note/</guid><description>前言 最近迷上了 Crack Me，入门无果。老是看到有大佬发52pojie又有哪个佬把什么黄油给手撕了，心痒痒。干脆也正正经经地去学一下好了。
这当然也算是程序员本职的正经知识（心虚而且超大声）。
常规知识和速记 笔记内容是关于 8086/x86 汇编。
x86体系结构下内存和寄存器都是小端序。小端序指低位在右，高位在左。如0x1的小端序表示是0000 0001。
8比特能表示2位16进制数（0xFF，也就是255），16比特能表示4位16进制数（0xFFFF，65535），32比特能表示8位16进制数（0XFFFFFFFF，4294967295）。
数据类型：
助记符 描述 dword 双字（double word），32比特整型数据。 word 字，16比特整型数据。 byte 字节，8比特整型数据。 常用的16进制数记法：
0x2A，前缀0x 2AH，后缀H 寄存器 通用寄存器 参考：x86汇编 - 维基百科
参考：x64体系结构 - windows hardware
64位寄存器 32位寄存器 16位寄存器 8位寄存器 用途 RAX或R0 EAX AX AL和AH Accumlator，累加寄存器，用于算术运算。 RBX或R3 EBX BX BL和BH Base，基址寄存器，指向数据块基址（段模式存于段寄存器DS） RCX或R1 ECX CX CL和CH Counter，用于用于移/环指令及循环（没懂）。 RDX或R2 EDX DX DL和DH Data，用于数学运算和IO操作。 RSI或R6 ESI SI SIL Source Index，指向指令流操作中的源。 RDI或R7 EDI DI DIL Destination Index，指向指令流操作中的目标。 RBP或R5 EBP BP BPL Stack Base Pointer，指向栈的基地址。 RSP或R4 ESP SP SPL Stack Pointer，指向栈顶的地址。 R8 R8D R8W R8B 无别名。 R9 R9D R9W R9B 无别名。 R10 R10D R10W R10B 无别名。 R11 R11D R11W R11B 无别名。 R12 R12D R12W R12B 无别名。 R13 R13D R13W R13B 无别名。 R14 R14D R14W R14B 无别名。 R15 R15D R15W R15B 无别名。 后续还是用 32 位寄存器的名字称呼这些寄存器。</description></item><item><title>信号量 vs 互斥锁</title><link>https://nnnewb.github.io/blog/p/%E4%BF%A1%E5%8F%B7%E9%87%8F-vs-%E4%BA%92%E6%96%A5%E9%94%81/</link><pubDate>Thu, 26 Aug 2021 00:00:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E4%BF%A1%E5%8F%B7%E9%87%8F-vs-%E4%BA%92%E6%96%A5%E9%94%81/</guid><description>看 go-patterns/semaphore.md at master · tmrts/go-patterns (github.com) 时产生了疑问，信号量为啥长得和互斥锁没啥区别呢。于是就谷歌了一圈，重温下一些关于并发的知识，对比信号量 semaphore 和互斥锁 mutex 。
互斥锁 mutex 以 pthread 自带的互斥锁为例，提供了三种不同类型的互斥锁：
PTHREAD_MUTEX_NORMAL ，普通的互斥锁，不支持死锁检测（does not detect deadlock），不支持递归加锁（relock without first unlocking it 会导致死锁），不检测解锁线程，解锁一个未加锁的互斥锁是未定义行为（undefined behavior）。 PTHREAD_MUTEX_ERRORCHECK，带错误检查的互斥锁，不支持递归加锁（会返回错误），解锁其他线程的互斥锁会返回错误，解锁未加锁的互斥锁会返回错误。 PTHREAD_MUTEX_RECURSIVE，递归加锁（relock with out unlocking it）会成功，解锁时需要调用解锁的次数和加锁时调用加锁的次数相同。解锁其他线程的互斥锁会返回错误。解锁未加锁的互斥锁会返回错误。 PTHREAD_MUTEX_DEFAULT，默认互斥锁类型，对这一类型的互斥锁递归加锁时行为是未定义的，解锁未加锁的互斥锁行为是未定义的，解锁其他线程的互斥锁行为是未定义的。这一类型的互斥锁通常映射为另外几种互斥锁之一。 可以比较清楚地看出，互斥锁有三个基本特征：
是否可重复加锁 是否可解锁未加锁的互斥锁 是否可解锁被其他人加锁的互斥锁 最严格的 PTHREAD_MUTEX_ERRORCHECK 类型互斥锁，对此定义是 NO、NO、NO 。
互斥锁的基本使用方式和使用场景有点像厕所的坑位：
抢坑位，锁门 你懂的 解锁，出门 其中有隐含的信息包括：
坑位是提前选择好的，你只能抢一个坑位，不能抢多个坑位。 坑位在使用期间是独占的，你不能和别人分享一个坑位。 只有你自己能解锁坑位，谁也不想办事儿的时候有人闯进来吧？ 而递归加锁这一特殊场景，我寻思吧，有点难拿坑位比喻。反正也不重要，就别管了。
信号量 semaphore 信号量本质上是一个整型值，不细分什么类型了。还是用 pthread 举例吧，依据 POSIX 标准。
对信号量的操作可以先简单分5种。
sem_init(sem,pshared,value)，初始化一个信号量，可以指定要不要在 fork() 创建的进程间共享，还可以指定信号量初始值。 sem_wait(sem)，等待信号量，信号量等于0时阻塞，其他线程通过sem_post唤醒。 sem_post(sem)，发送信号量，唤醒阻塞在sem_wait的线程。 sem_getvalue(sem,valp)，获取信号量当前值。 sem_destroy(sem)，销毁信号量。 信号量的主要特征就是它的值：</description></item><item><title>面试题之 goroutine 运行顺序</title><link>https://nnnewb.github.io/blog/p/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B-goroutine-%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/</link><pubDate>Wed, 04 Aug 2021 10:37:24 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B-goroutine-%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/</guid><description>不是我做的沙雕面试题，在 segmentfault 上看到的。
原题 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;sync&amp;#34; ) func main() { runtime.GOMAXPROCS(1) wg := sync.WaitGroup{} wg.Add(10) for i := 0; i &amp;lt; 5; i++ { go func() { fmt.Println(&amp;#34;A:&amp;#34;, i) wg.Done() }() } for i := 0; i &amp;lt; 5; i++ { go func(num int) { fmt.Println(&amp;#34;B:&amp;#34;, num) wg.Done() }(i) } wg.Wait() } 问：代码输出结果是什么？
胡乱分析 第一眼进去看到 runtime.GOMAXPROCS(1) ，初步怀疑是又在考什么 GMP 面试题了。
但凡说到 Go 面试好像就一定要考一下 goroutine 调度和 GMP 模型，招进来又只让你写 curd 。搞得面试跟考试背书一样。</description></item><item><title>用 tree-sitter 写一个代码高亮</title><link>https://nnnewb.github.io/blog/p/%E7%94%A8-tree-sitter-%E5%86%99%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/</link><pubDate>Tue, 03 Aug 2021 15:52:21 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E7%94%A8-tree-sitter-%E5%86%99%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/</guid><description>这次用 tree-sitter 写一个简单的代码高亮。
前言 我寻思代码高亮是什么应该没啥可解释的，也有叫“语法高亮”，总之都是一个意思。就是给编辑器里的代码涂上颜色，便于阅读。
一般来说，简单的代码高亮只需要正则表达式就能搞定（比如说关键字高亮，Camel Case 标识符高亮等），不过正则表达式来实现高亮还是有很大的局限性。
举例来说，当我把函数当参数传给另一个函数的时候——
function f() {} function higher(fn) { return () =&amp;gt; fn() != 0; } higher(f); 在 higher(f) 这一行中的 f 不会以函数名的颜色标出。这就引出了一种新基于语义的代码高亮，让编辑器真正“认识”你的代码，并提供更聪明的提示。
开始 还是在 vscode 折腾。
先创建一个 vscode 插件项目，用 yo code 完成。
然后编辑 package.json ，添加你的语言和插件的激活事件。
{ &amp;#34;activationEvents&amp;#34;: [&amp;#34;onLanguage:proto&amp;#34;], &amp;#34;contributes&amp;#34;: { &amp;#34;languages&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;proto&amp;#34;, &amp;#34;extensions&amp;#34;: [&amp;#34;.proto&amp;#34;] } ] } } 然后修改 src/extension.ts，去掉默认创建的 hello world 代码，留一个 console.log，然后 F5 启动，打开一个 .proto 文件，检查插件是否已经激活。
// The module &amp;#39;vscode&amp;#39; contains the VS Code extensibility API // Import the module and reference it with the alias vscode in your code below import * as vscode from &amp;#34;vscode&amp;#34;; // this method is called when your extension is activated // your extension is activated the very first time the command is executed export function activate(context: vscode.</description></item><item><title>玩玩 tree-sitter</title><link>https://nnnewb.github.io/blog/p/%E7%8E%A9%E7%8E%A9-tree-sitter/</link><pubDate>Thu, 29 Jul 2021 10:14:36 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E7%8E%A9%E7%8E%A9-tree-sitter/</guid><description>什么是tree-sitter呢？
tree-sitter 是一个 parser-generator，也是一个增量解析库（incremental parsing library）。它可以为源文件构建完整的语法树，并在源文件被编辑时高效地更新。
快速开始 tree-sitter 本身是一个 parser generator ，使用 javascript 来作为描述语法规则的语言（不像其他，如 yacc 一类的工具，以类似 EBNF 的 DSL 来描述语法规则）。
我们写 tree-sitter 语法规则本质上是类似于写一个 tree-sitter 的语法支持包，可以参考下 tree-sitter/tree-sitter-go: Go grammar for tree-sitter (github.com) 的项目结构。
废话不多说，先写个简单的 demo 跑起来。
mkdir tree-sitter-hello &amp;amp;&amp;amp; cd tree-sitter-hello npm init npm i --save nan npm i --save-dev tree-sitter-cli 初始化好项目目录，在 package.json 里写个简单的命令，方便之后用。
{ &amp;#34;scripts&amp;#34;:{ &amp;#34;test&amp;#34;: &amp;#34;tree-sitter generate &amp;amp;&amp;amp; tree-sitter parse test.txt&amp;#34; } } 现在开始干正事儿，创建一个 grammar.js
module.exports = grammar({ name: &amp;#39;hello&amp;#39;, rules: { source_file: $ =&amp;gt; repeat($.</description></item><item><title>csr 方式创建 kubernetes 用户出了点差错</title><link>https://nnnewb.github.io/blog/p/csr-%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA-kubernetes-%E7%94%A8%E6%88%B7%E5%87%BA%E4%BA%86%E7%82%B9%E5%B7%AE%E9%94%99/</link><pubDate>Mon, 19 Jul 2021 09:52:38 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/csr-%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA-kubernetes-%E7%94%A8%E6%88%B7%E5%87%BA%E4%BA%86%E7%82%B9%E5%B7%AE%E9%94%99/</guid><description>越是在 kubernetes 的浑水里摸索，越是发现这就是个不顺手的锤子。
网上很多人喜欢把东西用不惯叫做懒，蠢，要是多反驳几句，那就还得搭上个“坏”的帽子。感觉吧，就这帮人看来，大神放个屁也值得学习，从里面“悟”出什么道理。
这帮人就跟传教士一样，但凡说个不字，就是在亵渎他们的“大神”。可谓人类迷惑行为。
好吧。技术别饭圈化行吗？
你说尤大强吗？Richard Stallman 是不是值得尊敬？Google 是不是最好的技术公司？Android 天下无敌？
然后全摆上神坛，挂上赛博天神的牌匾，插上网线一天 25 小时膜拜？
这帮人哪天搞个崇拜互联网和计算机的教派，把冯·诺依曼奉为先知我都不奇怪。
拜托，你们真的好怪欸。
完整脚本 #!/bin/bash -e # # 创建用户 gitlab 并授予权限 # # reference: # https://kubernetes.io/zh/docs/reference/access-authn-authz/certificate-signing-requests/#normal-user # if `gitlab` does not exists, # create csr and approve if ! kubectl get csr gitlab &amp;gt;/dev/null; then # create credential if [ ! -f gitlab.csr ]; then openssl genrsa -out gitlab.key 2048 openssl req -new -key gitlab.key -out gitlab.csr fi csr=$(cat gitlab.</description></item><item><title>升级公司的 GitLab</title><link>https://nnnewb.github.io/blog/p/%E5%8D%87%E7%BA%A7%E5%85%AC%E5%8F%B8%E7%9A%84-gitlab/</link><pubDate>Thu, 15 Jul 2021 16:02:41 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E5%8D%87%E7%BA%A7%E5%85%AC%E5%8F%B8%E7%9A%84-gitlab/</guid><description>公司目前跑的 gitlab 是很久以前部署的，当前版本 8.4.2 。升级目标是 13.12.Z 。部署方式是 docker 。
宿主机配置不高，系统 Ubuntu 15.04 。眼下这个时间，这个Ubuntu版本，基本宣告没法用了。直接在线升级容易把引导搞挂，到时候还得亲自去实体机上折腾引导，麻烦。暂时不管宿主机。
情况概述 因为 GitLab 版本实在太低了，以至于连一个能集成的 CI/CD 工具都找不到。即使 jenkins 都只能很勉强地动起来，偏偏 jenkins 还不能满足需要（也可能是我太菜，反正公司没人玩得转 jenkins）。
但开发需要 CI/CD 来解决持续构建和部署的问题，不得不考虑升级了。
1. 备份 什么都别说了，开干前最重要的事情就是备份，免得把自己玩死。
最常用的备份手段自然是 tar 。不过 gitlab 数据目录实在太大了，要是直接运行 tar -czpf gitlab.tar.gz ./gitlab 不知道跑多久，也不知道有没有卡死。
于是上技术手段：用 pv 显示个进度条。
pv 项目的首页在 ivarch.com。因为服务器还在跑ubuntu 15.10，现在连个能用的源都没啦。只好下载了源码，在 wsl 里编译好推上去。
最终命令如下。
sudo tar cf - ./gitlab -P | pv -s $(sudo du -sb ./gitlab | awk &amp;#39;{print $1}&amp;#39;) | gzip &amp;gt; gitlab.</description></item><item><title>MySQL XA 事务和分布式事务处理模型：2阶段提交</title><link>https://nnnewb.github.io/blog/p/mysql-xa-%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B2%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/</link><pubDate>Fri, 09 Jul 2021 09:29:22 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/mysql-xa-%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B2%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/</guid><description>关于 MySQL XA 事务和 2PC（两阶段提交）分布式事务处理模型（Distributed Transaction Processing, DTP Model）的学习笔记。
事务 分布式事务XA 介绍 MySQL内建分布式事务支持（XA），参考文档列出如下
[MySQL Manual - XA](MySQL :: MySQL 8.0 Reference Manual :: MySQL Glossary) [MySQL Manual - XA Transaction](MySQL :: MySQL 8.0 Reference Manual :: 13.3.8 XA Transactions) [MySQL Manual - XA Transaction Statements](MySQL :: MySQL 8.0 Reference Manual :: 13.3.8.1 XA Transaction SQL Statements) [MySQL Manual - XA Transaction State](MySQL :: MySQL 8.0 Reference Manual :: 13.3.8.2 XA Transaction States) XA 事务在 InnoDB 引擎中可用。MySQL XA 事务实现基于 X/Open CAE 文档 《Distributed Transaction Processing: The XA Specification》。这份文档由 Open Group 发布，可以在 http://www.</description></item><item><title>不常用的 Git 命令</title><link>https://nnnewb.github.io/blog/p/%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%9A%84-git-%E5%91%BD%E4%BB%A4/</link><pubDate>Fri, 09 Jul 2021 09:25:16 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%9A%84-git-%E5%91%BD%E4%BB%A4/</guid><description>大概是不太常用的一些 Git 命令。
找回数据 两种办法：
git reflog show git reset --hard HEAD@{1} # 从上一步找到希望回退的位置 或者
git fsck --lost-found cd .git/lost-found/ # 用 git show hash 查看悬空对象的内容 # 用 git merge hash 或者 git rebase hash 来恢复到当前分支里 合并分支时创建合并commit git config branch.master.mergeoptions &amp;#34;--no-ff&amp;#34; 删除远程分支 git push --delete origin branch 删除已经合并的分支 参考
删除已合并的本地分支 git branch --merged \ | grep -E &amp;#34;^\\s+(patch|feat|refactor|test|misc)&amp;#34; \ | xargs -I{} git branch -d {} 删除已合并的远程分支 git branch -r --merged \ | grep -E &amp;#34;^\\s+origin/(patch|feat|refactor|test|misc)&amp;#34; \ | sed &amp;#39;s/origin\///&amp;#39; \ | xargs -I{} echo git push --delete origin {}</description></item><item><title>从零实现一个容器</title><link>https://nnnewb.github.io/blog/p/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8/</link><pubDate>Mon, 31 May 2021 16:16:52 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8/</guid><description>前言 自从看了cocker项目的 ppt 之后就有点念念不忘的意思了，实现一个 docker 或 docker 的类似物看起来并不是做不到的事情。
于是就动手试一试。
核心技术 namespace 命名空间包装全局系统资源，让在命名空间中的进程看起来就像是有自己独立隔离的全局资源一样。命名空间中的全局资源对命名空间中的其他进程都是可见的，但对命名空间外的进程不可见。命名空间用途之一就是实现容器。
Linux provides the following namespaces: Namespace Constant Isolates Cgroup CLONE_NEWCGROUP Cgroup root directory IPC CLONE_NEWIPC System V IPC, POSIX message queues Network CLONE_NEWNET Network devices, stacks, ports, etc. Mount CLONE_NEWNS Mount points PID CLONE_NEWPID Process IDs User CLONE_NEWUSER User and group IDs UTS CLONE_NEWUTS Hostname and NIS domain name 几个命名空间的 API
clone setns unshare 不得不说 man 7 namespaces 对 namespace 的解释已经非常到位了。</description></item><item><title>2021-04-25 无事发生</title><link>https://nnnewb.github.io/blog/p/2021-04-25-%E6%97%A0%E4%BA%8B%E5%8F%91%E7%94%9F/</link><pubDate>Sun, 25 Apr 2021 10:40:30 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/2021-04-25-%E6%97%A0%E4%BA%8B%E5%8F%91%E7%94%9F/</guid><description>4月25日好像也不是什么节日，对我个人来说也没有什么特殊意义。仅仅是普通的一天——如果不算五一调休导致今天明明是周日但还要上班这一点的话。
想想也挺不可思议的，不知不觉已经到2021年这个在不少科学幻想中的“未来”时代了，光算工作年限，我也干了有四五年的程序了吧。
从最开始抱着“不写代码还能干啥”到“写代码也挺不错的”，再到现在，“还能写几年代码呢”。
反思一下这几年，几乎没干出什么成绩，工作一年一换，工作几年下来，也没几个认识、熟悉到可以称之为“朋友”的人。倒不是我孤僻（这么说的人一般都确实孤僻吧），主要是确实没什么主观能动性。
如今这家公司写写 go，折腾折腾 kubernetes，也算清闲，反倒开始忧心起将来了。
现在的工作，说好，也就那样。说不好，这个大环境下，但凡没失业，我觉得都算不上不好吧。
又是疫情，又是新冷战，又是各种各样的奇葩事。当笑话看，看久了也笑不出来了。
我这人爱看小说，以前也是动画漫画来者不拒，特效大片就饭，总之蛮快乐的。过去还写过同人小说，可惜没得家里支持，最后也就是40万字左右就切了。
不过起码这段经历算是给我找第一份码农工作加了点助力（大概）。自从开始写代码拿工资，好像写小说这回事就和我没什么关系了的样子。
不过我还是一直想写的，几乎每次换工作，心里想的都是空闲的时间多了，就会用来做点有意义的事情。比如学学钢琴啊（买了电钢琴吃灰中），比如写写小说啊（也就开了个头），比如学点新技术啊（有倒是有，新工作新技术栈），总之就是自我提升下。
结果当然是没有的。
好像从前读书的时候捧着本 C Primer Plus/C++ Primer 看的激情已经完全从身体里消失了一样。不管是什么事情，虽然总是想到，啊，这个想要，那个想要。但一到行动，就完全没了动力。“做了也没用”，“学了也是浪费时间”这种想法就从脑子里冒出来了。
不能说和家庭完全没关系——但把责任都推给父母、老师，大概也不合适。
我是相信环境会改变人的，当然人也能发挥主观能动性，改造环境。像是叶子随波逐流进了下水道，不能说是水有错，也不能怪叶子没有奋力闪躲，秋风更是无辜。于是环视四周，最后悲哀地发现只能感叹一句命运无常。
诸如未来可以改变之类的鸡汤喝了又喝，脑子也有了抗性，不切实际的期待也越来越少，然后发现即使是切实可行的期待也开始落向不切实际的一侧。
那便不想未来了吧。俗话说，“把握当下”。于是便来上班，对着屏幕，无事可做，等待 call of work。
那便是这样了吧。
2021年4月25日，无事发生。</description></item><item><title>pattern-match-in-python310</title><link>https://nnnewb.github.io/blog/p/pattern-match-in-python310/</link><pubDate>Fri, 19 Mar 2021 10:19:06 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/pattern-match-in-python310/</guid><description>说明 简单机翻润色一下 PEP-636
概要 这个PEP是PEP 634引入的模式匹配教程。
PEP 622提出了模式匹配的语法，社区和指导委员会对此进行了详细讨论。一个常见的问题是解释(和学习)这个特性是否容易。这个PEP关注的是提供开发人员可以用来学习Python中的模式匹配的文档类型。
PEP 636 被认为是PEP 634(模式匹配的技术规范)和PEP 635(模式匹配的添加动机和理由与设计考虑)的支持材料。
对于想要快速回顾而不是教程的读者，请参阅附录a。
教程 作为本教程的一个例子，你将编写一个文本冒险游戏。这是一种互动小说形式，用户输入文本命令与虚构世界进行互动，并接收关于所发生事情的文本描述。命令将是简化形式的自然语言，如get sword，attack dragon，go north，enter shop或but cheese。
匹配序列 你的主循环将需要从用户那里获取输入，并将它分割成单词，例如一个像这样的字符串列表:
command = input(&amp;#34;What are you doing next? &amp;#34;) # analyze the result of command.split() 下一步是解读这些单词。我们的大多数命令都有两个词:一个动作和一个对象。所以你可能会忍不住这样做:
[action, obj] = command.split() ... # interpret action, obj 这行代码的问题在于它遗漏了一些东西：如果用户输入的单词多于或少于2个单词怎么办?为了防止这个问题，您可以检查单词列表的长度，或者捕获上面的语句将引发的ValueError。
或者，你可以使用match语句来代替:
match command.split(): case [action, obj]: ... # interpret action, obj match语句计算**“subject”**(match关键字后面的值)，并根据模式(case旁边的代码)检查它。一个模式可以做两件不同的事情:
验证 subject 具有一定的结构。在您的示例中，[action, obj]模式匹配任何恰好包含两个元素的序列。这叫做 maching。 它将模式中的一些名称绑定到 subject 的组件元素。在本例中，如果列表有两个元素，它将绑定action = subject[0]和obj = subject[1]。 如果匹配，则case块内的语句将与绑定的变量一起执行。如果没有匹配，则什么也不发生，然后执行match之后的语句。</description></item><item><title>go 的 defer 语句</title><link>https://nnnewb.github.io/blog/p/go-%E7%9A%84-defer-%E8%AF%AD%E5%8F%A5/</link><pubDate>Tue, 05 Jan 2021 10:01:48 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/go-%E7%9A%84-defer-%E8%AF%AD%E5%8F%A5/</guid><description>昨天对项目做了个小重构，主要是对以前手写的 stmt.Close 没处理返回值的问题、还有各种该记录日志的地方没记日志等等，做了下处理。
老实说这事儿做着做着还有种奇妙的快感，类似于看高压水枪清污视频的感觉。哈哈，也亏领导不管事，代码也不 Review ，测试=摆设。
这不一上班就发现好多问题，幸好只推送到内网。
笑中带泪.gif
0x01 问题描述 问题倒是挺简单的，看下面的代码。
stmt := db.Prepare(query) defer SilentLogError(stmt.Close(), &amp;#34;stmt close failed&amp;#34;) row := stmt.QueryRow(params...) defer row.Close() if err = row.Scan(vars...); err != nil { return nil, err } return vars, nil 那么，请问上面的代码有什么问题呢？
标题都说了 defer 了，那问题肯定是出在 defer 这一行上。
0x02 defer 的求值 简单的结论就是: defer f() 的参数在 defer 这一行求值
具体到上面的例子，defer f(i()) 这样的形式，可以先分成三个部分。
defer 本身的执行时机 i() 的求值时机 f() 的求值时机 把这三部分排一下序:
i() defer defer 把参数求值后包装成一个新函数延迟执行</description></item><item><title>在 slackware 上安装 neovim</title><link>https://nnnewb.github.io/blog/p/%E5%9C%A8-slackware-%E4%B8%8A%E5%AE%89%E8%A3%85-neovim/</link><pubDate>Mon, 04 Jan 2021 15:00:20 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E5%9C%A8-slackware-%E4%B8%8A%E5%AE%89%E8%A3%85-neovim/</guid><description>最近在虚拟机里折腾 slackware ，发现 slackware 14.2 的 vim 版本还停留在 7.4 ，于是考虑还是装个 neovim 算了。毕竟升级 vim8 还得自己写 SlackBuild，万一和原本的 vim 7.4 冲突就更头疼了。
0x01 确定依赖 到处翻 slackbuild 之间依赖关系的时候发现 sbopkg 提供了一个解决依赖的脚本，sqg。
于是简单点，拿 sqg -p neovim 生成 neovim 的安装队列 neovim.sqf 文件。
sqg 和 sbopkg 一起提供了，所以不用另外安装。
0x02 安装 一条命令：sudo sbopkg -i neovim.sqf
然后等完成吧。
0x03 可选依赖 上述步骤完成后还只是装好基本的 neovim ，但 python2/python3/ruby/nodejs 支持都是没有的。
打开 nvim，输入命令 :checkhealth 后会显示缺少支持，同时也提供了解决办法：pip install pynvim。
然后就是另一个坑：pip 也不在默认的 python2 包里。于是为了解决这个问题，还得先装上 pip : sudo sbopkg -i python-pip
然后执行 sudo pip install pynvim，此时 python2 支持已经装好。</description></item><item><title>slackware 和虚拟机基本配置</title><link>https://nnnewb.github.io/blog/p/slackware-%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</link><pubDate>Wed, 30 Dec 2020 11:11:56 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/slackware-%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</guid><description>slackware 是一个非常有极客味的 Linux 发行版，因为官方维护的包不多，基本靠 slackbuilds 续命。
slackware 的一个特色是包管理系统不处理依赖关系，这一点劝退不少人。
实际上，虽然我不是很赞同 这个观点 ，不过并不妨碍 slackware 成为可玩性相对高的 Linux 发行版之一（另外几个可玩性不错的发行版包括 Arch Linux 和 Gentoo）。
这篇博文实际上就是安利下 slackware 并且简要介绍下怎么在虚拟机里搭建个基本环境来体验游玩。
0x01 安装 安装的参考文档太多了，个人认为主要的难点在分区和引导。毕竟不像其他更流行的发行版的 GUI 安装引导，对 fdisk 和 parted 这些工具不熟悉、对操作系统引导启动的一些基本概念、原理不了解的人很容易犯下错误而不自知。
这里提供一篇之前在贴吧写的 安装教程 ，不做赘述了。
0x02 桌面 对习惯了装完就有桌面的用户来说，安装完 slackware 之后遇到的第一个问题就是怎么进入桌面——甚至会问怎么登陆。
这里就挂一张 gif 好了。
01
假设没手贱在安装的时候把 x/kde/xfce 之类的软件包组给去掉的话，就不会有什么问题。
如果需要自动进入桌面，需要手动修改 /etc/inittab 文件，把默认的 runlevel 修改为 4 。
具体怎么改，看 gif 。
02
0x03 slackpkg 包管理 如果用过 ubuntu ，那么下一个问题可能就是 &amp;ldquo;怎么没有 apt-get 命令？&amp;rdquo; 或者 &amp;ldquo;slackware 用什么命令安装软件？&amp;rdquo;</description></item><item><title>一个安卓应用的逆向分析</title><link>https://nnnewb.github.io/blog/p/%E4%B8%80%E4%B8%AA%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</link><pubDate>Tue, 29 Dec 2020 14:04:02 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E4%B8%80%E4%B8%AA%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</guid><description>说起来也不算什么新鲜的东西，现成的工具拼拼凑凑就搞定了，单纯算是点亮了新的技能。
待破解应用的名字不透露了，避免引火烧身。
需要准备的工具包括
mumu 模拟器(或者别的什么有 root 权限、能装 xposed 的模拟器) FDex2 脱壳 jadx 反编译 dex 源码 apktools 拆解 apk mitmproxy 中间人拦截网络请求 0x01 目标和方向选择 首要的目标是破解这个软件的 api 加密。
使用 mitmproxy 抓到 https 流量，发现请求体全部是 base64 ，解码发现乱码。基本断定是加密了。
mitmproxy 怎么抓 https 流量不多说了，基本流程就是装证书，然后配置代理。能看到有流量进 mitmproxy 就算成功了。
直接参考 mitmproxy 的文档快一点。
01
搜了一圈没有什么现成的对这个 App 的破解的文章，于是决定自己动手。
0x02 解包和脱壳 先确认下电脑上装了 JDK 或者 JRE ，没有的话就装好。
推荐一个 vscode 的插件，apklab。会帮你装好 jadx 和 apktools / signer 这些工具。
接下来直接用 apklab 打开需要破解的 apk 文件。</description></item><item><title>在C++中嵌入Python解释器</title><link>https://nnnewb.github.io/blog/p/%E5%9C%A8c-%E4%B8%AD%E5%B5%8C%E5%85%A5python%E8%A7%A3%E9%87%8A%E5%99%A8/</link><pubDate>Fri, 07 Feb 2020 21:59:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E5%9C%A8c-%E4%B8%AD%E5%B5%8C%E5%85%A5python%E8%A7%A3%E9%87%8A%E5%99%A8/</guid><description>先不说废话，项目地址：https://github.com/nnnewb/CQPy 。欢迎给个 Star 什么的。
背景 想给最近在玩的酷 Q 写个插件，发现没有合适的直接使用 Python 的解决方案。
Richard Chien 提供了一个比较通用的插件，CQHttp。CQHttp本体是用 C++ 编写的插件，将酷 Q 的回调包装成 HTTP 请求转发至指定的地址，支持http和websocket两种协议。
不过由于个人想折腾折腾的想法，打算试试把 Python 解释器直接嵌入到 C++ 里得了。
整个思路如下。
graph LR; CQP[酷Q] --事件回调--&amp;gt; dll[插件DLL]; dll --事件回调--&amp;gt; python[Python脚本]; python --调用API--&amp;gt; dll; dll --调用API--&amp;gt; CQP; 依赖 为了简化操作 Python 接口，我没有使用 Python 自带的 C API，而是pybind11，使用vcpkg管理依赖。
安装命令：
vcpkg install pybind11:x86-windows 0x1 编译 DLL 我使用 CMake 作为编译系统，因此可以很简单地写一个编译出 DLL 的 CMakeLists.txt
cmake_minimum_required(VERSION 3.15)project(top.weak-ptr.cqpy LANGUAGES CXX VERSION 0.1.0)include_directories(src)aux_source_directory(src SOURCES)set(CMAKE_CXX_STANDARD 17)# 引入 pybind11 find_package(pybind11 CONFIG REQUIRED)# 添加 target set(OUT_NAME &amp;#34;app&amp;#34;)add_library(${OUT_NAME} SHARED ${SOURCES})set_target_properties(${OUT_NAME} PROPERTIES LINKER_LANGUAGE CXX)target_link_libraries(${OUT_NAME} PRIVATE pybind11::embed)源代码使用 MSVC 和 MinGW 编译，另外再处理下源码编码的问题和宏。</description></item><item><title>Flask源码阅读笔记：WSGI</title><link>https://nnnewb.github.io/blog/p/flask%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0wsgi/</link><pubDate>Sun, 17 Mar 2019 00:00:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/flask%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0wsgi/</guid><description>0. Intro Flask 是一个基于 WSGI 协议的上层应用框架，据我了解应该是和 Tornado、Django 流行程度相近，当然 Django 老大哥始终占据了最多的份额。Flask 是一个轻量级的 Micro Framework，源码值得一读。
1. 回顾 WSGI 开始之前，需要先回顾以下 WSGI 协议。
WSGI 是一个针对 Python 的协议，故说到的 App、Server、函数、参数等描述都是指 Python 对应的概念或实现。
1.1 PEP-0333 到 PEP-3333 PEP-0333 是初版的 WSGI 协议提案，PEP-3333 是 1.0.1 版本的 WSGI 提案，差别不大，主要是对 py3 和 py2 不兼容的部分作了更新说明（str和unicode方面的问题，python2 的 str 在 python3 是 bytes，故 python3 编写的 wsgi app 必须返回 bytes）。
WSGI 协议规范了 Python Web 应用的两个层级：服务器层（Server）和应用层（Application），两者通过 WSGI 协议进行通信。
其中 Server 负责处理请求，将请求转换成符合 WSGI 要求的模式（environ参数）。 Application 完成处理后再通知 Server 返回 Response（start_response参数）。</description></item><item><title>Django 的各种关系字段详解</title><link>https://nnnewb.github.io/blog/p/django-%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3/</link><pubDate>Wed, 06 Mar 2019 21:11:35 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/django-%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3/</guid><description>参考资料如下
Django 文档 - Model field reference SQLAlchemy 中的级联删除 1. ForeignKey ForeignKey用于多对一关系，直接对应到数据库外键的概念。使用ForeignKey需要指定引用的目标表，会自动关联到目标表的主键（一般是id字段）。
例子如下。
from django.db import models class Child(models.Model): parent = models.ForeignKey(&amp;#39;Parent&amp;#39;, on_delete=models.CASCADE, ) # ... class Parent(models.Model): # ... pass 对比之 sqlalchemy，一行parent=models.ForeignKey(...)包含了 sqlalchemy 中的ForeignKey和relationship两部分内容。
1.1 参数：on_delete on_delete意为当ForeignKey引用的对象被删除时进行的操作。
有几个可以考虑的选项。
1.1.1 models.CASCADE CASCADE意为级联，on_delete设置为CASCADE时意为执行级联删除。依据文档，Django 会模仿 SQL 的ON DELETE CASCADE，对包含了ForeignKey的对象执行删除。
需要注意的是不会调用被级联删除对象上的model.delete()，但是会发送pre_delete和post_delete信号。
1.1.1.2 models.PROTECT PROTECT意为保护，on_delete设置为PROTECT意味着要阻止删除操作发生。删除关联的对象时，ForeignKey的on_delete设置为PROTECT会触发ProtectedError。
1.1.1.3 models.SET_NULL 如其名所述，如果这个ForeignKey是 nullable 的，则关联的对象删除时将外键设置为 null。
1.1.1.4 models.SET_DEFAULT 如其名所述，如果这个ForeignKey设置了DEFAULT，则关联的对象删除时设置这个外键为DEFAULT值。
1.1.1.5 models.SET 在关联的对象删除时，设置为一个指定的值。这个参数可以接受一个可以赋值给这个 ForeignKey 的对象或者一个可调用对象。
官方例子如下。</description></item><item><title>轻量级 django 阅读笔记：最小的 django 应用</title><link>https://nnnewb.github.io/blog/p/%E8%BD%BB%E9%87%8F%E7%BA%A7-django-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%9C%80%E5%B0%8F%E7%9A%84-django-%E5%BA%94%E7%94%A8/</link><pubDate>Sun, 03 Mar 2019 12:26:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E8%BD%BB%E9%87%8F%E7%BA%A7-django-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%9C%80%E5%B0%8F%E7%9A%84-django-%E5%BA%94%E7%94%A8/</guid><description>Intro 找不到工作十分难受，在家看书，恰巧翻到这本《轻量级 Django》，看起来还蛮有意思的，做个读书笔记。
1. 最小的 Django App Django 是个重量级框架，所谓最小指的是写最少的代码，理解一个 Django App 的最小组成元素。
作为开场，先创建一个 app.py 文件，作为整个 Django App 存储的地方。
1.1 django.conf.settings 书中使用 django.core.management.execute_from_command_line 作为启动 Django app 的手段。
execute_from_command_line，就是通过 django startproject的方式创建的manage.py内的主要内容，这种方式启动必须要配置settings才行。
在一个常规方式创建的 Django App 中，settings.py是一个独立的 python 模块，Django通过DJANGO_SETTINGS_MODULE这个环境变量来确定配置信息存储位置。
但是换一种方式，django.conf.settings.configure()可以手动完成配置。
看代码。
from django.conf import settings settings.configure(DEBUG=True, ROOT_URLCONF=__name__, ) 每一个 keyword argument 都和 settings.py这个模块内的名字相同，去除所有不必要的元素之后，剩下的就是DEBUG和ROOT_URLCONF了。
阅读源码可知configure只能被调用一次。
# 摘自 django.conf.settings.configure 源码 # Django 版本号: # VERSION = (2, 1, 7, &amp;#39;final&amp;#39;, 0) def configure(self, default_settings=global_settings, **options): &amp;#34;&amp;#34;&amp;#34; Called to manually configure the settings.</description></item><item><title>sqlalchemy 各种表关系</title><link>https://nnnewb.github.io/blog/p/sqlalchemy-%E5%90%84%E7%A7%8D%E8%A1%A8%E5%85%B3%E7%B3%BB/</link><pubDate>Fri, 01 Mar 2019 15:52:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/sqlalchemy-%E5%90%84%E7%A7%8D%E8%A1%A8%E5%85%B3%E7%B3%BB/</guid><description>注意事项 ForeignKey db.ForeginKey的参数是&amp;lt;表名&amp;gt;.&amp;lt;键名&amp;gt;，而不是&amp;lt;类名&amp;gt;.&amp;lt;字段名&amp;gt;，务必注意这个区别。
back_populates 和 backref 在多对多关系中使用的区别 back_populates是更推荐的写法。
多对多关系中使用backref并指定了secondary的话，另一张表关联的relationship字段会使用相同的secondary。
back_populates则需要在两张表的relationship中都写上相同的secondary中间表。
可调用的 secondary secondary参数可以是一个可调用对象，做一些 trick 的时候应该有用。姑且记下。
一对多关系 class Parent(Base): __tablename__ = &amp;#39;parent&amp;#39; id = Column(Integer, primary_key=True) child = relationship(&amp;#34;Child&amp;#34;, back_populates=&amp;#34;parent&amp;#34;) class Child(Base): __tablename__ = &amp;#39;child&amp;#39; id = Column(Integer, primary_key=True) parent_id = Column(Integer, ForeignKey(&amp;#39;parent.id&amp;#39;)) parent = relationship(&amp;#34;Parent&amp;#34;, back_populates=&amp;#34;child&amp;#34;) parent包含多个child的一对多关系。child里写ForeignKey为parent的主键，child里写relationship，parent里同样写relationship，back_populates填充上，完事。
一对一关系 class Parent(Base): __tablename__ = &amp;#39;parent&amp;#39; id = Column(Integer, primary_key=True) child = relationship(&amp;#34;Child&amp;#34;, uselist=False, back_populates=&amp;#34;parent&amp;#34;) class Child(Base): __tablename__ = &amp;#39;child&amp;#39; id = Column(Integer, primary_key=True) parent_id = Column(Integer, ForeignKey(&amp;#39;parent.</description></item><item><title>利用 descriptor 实现自己的 property</title><link>https://nnnewb.github.io/blog/p/%E5%88%A9%E7%94%A8-descriptor-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84-property/</link><pubDate>Thu, 21 Feb 2019 17:53:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E5%88%A9%E7%94%A8-descriptor-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84-property/</guid><description>1.概念简介 1.1 property 在 python 代码中，property 是非常常见的一个内置函数。property 可以为一个 python 类的 attribute 设置 getter/setter，可以类比之 C# 的 properties。
见下面的例子。
class A: def __init__(self): self.a = 1 @property() def hello(self): return self.a @hello.setter() def hell(self, value): self.a = value print(A().hello) # output: # 1 obj = A() obj.hello = &amp;#34;hello world&amp;#34; print(obj.hello) # output: # hello world 1.2 descriptor python 中的 descriptor 指的是实现了__get__、__set__、__delete__三个方法之一的类。
当一个 descriptor 类的实例作为其他类的成员时，通过obj.attr语法访问该实例将会调用 descriptor 实例的__get__方法。同理，__set__和__delete__也是相似的逻辑。
先看个例子。
class DescriptorClass: def __get__(self, instance, owner): print(self) print(instance) print(owner) return &amp;#39;some value&amp;#39; class SomeClass: some_attr = DescriptorClass() print(SomeClass().</description></item><item><title>python3元类深入解读</title><link>https://nnnewb.github.io/blog/p/python3%E5%85%83%E7%B1%BB%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB/</link><pubDate>Thu, 20 Dec 2018 19:46:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/python3%E5%85%83%E7%B1%BB%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB/</guid><description>0. intro 元类是 python 里被说烂了的一个东西，然而日常用到的地方实在不多，每次想到都得查一下谷歌，想想干脆在博客留个笔记好了。
元类的主要用途是定制类的产生过程，以便于根据类声明包含的信息来创建出不同的类。
1. type 提到元类不得不说一下 python 的类型系统。
python 的 class 也被视作一个对象，定制一个 class 的构造过程其实就和平时在 class 定义里写__init__没啥区别。
python3 里类的类型是type，type又继承自object，object的父类是自己，构成一个奇怪的闭环。其中，type本身是一个特殊的类，他是自己的实例。
graph TB; type --&amp;gt; |inherite|object; type --&amp;gt; |instance-of| type; object --&amp;gt; |instance-of|type; other-cls --&amp;gt; |instance-of| type; other-cls --&amp;gt; |inherite| object; other-cls-instance --&amp;gt; |instance-of|other-cls; type有两种调用方式，一种是最常用的接受一个对象参数，返回该对象的类型，另一种是不怎么常用的，直接创建一个新的类型。
# usage with one argument type(object) # 返回对象的类型，这里返回的是 `type` # usage with three arguments type(name, bases, attr) # 返回新创建的类型 2. meta class 元类语法如下
class MyClass(basecls1, basecls2, metaclass=MetaClass, named1=arg, named2=arg): .</description></item><item><title>python 实现 redis 分布式锁</title><link>https://nnnewb.github.io/blog/p/python-%E5%AE%9E%E7%8E%B0-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link><pubDate>Mon, 17 Dec 2018 14:57:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/python-%E5%AE%9E%E7%8E%B0-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid><description>Intro 分布式不是啥黑魔法，究其理念无非是用多台服务器处理更多的请求。提高每秒处理的数据量，并发就不可避免了。
在单机并发的情况下，我们可以用 mutex，可以用 os 的文件锁，全局锁，多台服务器的并发就需要另一个持有并保护锁的角色了。
概述如何使用 redis 实现一个分布式锁。
为何是 Lua redis 保证了 lua 解释器执行脚本的事务性，即执行结果要么不可见，要么已完成。
参考这篇文档。
简单锁 简单锁指的是简单互斥锁，一旦锁定，则其他锁定请求都必须等待。
加锁 直觉的想法是通过 redis 的键来保持锁，故准备一个用于锁定互斥的名字（比如说 mutex-1）然后指定为键。
直接使用 set 是显然不正确的，如果临界区内程序崩溃或意外断网将导致死锁，所以 setnx 和 expire 是必选项。
加锁需要判断锁的键为空，才能加锁，这两步必须保证原子性，要么都执行，要么一个都不执行。幸好 redis 提供了这方面保证，只要使用 lua 脚本的话。
-- 加锁 if redis.call(&amp;#34;get&amp;#34;, KEYS[1]) == nil then if redis.call(&amp;#34;setnx&amp;#34;, KEYS[1], ARGV[1]) == 1 then redis.call(&amp;#34;expire&amp;#34;, KEYS[1], ARGV[2]) return 1 else return end end 上面的 lua 代码用 python 再封装一层，就是这样
def lock(key, expire): redis.eval( &amp;#39;&amp;#39;&amp;#39; -- 加锁 if redis.</description></item><item><title>unity3d 键盘控制移动</title><link>https://nnnewb.github.io/blog/p/unity3d-%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E7%A7%BB%E5%8A%A8/</link><pubDate>Mon, 17 Dec 2018 02:29:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/unity3d-%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E7%A7%BB%E5%8A%A8/</guid><description>void HandleKeyboardAction() { var horizontal = Input.GetAxis(&amp;#34;Horizontal&amp;#34;) * PlayerMotionScaleLevel * Time.deltaTime; var vertical = Input.GetAxis(&amp;#34;Vertical&amp;#34;) * PlayerMotionScaleLevel * Time.deltaTime; var motion = transform.rotation * new Vector3(horizontal, 0, vertical); var mag = motion.magnitude; motion.y = 0; Player.transform.position += motion.normalized * mag; } 极其简单的做法，获取到键盘移动的轴之后，用摄像机的旋转四元数乘一下，即可得到旋转后的向量，加上去就 ok 了。
需要注意的是这里用摄像机的四元数旋转要求摄像机必须只在 x 和 y 两个轴旋转。
先备份一下三维向量的数量值，这是为了能保证摄像机向上和向下看时，平面 x 和 z 轴上的分量不会过小，保持一致的移动速度。
用四元数旋转完成后，去除 y 轴的值，使目标只在当前平面上移动。再用算出来的向量的单位向量乘上之前备份的数量值，得到平面上移动的偏移向量。
最后，算出新的位置坐标。</description></item><item><title>go语言实战之解密ons脚本</title><link>https://nnnewb.github.io/blog/p/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E4%B9%8B%E8%A7%A3%E5%AF%86ons%E8%84%9A%E6%9C%AC/</link><pubDate>Sun, 16 Dec 2018 23:44:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E4%B9%8B%E8%A7%A3%E5%AF%86ons%E8%84%9A%E6%9C%AC/</guid><description>Intro ons 是一个开放源代码的视觉小说引擎，以简单实用出名。本博用 golang 来解密 ons 引擎的.dat和.nt2脚本，主要实践目标是异步解密输出。
算法 .dat的加密非常简单，一次异或。密码是0x84。
可以用 go 非常简单粗暴地写出以下代码。
for i := 0; i &amp;lt; len(buf); i++ { buf[i] ^= 0x84 } .nt2的加密同样简单，一次异或，密码是0x85 &amp;amp; 0x97。
可以用 go 非常粗暴地写出以下代码。
for i := 0; i &amp;lt; len(buf); i++ { buf[i] = (buf[i] ^ (0x85 &amp;amp; 0x97)) - 1 } 异步读文件 go 方式比较多，ioutil或者bufio或者os都有文件模块。这里采用bufio套os.Open的方式读文件。
func readFile(p string, outChannel chan []byte) { // 只读方式打开文件 file, err := os.OpenFile(p, os.O_RDONLY, 0644) if err !</description></item><item><title>关于笔记的考虑</title><link>https://nnnewb.github.io/blog/p/%E5%85%B3%E4%BA%8E%E7%AC%94%E8%AE%B0%E7%9A%84%E8%80%83%E8%99%91/</link><pubDate>Sun, 16 Dec 2018 23:30:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E5%85%B3%E4%BA%8E%E7%AC%94%E8%AE%B0%E7%9A%84%E8%80%83%E8%99%91/</guid><description>使用了两年多的 One Note，但是 One Note 对代码的支持实在是难受，于是数次折腾之后最终还是选择再找个更合适的笔记工具。
在知乎上搜了一圈之后，大多数笔记工具收费且不论，最严重的问题反而是对笔记能否生存下去的怀疑。
大多笔记工具用私有格式来处理富文本（比如可用样式排版有限的 HTML），或者其他奇奇怪怪的格式。且不说这些东西导出来怎么办&amp;hellip;..把笔记多地备份本身就够难受了。
再者，笔记这玩意儿记了自己都不一定看。偶尔想起来翻一下，还要怀疑自己当初写的什么狗屁玩意儿。
所以经过这么多考虑&amp;hellip;&amp;hellip;还是直接搭个博客最自由且不会太担心保存的问题了。
比较别的笔记工具可能密码忘了或长时间不登陆，git 天天用（这里应有自嘲），根本离不开。
所以想了想，还是转移笔记到博客好了。写笔记可能很随便，写博客总要考据两下的。再说，还可以自定义页面效果，对我这种喜欢折腾的人还是蛮对胃口的。
总而言之，先挂上去了，就这样。</description></item><item><title>AudioContext 技术和音乐可视化（2）</title><link>https://nnnewb.github.io/blog/p/audiocontext-%E6%8A%80%E6%9C%AF%E5%92%8C%E9%9F%B3%E4%B9%90%E5%8F%AF%E8%A7%86%E5%8C%962/</link><pubDate>Thu, 08 Nov 2018 21:41:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/audiocontext-%E6%8A%80%E6%9C%AF%E5%92%8C%E9%9F%B3%E4%B9%90%E5%8F%AF%E8%A7%86%E5%8C%962/</guid><description>Intro 转载请注明来源，可以在测试博客查看完成效果。
本篇讲述如何从频域数据绘制动态的星空。
一、使用 Canvas 绘图 1.1 位置和大小 绘制背景的第一要务便是把 canvas 元素放置在背景这一层次上，避免遮盖其他元素。
对我而言，个人习惯用 css 来设置大小和位置，用 html 来确定渲染顺序而不是 z-index。
下面是 html 代码。
&amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;canvas id=&amp;#34;background-canvas&amp;#34;&amp;gt;&amp;lt;/canvas&amp;gt; &amp;lt;!-- other elements --&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 下面是 css 代码。
#background-canvas { position: fixed; left: 0; top: 0; width: 100vw; height: 100vh; background-color: black; } fixed确保拖动页面不会令背景也跟随移动。
其余部分我想应该没什么有疑问的地方。
1.2 CanvasContext2D 对于 canvas 元素的绘图操作我想很多人应该接触过。
以绘制圆形为例，使用如下代码。
const canvas = document.getElementById(&amp;#34;background-canvas&amp;#34;); const ctx = canvas.getContext(&amp;#34;2d&amp;#34;); ctx.fillStyle = &amp;#34;#fff&amp;#34;; ctx.beginPath(); ctx.arc(100, 100, 50, 0, Math.</description></item><item><title>AudioContext技术和音乐可视化（1）</title><link>https://nnnewb.github.io/blog/p/audiocontext%E6%8A%80%E6%9C%AF%E5%92%8C%E9%9F%B3%E4%B9%90%E5%8F%AF%E8%A7%86%E5%8C%961/</link><pubDate>Wed, 07 Nov 2018 02:48:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/audiocontext%E6%8A%80%E6%9C%AF%E5%92%8C%E9%9F%B3%E4%B9%90%E5%8F%AF%E8%A7%86%E5%8C%961/</guid><description>Intro 因为自己搭了个博客，一时兴起，就想写个动态的博客背景。毕竟用 django 后端渲染，前端只有 jquery 和 bootstrap 已经够 low 了，虽说极简风格也很棒，但是多少有点亮眼的东西才好办不是吗。
转载注明来源。
为了方便讲解，整个思路分为两个部分：音乐播放和背景绘制。
一、音乐播放 1.1 AudioContext 概述部分懒得自己写，参考 MDN 的描述。
AudioContext接口表示由音频模块连接而成的音频处理图，每个模块对应一个AudioNode。AudioContext可以控制它所包含的节点的创建，以及音频处理、解码操作的执行。做任何事情之前都要先创建AudioContext对象，因为一切都发生在这个环境之中。
1.2 浏览器支持状况 AudioContext标准目前还是草案，不过新 chrome 已经实现了。我使用的 chrome 版本如下。
版本 70.0.3538.77（正式版本） （64 位） 如果发现 console 报错或者其他问题请检查浏览器版本，所有支持的浏览器可以在这个链接查看。
1.3 AudioContext 和音频处理图 关于AudioContext我的了解不是很深入，所以只在需要用到的部分进行概述。
首先，关于音频处理图的概念。
这个名词不甚直观，我用过虚幻，所以用虚幻的Blueprint来类比理解。音频处理图，其实是一系列音频处理的模块，连接构成一张数据结构中的“图”，从一般使用的角度来讲，一个播放音频的图，就是AudioSource -&amp;gt; AudioContext.destination，两个节点构成的图。其中有很多特殊的节点可以对音频进行处理，比如音频增益节点GainNode。
对于音频处理的部分介绍就到这里为止，毕竟真的了解不多，不过从 MDN 的文档看，可用的处理节点还是非常多的，就等标准制订完成了。
1.4 加载音频文件并播放 音频文件加载使用典型的JavaScript接口FileReader实现。
一个非常简单的实例是这样
首先是 html 里写上 input
&amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;input type=&amp;#34;file&amp;#34; accept=&amp;#34;audio/*&amp;#34; onchange=&amp;#34;onInputChange&amp;#34; /&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 然后在 javascript 里读文件内容。
function onInputChange(files) { const reader = new FileReader(); reader.</description></item><item><title>Unity3D 键盘控制物体平面移动（操作相对于摄像机方向）</title><link>https://nnnewb.github.io/blog/p/unity3d-%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E7%89%A9%E4%BD%93%E5%B9%B3%E9%9D%A2%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%AF%B9%E4%BA%8E%E6%91%84%E5%83%8F%E6%9C%BA%E6%96%B9%E5%90%91/</link><pubDate>Sat, 03 Nov 2018 18:57:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/unity3d-%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E7%89%A9%E4%BD%93%E5%B9%B3%E9%9D%A2%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%AF%B9%E4%BA%8E%E6%91%84%E5%83%8F%E6%9C%BA%E6%96%B9%E5%90%91/</guid><description>Intro 目标是实现目标随摄像机方向的不同而进行不同方向移动——而且，目标不需要随摄像机一起旋转。
使用摄像机的四元数旋转 void HandleKeyboardAction() { var horizontal = Input.GetAxis(&amp;#34;Horizontal&amp;#34;) * PlayerMotionScaleLevel * Time.deltaTime; var vertical = Input.GetAxis(&amp;#34;Vertical&amp;#34;) * PlayerMotionScaleLevel * Time.deltaTime; var motion = transform.rotation * new Vector3(horizontal, 0, vertical); var mag = motion.magnitude; motion.y = 0; Player.transform.position += motion.normalized * mag; } 极其简单的做法，获取到键盘移动的轴之后，用摄像机的旋转四元数乘一下，即可得到旋转后的向量，加上去就 ok 了。
需要注意的是这里用摄像机的四元数旋转要求摄像机必须只在 x 和 y 两个轴旋转。
先备份一下三维向量的数量值，这是为了能保证摄像机向上和向下看时，平面 x 和 z 轴上的分量不会过小，保持一致的移动速度。
用四元数旋转完成后，去除 y 轴的值，使目标只在当前平面上移动。再用算出来的向量的单位向量乘上之前备份的数量值，得到平面上移动的偏移向量。
最后，算出新的位置坐标，赋值，完事儿。</description></item><item><title>Unity3d 摄像机跟随旋转的方案</title><link>https://nnnewb.github.io/blog/p/unity3d-%E6%91%84%E5%83%8F%E6%9C%BA%E8%B7%9F%E9%9A%8F%E6%97%8B%E8%BD%AC%E7%9A%84%E6%96%B9%E6%A1%88/</link><pubDate>Sat, 03 Nov 2018 18:20:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/unity3d-%E6%91%84%E5%83%8F%E6%9C%BA%E8%B7%9F%E9%9A%8F%E6%97%8B%E8%BD%AC%E7%9A%84%E6%96%B9%E6%A1%88/</guid><description>Intro 主要想探讨的是如何令摄像机随鼠标操作进行旋转和移动，摄像机跟随的脚本官方就有 Example。
方案：独立的角度变量 主要的特点是使用独立的角度变量，每次处理鼠标移动操作都会创建一个新的Quaternion用于计算。
先看 Demo。
public class PlayerControls : MonoBehaviour { public GameObject Player; public float Distance; //public float CameraRepositionSpeed; public float MouseMotionScaleLevel; public bool ReverseAxisY; public float PitchMaximum; public float PitchMinimum; private float _CurrentCameraAngleAroundX; private float _CurrentCameraAngleAroundY; private Vector3 _PositionTarget; // Use this for initialization void Start() { } // Update is called once per frame void Update() { _CurrentCameraAngleAroundX += Input.GetAxis(&amp;#34;Mouse Y&amp;#34;) * MouseMotionScaleLevel * Time.</description></item><item><title>GameHollywood 面试笔记</title><link>https://nnnewb.github.io/blog/p/gamehollywood-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</link><pubDate>Tue, 26 Jun 2018 17:22:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/gamehollywood-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</guid><description>Intro 面试的职位是 C++后端开发工程师，主要聊的还是 C++。在过程中自我感觉面得还行，至少没上次那么蠢。
聊的内容主要集中在 STL 和线程安全、资源管理的层面。
惯例的，填完面试信息表并简历一起上交，然后等面试官来客套完，就开始聊技术了。
注意，面试官的提问并非原话，有修饰和脑补。
0. 预热：你用哪个版本的 C++？ 客套话什么的就略了。
面试官：&amp;hellip;行，那我们就聊聊 C++吧。你常用哪个版本的 C++？
我：我比较常用的是 C++11。
C++版本这个问题面试里应该不多见，不过作为引入的话题还行，标准之神会瞑目的。
对于C++版本这个词，很大概率上大家说的应该就是 C++标准委员会WG21制定的 C++标准了，最新版本的标准文档是 C++17 定稿N4659，制定中的 C++20 标准文档可以访问WG21/docs/papers/2018查阅。
需要注意的是，如果答成了我用 VC6之类的骚话，很大概率会留下不好的映像——或者对方也是忠实的 VC6 神教教徒的话，达成共识也说不定。
闲话少叙。
1. 起手式：std::shared_ptr 面试官：说说std::shared_ptr是怎么实现的？一般怎么去使用它？
答：shared_ptr是通过引用计数实现的，它可以作为容器元素，在程序里传递 blabal&amp;hellip;..而且shared_ptr不是线程安全的，它不能跨线程传递，要额外做一层包装 blabla&amp;hellip;&amp;hellip;
正巧最近有想写一篇智能指针相关的博客，面试官的第一问就提到了。
说到智能指针，就必须提一下 RAII 了。
1.1 异常安全和 RAII std::shared_ptr和其他智能指针类型都在&amp;lt;memory&amp;gt;头文件里定义，主要的作用是实现自动化的资源管理，基于RAII的理念设计和实现。
RAII指的是获取资源即初始化，英文全写是Resource Acquisition Is Initialization，属于一种面向对象编程语言中常见的惯用法。
它的思路是这样子的：初始化即获取资源，离开作用域就自动销毁。
RAII 解决的问题是，当异常发生时，如何确保资源释放。这是个异常安全的问题。
常见的非 RAII 风格代码里，如果要确保资源被正确释放，就要用try {} catch() {} finally {}块捕获异常，然后执行资源释放的代码，再将异常重新抛出。</description></item><item><title>可重入和异步安全</title><link>https://nnnewb.github.io/blog/p/%E5%8F%AF%E9%87%8D%E5%85%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E5%AE%89%E5%85%A8/</link><pubDate>Sun, 24 Jun 2018 22:48:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E5%8F%AF%E9%87%8D%E5%85%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E5%AE%89%E5%85%A8/</guid><description>这篇博客主要记录的是关于可重入性的相关定义，以及关于并发安全的思考。
可重入性 在不同语言中，由于语言标准以及运行期环境规定的不同，可重入性的具体定义可能有所不同。这里聊的是 C++语言中的可重入性。
所谓可重入性（reetrant），指的是同时具备并发安全和中断安全的特征，这是目前为止我对可重入性的认识，也是这篇博客在写下时给可重入性下的定义。
这个认知可能并不准确，因为在wiki上的定义是这样的。
若一个程序或子程序可以「在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错」，则称其为可重入（reentrant 或 re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合設計時預期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。
但是在很多中文博客里，聊到可重入性的时候往往也会把并发安全混为一谈。实际上来说的话&amp;hellip;&amp;hellip;一个可重入的函数，常常也是并发安全的。
那么先从并发安全讲起吧。
并发安全性和可重入性 所谓并发安全已经是老生常谈了。
以一段非常简单的代码为例，我们打算初始化一个对象，这个对象被两个线程共享。
void initialize(Something** someshit) { if(!*someshit) { *someshit = createSomeShit(); } } 显而易见，如果线程在执行到特定环节时发生了切换
void initialize(Something** someshit) { if(!*someshit) { // &amp;lt;-------- 线程切换 // 线程2() { // initialize(something); // } // 线程切换 ---------&amp;gt; *someshit = createSomeShit(); } } 那么 createSomeShit这段代码就会被执行两次。
显然这和我们预期的行为不符。
这里要聊的不是并发，而是&amp;hellip;&amp;hellip;可重入性。所以我们再看看这个函数能否被重入。
按照 wiki 提供的定义，函数可重入指的是
在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错。
符合吗？不。为什么？因为同样在那个线程切换的位置上中断，然后再另一段代码里再次执行这个函数，也会触发同样的问题，导致createSomeShit被执行两次。
void initialize(Something** someshit) { if(!</description></item><item><title>MySQL 24小时入门笔记 - 4</title><link>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-4/</link><pubDate>Sat, 23 Jun 2018 22:34:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-4/</guid><description>创建表 CREATE TABLE CREATE TABLE的作用是创建表。不多说，先创建个简单的学生表。
CREATETABLEstudents(idint,namechar(16)NOTNULL,primarykey(id));这里没写 ENGINE=InnoDB，因为这是新 MariaDB 的默认值。
那么进入正题，CREATE TABLE的语法如下。
CREATETABLE[表名]([列名][类型][约束和其他属性],[列名][类型][约束和其他属性],....[其他表配置]);很容易看出，括号里面写的是表的相关配置，包括列定义，主键定义，索引定义等等。
默认值 在创建表时可以指定默认值，有默认值的列在插入时可以不填。
语法如下。
CREATETABLE[表]([列][类型]DEFAULT[值],);即可为一个列设定默认值。
非空 非空约束非常常见。比如说，我们要记录学生信息，包括学号、成绩、姓名，那么学生姓名能不能留空呢？显然不行，因为没有姓名的记录让谁看都是一脸懵逼，这破坏了一条记录的完整性。
创建非空约束的语法如下。
CREATETABLE[表]([列][类型]NOTNULL,);这就创建了非空约束。非空约束下，插入数据时不能不填写这个列。
如果需要要求可空，那么这样做。但一般不用特地写，很多DBMS的列默认创建就是可空的。
CREATETABLE[表]([列][类型]NULL,);修改表 ALTER TABLE ALTER TABLE可以修改表定义，添加删除列，修改约束，等等。
添加列 举例，在一个只有学号和姓名两个列的学生表加入一个新的成绩列，代码如下。
ALTERTABLEstudentsADDscoreint;语法基本是这样。
ALTERTABLE[表名]ADD[列名][类型][其他属性和约束];后面列的定义写法基本和CREATE TABLE时差不多。
删除列 和添加列差不多，但删除的关键字不是DELETE，而是DROP。
ALTERTABLE[表名]DROP[列名];添加外键约束 外键约束其实保证的是引用完整性，外键约束的列的值必须引用了一个有效的行，或者是NULL。
举例来说，我们先有两个表。
学生表
id name class 1 student 1 1 2 student 2 2 3 student 3 3 班级表
id level 1 Lv5 2 Lv4 3 Lv3 为了让学生表的class关联到班级表的id，我们要这样做。</description></item><item><title>MySQL 24小时入门笔记 - 3</title><link>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-3/</link><pubDate>Sat, 23 Jun 2018 21:51:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-3/</guid><description>插入 INSERT INSERT用法非常简单。现在我们有表students如下。
列名 类型 约束 id int primary key name char(16) NOT NULL 向里面插入一条学号为1，姓名为学姐的学生，只需要写如下SQL语句。
INSERTINTOstudentsVALUES(1,&amp;#39;学姐&amp;#39;);语法
INSERTINTO[表]VALUES(列值1,列值2,...);其中INSERT语句有一个简单的变体，能比较明确地指明将值交付给哪个列。
INSERTINTOstudents(id,name)VALUES(1,&amp;#39;学妹&amp;#39;);这样写相当于指明了1应该是id，'学妹'应该是name。
插入多条也很简单，只要在VALUES后面跟更多小括号包围的值集合就行了，记得拿括号分隔，下面给个例子。
INSERTINTOstudents(id,name)VALUES(1,&amp;#39;学渣&amp;#39;),(2,&amp;#39;学霸&amp;#39;),(3,&amp;#39;学神&amp;#39;);INSERT SELECT 这个写法比较有意思，从一个表查询出数据，并插入另一个表。
举个例子来说，我们有两个班级表，分别叫学渣班和补习班，一旦学渣成绩烂到一定程度，那么我们就要把他分配到补习班里去强制补习。
怎么做呢？看下面啦。
INSERTINTO补习班(name,score)SELECT学渣班.name,学渣班.scoreFROM学渣班WHERE学渣班.score&amp;lt;10;值得注意的是，INSERT 填充补习班表时用的并不是你SELECT的列名，而是SELECT后列名的顺序，来对应到要INSERT的表的列上。
其他的写法和SELECT相同。
修改 UPDATE UPDATE语句的作用是修改现存行的数据，非常值得注意的是用UPDATE语句时一定要小心写WHERE子句，不然就等着删库跑路吧。
依然举个实际栗子，学号为10的学生成绩由于作弊而被取消了，我们要更新他的成绩为 0 分，这真是个悲伤的故事:P
UPDATEstudentsSETscore=0WHEREid=10;语法是这样的。
UPDATE[表名]SET[列名]=[新值]WHERE[条件];更新多条的话是这样的
UPDATE[表名]SET[列1]=[新值],[列2]=[新值],...[列N]=[新值]WHERE[条件]; 千万小心，如果没有 WHERE子句的话，指定的列会全部被设置成这个值。这样一来，所有的学生都变成了 0 分&amp;hellip;&amp;hellip;你会被手撕了的。
删除 DELETE DELETE的作用是删除行，同样的，万分注意WHERE子句一定要正确编写，不然真的要删库跑路了。
同样以之前那位作弊的同学为例，很遗憾，他又一次作弊被抓住了，传说中的高科技 AR 技术作弊眼镜也没能让他逃过监考员的火眼金睛，于是他被退学了&amp;hellip;&amp;hellip;
另一个悲伤的故事:P
DELETEFROMstudentsWHEREid=10;语法是这样子的。
DELETEFROM[表名]WHERE[条件];如果不写WHERE的话&amp;hellip;&amp;hellip;找个好点的新工作吧，不要再去写SQL了，ORM 多好。
注意，不写WHERE子句会删除这个表里的所有行。</description></item><item><title>MySQL 24小时入门笔记 - 2</title><link>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/</link><pubDate>Sat, 23 Jun 2018 15:41:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/</guid><description>查询 SELECT SELECT是一个特殊的关键字，它的语义是查询，取出结果。
注意：仅为个人理解。
FROM FROM子句，标识要查询的对象的来源，来源可能是多个的。在查询有多个来源表的情况下，称之为联结查询（Join query）。
最常见的常规写法是SELECT column FROM table，表示从特定表取出所有行的特定列。
WHERE WHERE子句用于过滤查询的行，只有满足条件的行会被查询出来。
常见的用法有SELECT column FROM table WHERE column &amp;lt;&amp;gt; 0，表示在table表中查询column非空的行，返回这些行的column。
其中的二元关系运算符&amp;lt;&amp;gt;表示不等于，其他常见的关系运算符还有这些。
运算符 含义 = 相等 &amp;gt; 大于 &amp;lt; 小于 &amp;gt;= 大于等于 &amp;lt;= 小于等于 != 不等于 &amp;lt;&amp;gt; 不等于 此外还有一些SQL关键字可以辅助编写判断逻辑。
SQL关键字IN可以用于判断元素是否在集合中。举例，SELECT 1 IN (1,2,3)，查询1是否在1,2,3这个集合中。被判断的集合需要被小括号包围，并且以逗号分隔元素。
SQL关键字BETWEEN可以判断元素是否在一定区间中。举例，SELECT 1 BETWEEN 0 and 10，查询1是否在0到10的区间内。语法是BETWEEN [low] AND [high]，区间较小的一端必须在左侧，较大的一端必须在右侧。</description></item><item><title>MySQL 24小时入门笔记 - 1</title><link>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-1/</link><pubDate>Sat, 23 Jun 2018 02:24:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-1/</guid><description>1. 数据库概念 1.1 数据和储存 数据库本质上做的工作是储存和查询数据。理论上而言，MySQL应该叫做DBMS，也就是数据库管理系统，而不是数据库。
DBMS提供了统一的建立、使用、管理数据库的接口，常见的DBMS有postgreSQL、MariaDB、SQL Server等。
1.2 数据库和Schema 通常来说，一个DBMS会支持多个数据库共存。这里所说的数据库指的是特定数据库管理系统管理下的数据库，而不是上一节说的DBMS。
而Schema的中译术语一般叫模式，Schema描述了数据库的结构，比如说有哪些表，表有哪些字段，字段分别有哪些限制，有哪些声明了的函数，等等。
通常的DBMS往往是这样的结构：位于DBMS管理最顶层的是一个或多个数据库，数据库里存放表，表里以行为单位存放数据。
1.3 表、列、键、行 1.3.1 表 表的英语术语是Table。
用过 Excl 吗？
id name 1 Mike 2 John 直观的表就是一个二维的“表”，有行，有列。
1.3.2 列 列的术语是 Column。
每个列都应该有一个特定的类型（type），使该列仅仅储存指定类型的数据。
1.3.3 键&amp;hellip;&amp;hellip;或者叫码 键的术语是 Key。
通常指的是Primary Key，也就是主键。主键可以是任意一个列。但是如果列是主键，那么这个列必须每个行都保证不和其他行重复。
主键也可以是多个列，如果是多个列，那么必须保证这些列的组合不重复。
举例来说
db table id name aa aaaaa 11 xxxx aa bbbbb 11 xxxx 其中db和table还有id都是主键，只要保证没有两个行同时存在相同的db/table/id就算是满足了主键约束。</description></item><item><title>鲸鱼游戏面试笔记</title><link>https://nnnewb.github.io/blog/p/%E9%B2%B8%E9%B1%BC%E6%B8%B8%E6%88%8F%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</link><pubDate>Wed, 20 Jun 2018 19:15:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E9%B2%B8%E9%B1%BC%E6%B8%B8%E6%88%8F%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</guid><description>Intro 简单介绍下面试的前置情况。
面试的公司是鲸鱼游戏，职位是后端开发工程师，开发语言 C++。
这篇博文主要是为了记录面试中发现的自身不足。
这次面试里，因为面试约得比较匆忙，所以基本没做任何准备。讲道理的说我是有点盲目自信了，毕竟 C/C++是我的第一语言来着，本来以为考察语言的部分不会有什么问题，但没想到因为紧张而错漏百出。
那么接下来就直接进入正题，以下是对面试中遇到的问题重新思考后的回答和想法。
下面面试官的提问并非原话，有经过脑补润色。
起手式：面向对象 面试官：讲讲面向对象，继承，还有多态。我们都知道程序设计有两种常见的范式，面向过程和面向对象，讲讲面向对象给我们带来了什么好处？
实话说第一问就已经有点出乎意料，但想想其实还是在意料之中。初级职位更注重于基础概念和技能，中高级职位可能会在数据结构和并发一类的问题上更深入。
答：抽象，归类 blabla&amp;hellip;易于维护 blabla&amp;hellip;
全错。
现在回忆起来，面试官想问的其实只有一点，就是那句封装。
封装是面向对象的核心概念之一。
封装使代码成为一个黑箱，让我们不必关注它的实现，而是关注它的行为和接口。
这产生了面向接口编程的概念，我们不再关注封装后的对象内部的逻辑，我们给封装后的对象以输入，然后从封装后的对象里取出数据。
封装并不只是一系列接口的集合，更包含了数据和状态，它就是一个微型化的服务，调用者告诉它去做什么事，而不关心它怎么做。
第二招：继承 面试官：讲讲继承。
我：代码复用，blabla&amp;hellip;&amp;hellip;
代码复用，这是核心。
代码复用是继承最主要的作用，大家都知道。面试官并没有在这方面继续深入，所以能答出代码复用其实已经差不多了。
除非再抠上语言相关的语法细节：多继承和单继承。
多继承 C++ 采用了多继承模型，即一个子类可以有多个父类。
Father ------| |====&amp;gt; child Mother ------| 多继承可以允许一些特殊的编程范式。比如说mixin模式。但是多继承也存在其固有的复杂性，主要表现在运行时多态上。
举几个多继承上常见的问题。
父类成员冲突 典型场景如下
class ParentA { public: void func(){} }; class ParentB { public: void func(){} }; class Child: public ParentA,ParentB {}; int main() { Child c; c.</description></item></channel></rss>