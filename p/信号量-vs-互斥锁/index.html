<!doctype html><html lang=zh-cn>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="看 go-patterns/semaphore.md at master · tmrts/go-patterns (github.com) 时产生了疑问，信号量为啥长得和互斥锁没啥区别呢。于是就谷歌了一圈，重温下一些关于并发的知识，对比信号量 semaphore 和互斥锁 mutex 。
互斥锁 mutex 以 pthread 自带的互斥锁为例，提供了三种不同类型的互斥锁：
 PTHREAD_MUTEX_NORMAL ，普通的互斥锁，不支持死锁检测（does not detect deadlock），不支持递归加锁（relock without first unlocking it 会导致死锁），不检测解锁线程，解锁一个未加锁的互斥锁是未定义行为（undefined behavior）。 PTHREAD_MUTEX_ERRORCHECK，带错误检查的互斥锁，不支持递归加锁（会返回错误），解锁其他线程的互斥锁会返回错误，解锁未加锁的互斥锁会返回错误。 PTHREAD_MUTEX_RECURSIVE，递归加锁（relock with out unlocking it）会成功，解锁时需要调用解锁的次数和加锁时调用加锁的次数相同。解锁其他线程的互斥锁会返回错误。解锁未加锁的互斥锁会返回错误。 PTHREAD_MUTEX_DEFAULT，默认互斥锁类型，对这一类型的互斥锁递归加锁时行为是未定义的，解锁未加锁的互斥锁行为是未定义的，解锁其他线程的互斥锁行为是未定义的。这一类型的互斥锁通常映射为另外几种互斥锁之一。  可以比较清楚地看出，互斥锁有三个基本特征：
 是否可重复加锁 是否可解锁未加锁的互斥锁 是否可解锁被其他人加锁的互斥锁  最严格的 PTHREAD_MUTEX_ERRORCHECK 类型互斥锁，对此定义是 NO、NO、NO 。
互斥锁的基本使用方式和使用场景有点像厕所的坑位：
 抢坑位，锁门 你懂的 解锁，出门  其中有隐含的信息包括：
 坑位是提前选择好的，你只能抢一个坑位，不能抢多个坑位。 坑位在使用期间是独占的，你不能和别人分享一个坑位。 只有你自己能解锁坑位，谁也不想办事儿的时候有人闯进来吧？  而递归加锁这一特殊场景，我寻思吧，有点难拿坑位比喻。反正也不重要，就别管了。
信号量 semaphore 信号量本质上是一个整型值，不细分什么类型了。还是用 pthread 举例吧，依据 POSIX 标准。
对信号量的操作可以先简单分5种。
 sem_init(sem,pshared,value)，初始化一个信号量，可以指定要不要在 fork() 创建的进程间共享，还可以指定信号量初始值。 sem_wait(sem)，等待信号量，信号量等于0时阻塞，其他线程通过sem_post唤醒。 sem_post(sem)，发送信号量，唤醒阻塞在sem_wait的线程。 sem_getvalue(sem,valp)，获取信号量当前值。 sem_destroy(sem)，销毁信号量。  信号量的主要特征就是它的值："><title>信号量 vs 互斥锁</title>
<link rel=canonical href=https://nnnewb.github.io/blog/p/%E4%BF%A1%E5%8F%B7%E9%87%8F-vs-%E4%BA%92%E6%96%A5%E9%94%81/>
<link rel=stylesheet href=/blog/scss/style.min.css><meta property="og:title" content="信号量 vs 互斥锁">
<meta property="og:description" content="看 go-patterns/semaphore.md at master · tmrts/go-patterns (github.com) 时产生了疑问，信号量为啥长得和互斥锁没啥区别呢。于是就谷歌了一圈，重温下一些关于并发的知识，对比信号量 semaphore 和互斥锁 mutex 。
互斥锁 mutex 以 pthread 自带的互斥锁为例，提供了三种不同类型的互斥锁：
 PTHREAD_MUTEX_NORMAL ，普通的互斥锁，不支持死锁检测（does not detect deadlock），不支持递归加锁（relock without first unlocking it 会导致死锁），不检测解锁线程，解锁一个未加锁的互斥锁是未定义行为（undefined behavior）。 PTHREAD_MUTEX_ERRORCHECK，带错误检查的互斥锁，不支持递归加锁（会返回错误），解锁其他线程的互斥锁会返回错误，解锁未加锁的互斥锁会返回错误。 PTHREAD_MUTEX_RECURSIVE，递归加锁（relock with out unlocking it）会成功，解锁时需要调用解锁的次数和加锁时调用加锁的次数相同。解锁其他线程的互斥锁会返回错误。解锁未加锁的互斥锁会返回错误。 PTHREAD_MUTEX_DEFAULT，默认互斥锁类型，对这一类型的互斥锁递归加锁时行为是未定义的，解锁未加锁的互斥锁行为是未定义的，解锁其他线程的互斥锁行为是未定义的。这一类型的互斥锁通常映射为另外几种互斥锁之一。  可以比较清楚地看出，互斥锁有三个基本特征：
 是否可重复加锁 是否可解锁未加锁的互斥锁 是否可解锁被其他人加锁的互斥锁  最严格的 PTHREAD_MUTEX_ERRORCHECK 类型互斥锁，对此定义是 NO、NO、NO 。
互斥锁的基本使用方式和使用场景有点像厕所的坑位：
 抢坑位，锁门 你懂的 解锁，出门  其中有隐含的信息包括：
 坑位是提前选择好的，你只能抢一个坑位，不能抢多个坑位。 坑位在使用期间是独占的，你不能和别人分享一个坑位。 只有你自己能解锁坑位，谁也不想办事儿的时候有人闯进来吧？  而递归加锁这一特殊场景，我寻思吧，有点难拿坑位比喻。反正也不重要，就别管了。
信号量 semaphore 信号量本质上是一个整型值，不细分什么类型了。还是用 pthread 举例吧，依据 POSIX 标准。
对信号量的操作可以先简单分5种。
 sem_init(sem,pshared,value)，初始化一个信号量，可以指定要不要在 fork() 创建的进程间共享，还可以指定信号量初始值。 sem_wait(sem)，等待信号量，信号量等于0时阻塞，其他线程通过sem_post唤醒。 sem_post(sem)，发送信号量，唤醒阻塞在sem_wait的线程。 sem_getvalue(sem,valp)，获取信号量当前值。 sem_destroy(sem)，销毁信号量。  信号量的主要特征就是它的值：">
<meta property="og:url" content="https://nnnewb.github.io/blog/p/%E4%BF%A1%E5%8F%B7%E9%87%8F-vs-%E4%BA%92%E6%96%A5%E9%94%81/">
<meta property="og:site_name" content="weakptr's 笔记">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="golang"><meta property="article:published_time" content="2021-08-26T00:00:00+00:00"><meta property="article:modified_time" content="2021-08-26T00:00:00+00:00">
<meta name=twitter:title content="信号量 vs 互斥锁">
<meta name=twitter:description content="看 go-patterns/semaphore.md at master · tmrts/go-patterns (github.com) 时产生了疑问，信号量为啥长得和互斥锁没啥区别呢。于是就谷歌了一圈，重温下一些关于并发的知识，对比信号量 semaphore 和互斥锁 mutex 。
互斥锁 mutex 以 pthread 自带的互斥锁为例，提供了三种不同类型的互斥锁：
 PTHREAD_MUTEX_NORMAL ，普通的互斥锁，不支持死锁检测（does not detect deadlock），不支持递归加锁（relock without first unlocking it 会导致死锁），不检测解锁线程，解锁一个未加锁的互斥锁是未定义行为（undefined behavior）。 PTHREAD_MUTEX_ERRORCHECK，带错误检查的互斥锁，不支持递归加锁（会返回错误），解锁其他线程的互斥锁会返回错误，解锁未加锁的互斥锁会返回错误。 PTHREAD_MUTEX_RECURSIVE，递归加锁（relock with out unlocking it）会成功，解锁时需要调用解锁的次数和加锁时调用加锁的次数相同。解锁其他线程的互斥锁会返回错误。解锁未加锁的互斥锁会返回错误。 PTHREAD_MUTEX_DEFAULT，默认互斥锁类型，对这一类型的互斥锁递归加锁时行为是未定义的，解锁未加锁的互斥锁行为是未定义的，解锁其他线程的互斥锁行为是未定义的。这一类型的互斥锁通常映射为另外几种互斥锁之一。  可以比较清楚地看出，互斥锁有三个基本特征：
 是否可重复加锁 是否可解锁未加锁的互斥锁 是否可解锁被其他人加锁的互斥锁  最严格的 PTHREAD_MUTEX_ERRORCHECK 类型互斥锁，对此定义是 NO、NO、NO 。
互斥锁的基本使用方式和使用场景有点像厕所的坑位：
 抢坑位，锁门 你懂的 解锁，出门  其中有隐含的信息包括：
 坑位是提前选择好的，你只能抢一个坑位，不能抢多个坑位。 坑位在使用期间是独占的，你不能和别人分享一个坑位。 只有你自己能解锁坑位，谁也不想办事儿的时候有人闯进来吧？  而递归加锁这一特殊场景，我寻思吧，有点难拿坑位比喻。反正也不重要，就别管了。
信号量 semaphore 信号量本质上是一个整型值，不细分什么类型了。还是用 pthread 举例吧，依据 POSIX 标准。
对信号量的操作可以先简单分5种。
 sem_init(sem,pshared,value)，初始化一个信号量，可以指定要不要在 fork() 创建的进程间共享，还可以指定信号量初始值。 sem_wait(sem)，等待信号量，信号量等于0时阻塞，其他线程通过sem_post唤醒。 sem_post(sem)，发送信号量，唤醒阻塞在sem_wait的线程。 sem_getvalue(sem,valp)，获取信号量当前值。 sem_destroy(sem)，销毁信号量。  信号量的主要特征就是它的值：">
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=https://nnnewb.github.io/blog class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>返回</span>
</a>
</div>
<main class="main full-width">
<article class=main-article>
<header class=article-header>
<div class=article-details>
<header class=article-category>
<a href=/blog/categories/golang/>
golang
</a>
</header>
<h2 class=article-title>
<a href=/blog/p/%E4%BF%A1%E5%8F%B7%E9%87%8F-vs-%E4%BA%92%E6%96%A5%E9%94%81/>信号量 vs 互斥锁</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2021年 8月 26日</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
阅读时长: 1 分钟
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<p>看 <a class=link href=https://github.com/tmrts/go-patterns/blob/master/synchronization/semaphore.md target=_blank rel=noopener>go-patterns/semaphore.md at master · tmrts/go-patterns (github.com)</a> 时产生了疑问，信号量为啥长得和互斥锁没啥区别呢。于是就谷歌了一圈，重温下一些关于并发的知识，对比信号量 <em>semaphore</em> 和互斥锁 <em>mutex</em> 。</p>
<h2 id=互斥锁-mutex>互斥锁 mutex</h2>
<p>以 <em>pthread</em> 自带的互斥锁为例，提供了三种不同类型的互斥锁：</p>
<ul>
<li><em>PTHREAD_MUTEX_NORMAL</em> ，普通的互斥锁，不支持死锁检测（<em>does not detect deadlock</em>），不支持递归加锁（<em>relock without first unlocking it</em> 会导致死锁），不检测解锁线程，解锁一个未加锁的互斥锁是未定义行为（<em>undefined behavior</em>）。</li>
<li><em>PTHREAD_MUTEX_ERRORCHECK</em>，带错误检查的互斥锁，不支持递归加锁（会返回错误），解锁其他线程的互斥锁会返回错误，解锁未加锁的互斥锁会返回错误。</li>
<li><em>PTHREAD_MUTEX_RECURSIVE</em>，递归加锁（<em>relock with out unlocking it</em>）会成功，解锁时需要调用解锁的次数和加锁时调用加锁的次数相同。解锁其他线程的互斥锁会返回错误。解锁未加锁的互斥锁会返回错误。</li>
<li><em>PTHREAD_MUTEX_DEFAULT</em>，默认互斥锁类型，对这一类型的互斥锁递归加锁时行为是未定义的，解锁未加锁的互斥锁行为是未定义的，解锁其他线程的互斥锁行为是未定义的。这一类型的互斥锁通常映射为另外几种互斥锁之一。</li>
</ul>
<p>可以比较清楚地看出，互斥锁有三个基本特征：</p>
<ul>
<li>是否可重复加锁</li>
<li>是否可解锁未加锁的互斥锁</li>
<li>是否可解锁被其他人加锁的互斥锁</li>
</ul>
<p>最严格的 <em>PTHREAD_MUTEX_ERRORCHECK</em> 类型互斥锁，对此定义是 NO、NO、NO 。</p>
<p>互斥锁的基本使用方式和使用场景有点像厕所的坑位：</p>
<ol>
<li>抢坑位，锁门</li>
<li>你懂的</li>
<li>解锁，出门</li>
</ol>
<p>其中有隐含的信息包括：</p>
<ol>
<li>坑位是提前选择好的，你只能抢一个坑位，不能抢多个坑位。</li>
<li>坑位在使用期间是独占的，你不能和别人分享一个坑位。</li>
<li>只有你自己能解锁坑位，谁也不想办事儿的时候有人闯进来吧？</li>
</ol>
<p>而递归加锁这一特殊场景，我寻思吧，有点难拿坑位比喻。反正也不重要，就别管了。</p>
<h2 id=信号量-semaphore>信号量 semaphore</h2>
<p>信号量本质上是一个整型值，不细分什么类型了。还是用 <em>pthread</em> 举例吧，依据 <em>POSIX</em> 标准。</p>
<p>对信号量的操作可以先简单分5种。</p>
<ul>
<li><code>sem_init(sem,pshared,value)</code>，初始化一个信号量，可以指定要不要在 <code>fork()</code> 创建的进程间共享，还可以指定信号量初始值。</li>
<li><code>sem_wait(sem)</code>，等待信号量，信号量等于0时阻塞，其他线程通过<code>sem_post</code>唤醒。</li>
<li><code>sem_post(sem)</code>，发送信号量，唤醒阻塞在<code>sem_wait</code>的线程。</li>
<li><code>sem_getvalue(sem,valp)</code>，获取信号量当前值。</li>
<li><code>sem_destroy(sem)</code>，销毁信号量。</li>
</ul>
<p>信号量的主要特征就是它的值：</p>
<ul>
<li>当值等于0时，<code>sem_wait</code> 会阻塞。</li>
<li>当值大于0时，<code>sem_wait</code> 返回并使值-1。</li>
</ul>
<p>可以注意到，信号量的确可以做到互斥锁能做到的事情：设定好初始值1，然后<code>sem_wait</code>等同于加锁，<code>sem_post</code>等同于解锁，的确模拟出了互斥锁的功能。</p>
<p>不过信号量去模拟互斥锁会有一些问题。比如说无法实现递归加锁（信号量值等于0时，<code>sem_wait</code>会阻塞），无法检测解锁线程是不是加锁线程（除非你自己再封装一次，把信号量和线程ID绑定），解锁未加锁会导致信号量值大于1，进而造成<code>sem_wait</code>会允许多个线程并行执行（还是一样，你得自己封装，在<code>sem_post</code>前检查当前信号量的值）。</p>
<p>好，模拟互斥锁的话题到此为止。回到屎尿屁的比喻上。互斥锁可以比作公厕收费的老大爷。</p>
<ul>
<li>老规矩，不排队，大家从老大爷手里抢坑位。</li>
<li>坑位满员的时候老大爷谁也不让进。</li>
<li>每出来一个人，老大爷就放进去一个人。</li>
</ul>
<p>其中隐含的信息包括：</p>
<ul>
<li>当然，可用的坑位或者说资源依然是有限的，数量不确定。</li>
<li>你只能独占一部分资源，而且每个人独占的资源都一样多。不然老大爷看到有一个坑位放你进去了，但你想要用两个坑位，那你就只能继续等着，或者和别人分享坑位了。</li>
</ul>
<p>信号量最好用的场景还是 <strong>生产者-消费者</strong> 模型的队列，来统计队列中元素数量。消费者可以用一个简单的 <code>sem_timedwait</code> 调用实现等待新元素加入队列，用互斥锁来确保队列操作是线程安全的。</p>
<p>可见管公厕的老大爷也是非常有生活智慧哈，充分利用了年轻时的编程经验来提高晚年生活质量。</p>
<h2 id=结论>结论</h2>
<p>互斥锁和信号量都能处理数据竞争，但各有侧重。</p>
<p>典型的数据竞争场景当然是互斥锁好用，但信号量也不是完全不行。</p>
<p>信号量的典型场景也一样，互斥锁即便能行也会显得别扭。</p>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/blog/tags/golang/>golang</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
</footer>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>相关文章</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article>
<a href=/blog/p/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B-goroutine-%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/>
<div class=article-details>
<h2 class=article-title>面试题之 goroutine 运行顺序</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8/>
<div class=article-details>
<h2 class=article-title>从零实现一个容器</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/go-%E7%9A%84-defer-%E8%AF%AD%E5%8F%A5/>
<div class=article-details>
<h2 class=article-title>go 的 defer 语句</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E4%B9%8B%E8%A7%A3%E5%AF%86ons%E8%84%9A%E6%9C%AC/>
<div class=article-details>
<h2 class=article-title>go语言实战之解密ons脚本</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class=site-footer>
<section class=copyright>
&copy;
2021 weakptr's 笔记
</section>
<section class=powerby>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.1.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">目录</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#互斥锁-mutex>互斥锁 mutex</a></li>
<li><a href=#信号量-semaphore>信号量 semaphore</a></li>
<li><a href=#结论>结论</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/blog/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>