<!doctype html><html lang=zh-cn>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="前言 总得有个前言。
一直玩命令行 crackme 看着就没啥意思，来点带界面的。依然是学习用，目标是把汇编和底层和内存这套东西读熟。这次是用 wxwidgets 做的简单 crackme，为了在 CrackME-02 基础上再增加点难度但又不至于太难，这次是 OTP 生成序列号，要求解出生成 OTP 的 SECRET。
源码 越来越长了，贴上来没法看。现在托管到GitHub，包括前面的两个cm。
前两个cm托管的代码编译参数有一点修改，可能造成结果和文章不一致，但大体是一样的，别在意。
源码托管地址：github.com/nnnewb/crackmes
挑战一下C++代码开启优化的Hard模式。
观察 一个输入框，点击try it尝试。失败时提示Wrong，没有别的信息。
静态分析 老规矩先静态分析一波，粗略扫一眼，捋一捋逻辑。用你喜欢的反汇编工具打开，我用Cutter先试试。
因为是GUI程序，直接跳main肯定是不行的。Win32 GUI程序的入口点（程序员视角）在WinMain这个特殊函数，不过真拿Win32API手撸界面我是真没见过了，Win32 GUI程序设计也是玩的事件响应，找到主函数的意义不大。
所以找关键跳这一步只能是从数据段找字符串查引用，或者调试器下合适的访问断点了。
这里直接从数据段找到了字符串，定位到弹出错误对话框的逻辑。
这里有个姿势点是__thiscall，这是个微软自定义的调用约定，点这里看微软的文档。
__thiscall __thiscall的特点是被调用方清栈，this指针通过ecx寄存器传递，其他参数右至左压栈。对于可变长度参数（VAARG）的成员函数会特殊处理，采用cdecl调用约定，this指针最后压栈。
这里简单读一下定位到的几句代码，分析下意图。
 0x004064dc 68 34 e8 40 00 push str.Try_again ; 0x40e834 0x004064e1 8d 4d d0 lea ecx, [ebp - 0x30] 0x004064e4 ff 15 e0 33 41 00 call dword [public: void __thiscall wxString::constructor(char const *)] ; 0x4133e0 0x004064ea 68 44 e8 40 00 push str."><title>自娱自乐 crackme-03</title>
<link rel=canonical href=https://nnnewb.github.io/blog/p/crackme-03/>
<link rel=stylesheet href=/blog/scss/style.min.css><meta property="og:title" content="自娱自乐 crackme-03">
<meta property="og:description" content="前言 总得有个前言。
一直玩命令行 crackme 看着就没啥意思，来点带界面的。依然是学习用，目标是把汇编和底层和内存这套东西读熟。这次是用 wxwidgets 做的简单 crackme，为了在 CrackME-02 基础上再增加点难度但又不至于太难，这次是 OTP 生成序列号，要求解出生成 OTP 的 SECRET。
源码 越来越长了，贴上来没法看。现在托管到GitHub，包括前面的两个cm。
前两个cm托管的代码编译参数有一点修改，可能造成结果和文章不一致，但大体是一样的，别在意。
源码托管地址：github.com/nnnewb/crackmes
挑战一下C++代码开启优化的Hard模式。
观察 一个输入框，点击try it尝试。失败时提示Wrong，没有别的信息。
静态分析 老规矩先静态分析一波，粗略扫一眼，捋一捋逻辑。用你喜欢的反汇编工具打开，我用Cutter先试试。
因为是GUI程序，直接跳main肯定是不行的。Win32 GUI程序的入口点（程序员视角）在WinMain这个特殊函数，不过真拿Win32API手撸界面我是真没见过了，Win32 GUI程序设计也是玩的事件响应，找到主函数的意义不大。
所以找关键跳这一步只能是从数据段找字符串查引用，或者调试器下合适的访问断点了。
这里直接从数据段找到了字符串，定位到弹出错误对话框的逻辑。
这里有个姿势点是__thiscall，这是个微软自定义的调用约定，点这里看微软的文档。
__thiscall __thiscall的特点是被调用方清栈，this指针通过ecx寄存器传递，其他参数右至左压栈。对于可变长度参数（VAARG）的成员函数会特殊处理，采用cdecl调用约定，this指针最后压栈。
这里简单读一下定位到的几句代码，分析下意图。
 0x004064dc 68 34 e8 40 00 push str.Try_again ; 0x40e834 0x004064e1 8d 4d d0 lea ecx, [ebp - 0x30] 0x004064e4 ff 15 e0 33 41 00 call dword [public: void __thiscall wxString::constructor(char const *)] ; 0x4133e0 0x004064ea 68 44 e8 40 00 push str.">
<meta property="og:url" content="https://nnnewb.github.io/blog/p/crackme-03/">
<meta property="og:site_name" content="weakptr's 笔记">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="汇编"><meta property="article:tag" content="逆向"><meta property="article:published_time" content="2021-09-24T16:58:00+08:00"><meta property="article:modified_time" content="2021-09-24T16:58:00+08:00">
<meta name=twitter:title content="自娱自乐 crackme-03">
<meta name=twitter:description content="前言 总得有个前言。
一直玩命令行 crackme 看着就没啥意思，来点带界面的。依然是学习用，目标是把汇编和底层和内存这套东西读熟。这次是用 wxwidgets 做的简单 crackme，为了在 CrackME-02 基础上再增加点难度但又不至于太难，这次是 OTP 生成序列号，要求解出生成 OTP 的 SECRET。
源码 越来越长了，贴上来没法看。现在托管到GitHub，包括前面的两个cm。
前两个cm托管的代码编译参数有一点修改，可能造成结果和文章不一致，但大体是一样的，别在意。
源码托管地址：github.com/nnnewb/crackmes
挑战一下C++代码开启优化的Hard模式。
观察 一个输入框，点击try it尝试。失败时提示Wrong，没有别的信息。
静态分析 老规矩先静态分析一波，粗略扫一眼，捋一捋逻辑。用你喜欢的反汇编工具打开，我用Cutter先试试。
因为是GUI程序，直接跳main肯定是不行的。Win32 GUI程序的入口点（程序员视角）在WinMain这个特殊函数，不过真拿Win32API手撸界面我是真没见过了，Win32 GUI程序设计也是玩的事件响应，找到主函数的意义不大。
所以找关键跳这一步只能是从数据段找字符串查引用，或者调试器下合适的访问断点了。
这里直接从数据段找到了字符串，定位到弹出错误对话框的逻辑。
这里有个姿势点是__thiscall，这是个微软自定义的调用约定，点这里看微软的文档。
__thiscall __thiscall的特点是被调用方清栈，this指针通过ecx寄存器传递，其他参数右至左压栈。对于可变长度参数（VAARG）的成员函数会特殊处理，采用cdecl调用约定，this指针最后压栈。
这里简单读一下定位到的几句代码，分析下意图。
 0x004064dc 68 34 e8 40 00 push str.Try_again ; 0x40e834 0x004064e1 8d 4d d0 lea ecx, [ebp - 0x30] 0x004064e4 ff 15 e0 33 41 00 call dword [public: void __thiscall wxString::constructor(char const *)] ; 0x4133e0 0x004064ea 68 44 e8 40 00 push str.">
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=https://nnnewb.github.io/blog class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>返回</span>
</a>
</div>
<main class="main full-width">
<article class=main-article>
<header class=article-header>
<div class=article-details>
<header class=article-category>
<a href=/blog/categories/%E9%80%86%E5%90%91/>
逆向
</a>
</header>
<h2 class=article-title>
<a href=/blog/p/crackme-03/>自娱自乐 crackme-03</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2021年 9月 24日</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
阅读时长: 4 分钟
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<h2 id=前言>前言</h2>
<p>总得有个前言。</p>
<p>一直玩命令行 crackme 看着就没啥意思，来点带界面的。依然是学习用，目标是把汇编和底层和内存这套东西读熟。这次是用 wxwidgets 做的简单 crackme，为了在 CrackME-02 基础上再增加点难度但又不至于太难，这次是 OTP 生成序列号，要求解出生成 OTP 的 SECRET。</p>
<h2 id=源码>源码</h2>
<p>越来越长了，贴上来没法看。现在托管到GitHub，包括前面的两个cm。</p>
<p>前两个cm托管的代码编译参数有一点修改，可能造成结果和文章不一致，但大体是一样的，别在意。</p>
<p>源码托管地址：<a class=link href=https://github.com/nnnewb/crackmes/ target=_blank rel=noopener>github.com/nnnewb/crackmes</a></p>
<p>挑战一下C++代码开启优化的Hard模式。</p>
<h2 id=观察>观察</h2>
<p><img src=/blog/image/crackme-03/01.png alt=image-20210923104439284></p>
<p>一个输入框，点击try it尝试。失败时提示Wrong，没有别的信息。</p>
<h2 id=静态分析>静态分析</h2>
<p>老规矩先静态分析一波，粗略扫一眼，捋一捋逻辑。用你喜欢的反汇编工具打开，我用Cutter先试试。</p>
<p>因为是GUI程序，直接跳<code>main</code>肯定是不行的。Win32 GUI程序的入口点（程序员视角）在<code>WinMain</code>这个特殊函数，不过真拿Win32API手撸界面我是真没见过了，Win32 GUI程序设计也是玩的事件响应，找到主函数的意义不大。</p>
<p>所以找关键跳这一步只能是从数据段找字符串查引用，或者调试器下合适的访问断点了。</p>
<p>这里直接从数据段找到了字符串，定位到弹出错误对话框的逻辑。</p>
<p><img src=/blog/image/crackme-03/02.png alt=image-20210923105415082></p>
<p>这里有个姿势点是<code>__thiscall</code>，这是个微软自定义的调用约定，点这里看<a class=link href="https://docs.microsoft.com/zh-cn/cpp/cpp/thiscall?view=msvc-160" target=_blank rel=noopener>微软的文档</a>。</p>
<h3 id=__thiscall>__thiscall</h3>
<p><code>__thiscall</code>的特点是被调用方清栈，<code>this</code>指针通过<code>ecx</code>寄存器传递，其他参数右至左压栈。对于可变长度参数（VAARG）的成员函数会特殊处理，采用<code>cdecl</code>调用约定，<code>this</code>指针最后压栈。</p>
<p>这里简单读一下定位到的几句代码，分析下意图。</p>
<pre><code>
0x004064dc      68 34 e8 40 00              push    str.Try_again ; 0x40e834
0x004064e1      8d 4d d0                    lea     ecx, [ebp - 0x30]
0x004064e4      ff 15 e0 33 41 00           call    dword [public: void __thiscall wxString::constructor(char const *)] ; 0x4133e0
0x004064ea      68 44 e8 40 00              push    str.Wrong ; 0x40e844
0x004064ef      8d 4d b0                    lea     ecx, [ebp - 0x50]
0x004064f2      c6 45 fc 07                 mov     byte [ebp - 4], 7
0x004064f6      ff 15 e0 33 41 00           call    dword [public: void __thiscall wxString::constructor(char const *)] ; 0x4133e0
0x004064fc      6a ff                       push    0xffffffffffffffff
0x004064fe      6a ff                       push    0xffffffffffffffff
0x00406500      6a 00                       push    0
0x00406502      6a 05                       push    5 ; 5
0x00406504      8d 45 d0                    lea     eax, [ebp - 0x30]
0x00406507      c6 45 fc 08                 mov     byte [ebp - 4], 8
0x0040650b      50                          push    eax
0x0040650c      8d 45 b0                    lea     eax, [ebp - 0x50]
0x0040650f      50                          push    eax
0x00406510      ff 15 d4 3c 41 00           call    dword [int __cdecl wxMessageBox(class wxString const &amp;, class wxString const &amp;, long int, class wxWindow *, int, int)] ; 0x413cd4
</code></pre><p>反编译器对调用的第三方库的函数分析极大降低了肉眼判读的难度。可以看到前三步<code>push</code>、<code>lea ecx,...</code>、<code>call</code> 是典型的 <code>__thiscall</code> 调用，调用对象是<code>wxString</code>的构造器，所以可以知道<code>ecx</code>地址保存的是一个<code>wxString</code>对象的指针。</p>
<pre><code>0x004064ea      68 44 e8 40 00              push    str.Wrong ; 0x40e844
0x004064ef      8d 4d b0                    lea     ecx, [ebp - 0x50]
0x004064f2      c6 45 fc 07                 mov     byte [ebp - 4], 7
0x004064f6      ff 15 e0 33 41 00           call    dword [public: void __thiscall wxString::constructor(char const *)] ; 0x4133e0
</code></pre><p>这是另一个<code>wxString</code>的构造。</p>
<pre><code>0x004064fc      6a ff                       push    0xffffffffffffffff
0x004064fe      6a ff                       push    0xffffffffffffffff
0x00406500      6a 00                       push    0
0x00406502      6a 05                       push    5 ; 5
0x00406504      8d 45 d0                    lea     eax, [ebp - 0x30]
0x00406507      c6 45 fc 08                 mov     byte [ebp - 4], 8
0x0040650b      50                          push    eax
0x0040650c      8d 45 b0                    lea     eax, [ebp - 0x50]
0x0040650f      50                          push    eax
0x00406510      ff 15 d4 3c 41 00           call    dword [int __cdecl wxMessageBox(class wxString const &amp;, class wxString const &amp;, long int, class wxWindow *, int, int)] ; 0x413cd4
</code></pre><p>连续推入多个参数后，调用了<code>wxMessageBox</code>函数。我们知道<code>[ebp-0x30]</code>是<code>Try again</code>，<code>[ebp-0x50]</code> 是 <code>Wrong!</code>，这个调用用伪代码表示就是 <code>wxMessageBox("Wrong!", "Try again!", 5, 0, -1, -1)</code>。注意忽略中间的<code>mov byte [ebp - 4], 8</code>，<code>ebp-4</code>这个偏移显然不大可能是参数。</p>
<h3 id=关键跳>关键跳</h3>
<p>回到这段代码的开头，顺着界面上的绿色箭头找到关键跳。</p>
<p><img src=/blog/image/crackme-03/03.png alt=image-20210923111554787></p>
<p>一个<code>je</code>跳转，<code>je</code>指令检查<code>ZF</code>，向上一行就是<code>test</code>，<code>test bl,bl</code>自己对自己逻辑与，其实就是求<code>bl</code>是不是0。</p>
<p>bl又来自前面的<code>mov bl,al</code>，<code>al</code>寄存器是<code>eax</code>寄存器的低8位，再者大家也知道<code>eax</code>寄存器是函数返回值保存的寄存器，而离这个<code>mov</code>指令最近的<code>call</code>就是截图上方的<code>IsSameAs</code>函数了。</p>
<p>到了这一步，改指令跳过验证已经接近成功了，但这要是做 keygen 的话还不行。</p>
<p>继续往回翻，寻找密码生成的代码。</p>
<h3 id=寻找密码生成算法>寻找密码生成算法</h3>
<p>先一路回到关键跳所处的代码块顶部，挨个往下看有哪些函数调用。</p>
<p><img src=/blog/image/crackme-03/04.png alt=image-20210923113330184></p>
<p>还是那句话，感谢分析出了库函数，不然一堆未知函数看得满头雾水。</p>
<ol>
<li>
<p>调用是 <code>wxString.AsWChar(void)</code>，顾名思义是取宽字符，返回指针。</p>
</li>
<li>
<p>调用是<code>wxString.DoFormatWchar(wchar_t*)</code>，查询文档可知是个类似<code>sprintf</code>的字符串格式化函数。</p>
</li>
<li>
<p>调用是析构函数，怀疑上面的两个调用其实是内联了什么wxwidgets库的代码。因为直觉告诉我如果还没离开作用域，编译器应该不会这么着急插入析构函数调用，这听起来就没什么好处，还违背码农直觉。</p>
</li>
<li>
<p>函数就比较迷惑了，一路看上去的话会发现这个偏移值经过了多次计算，目前看不出用意，但还挺可疑的。</p>
</li>
<li>
<p>函数顾名思义，比较字符串相等。</p>
</li>
<li>
<p>又是析构函数。</p>
</li>
</ol>
<p>重点看字符串比较函数的参数：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=err>0</span><span class=nf>x0040646c</span>      <span class=mi>6</span><span class=no>a</span> <span class=mi>01</span>                       <span class=no>push</span>    <span class=mi>1</span> <span class=c>; 1
</span><span class=c></span><span class=mi>0x0040646e</span>      <span class=mi>8</span><span class=no>d</span> <span class=mi>4</span><span class=no>d</span> <span class=mi>90</span>                    <span class=no>lea</span>     <span class=no>ecx</span><span class=p>,</span> <span class=p>[</span><span class=no>ebp</span> <span class=p>-</span> <span class=mi>0x70</span><span class=p>]</span>
<span class=err>0</span><span class=nf>x00406471</span>      <span class=no>c6</span> <span class=mi>45</span> <span class=no>fc</span> <span class=mi>04</span>                 <span class=no>mov</span>     <span class=no>byte</span> <span class=p>[</span><span class=no>ebp</span> <span class=p>-</span> <span class=mi>4</span><span class=p>],</span> <span class=mi>4</span>
<span class=err>0</span><span class=nf>x00406475</span>      <span class=mi>51</span>                          <span class=no>push</span>    <span class=no>ecx</span>
<span class=err>0</span><span class=nf>x00406476</span>      <span class=mi>8</span><span class=no>b</span> <span class=no>c8</span>                       <span class=no>mov</span>     <span class=no>ecx</span><span class=p>,</span> <span class=no>eax</span>
<span class=err>0</span><span class=nf>x00406478</span>      <span class=no>ff</span> <span class=mi>15</span> <span class=no>d4</span> <span class=mi>33</span> <span class=mi>41</span> <span class=mi>00</span>           <span class=no>call</span>    <span class=no>dword</span> <span class=p>[</span><span class=no>public</span><span class=p>:</span> <span class=no>bool</span> <span class=no>__thiscall</span> <span class=no>wxString</span><span class=p>::</span><span class=no>IsSameAs</span><span class=p>(</span><span class=no>class</span> <span class=no>wxString</span> <span class=no>const</span> <span class=err>&amp;</span><span class=p>,</span> <span class=no>bool</span><span class=p>)</span><span class=no>const</span><span class=p>]</span> <span class=c>; 0x4133d4
</span></code></pre></div><p>把<code>eax</code>当成了<code>this</code>，暂且不看栈上的<code>ebp-0x70</code>，看到<code>eax</code>立刻就发现是来自第四个比较迷惑的函数调用，实锤这函数就是生成密码的函数。</p>
<h2 id=动态调试>动态调试</h2>
<p>水平有限，静态分析很快遇到了瓶颈，找不出这个偏移值算出来的函数到底在哪儿。</p>
<p>于是启动调试器，先跟到我们定位到的这个特殊函数。</p>
<p><img src=/blog/image/crackme-03/05.png alt=image-20210923140108796></p>
<p>惊喜地发现胡乱分析出现了错误，<code>eax+0x40</code>其实是获取输入框值的函数。。所以另一个参数，<code>ebp-0x70</code>才是密码。</p>
<p>往回看<code>ebp-0x70</code>在<code>DoFormatWchar</code>被当参数传递了进去，要注意的是<code>DoFormatWchar</code>是一个有变长参数的函数，这意味着你没法得知传了几个参数（前面push的内容不一定是当参数传了），分析更困难。</p>
<p>看一下<code>DoFormatWchar</code>这段汇编。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=err>0</span><span class=nf>x0040642c</span>      <span class=mi>8</span><span class=no>d</span> <span class=mi>8</span><span class=no>d</span> <span class=mi>70</span> <span class=no>ff</span> <span class=no>ff</span> <span class=no>ff</span>           <span class=no>lea</span>     <span class=no>ecx</span><span class=p>,</span> <span class=p>[</span><span class=no>ebp</span> <span class=p>-</span> <span class=mi>0x90</span><span class=p>]</span>
<span class=err>0</span><span class=nf>x00406432</span>      <span class=no>ff</span> <span class=mi>15</span> <span class=no>e8</span> <span class=mi>33</span> <span class=mi>41</span> <span class=mi>00</span>           <span class=no>call</span>    <span class=no>dword</span> <span class=p>[</span><span class=no>private</span><span class=p>:</span> <span class=no>wchar_t</span> <span class=no>const</span> <span class=p>*</span> <span class=no>__thiscall</span> <span class=no>wxFormatString</span><span class=p>::</span><span class=no>AsWChar</span><span class=p>(</span><span class=no>void</span><span class=p>)]</span> <span class=c>; 0x4133e8
</span><span class=c></span><span class=mi>0x00406438</span>      <span class=mi>56</span>                          <span class=no>push</span>    <span class=no>esi</span>
<span class=err>0</span><span class=nf>x00406439</span>      <span class=mi>50</span>                          <span class=no>push</span>    <span class=no>eax</span>
<span class=err>0</span><span class=nf>x0040643a</span>      <span class=mi>8</span><span class=no>d</span> <span class=mi>45</span> <span class=mi>90</span>                    <span class=no>lea</span>     <span class=no>eax</span><span class=p>,</span> <span class=p>[</span><span class=no>ebp</span> <span class=p>-</span> <span class=mi>0x70</span><span class=p>]</span>
<span class=err>0</span><span class=nf>x0040643d</span>      <span class=mi>50</span>                          <span class=no>push</span>    <span class=no>eax</span>
<span class=err>0</span><span class=nf>x0040643e</span>      <span class=no>ff</span> <span class=mi>15</span> <span class=no>d0</span> <span class=mi>33</span> <span class=mi>41</span> <span class=mi>00</span>           <span class=no>call</span>    <span class=no>dword</span> <span class=p>[</span><span class=no>private</span><span class=p>:</span> <span class=no>static</span> <span class=no>class</span> <span class=no>wxString</span> <span class=no>__cdecl</span> <span class=no>wxString</span><span class=p>::</span><span class=no>DoFormatWchar</span><span class=p>(</span><span class=no>wchar_t</span> <span class=no>const</span> <span class=p>*)]</span> <span class=c>; 0x4133d0
</span></code></pre></div><p>一共推了三个东西入栈，esi、eax（上一个调用的返回值）、还有<code>[ebp-0x70]</code>。</p>
<p>继续调试器跟一遍看看。</p>
<p><img src=/blog/image/crackme-03/06.png alt=image-20210923142010900></p>
<p><code>esi</code>的值比较怪，先忽略。</p>
<p><code>eax</code>比较清楚，宽字符串<code>%06d</code>，按压栈顺序，<code>esi</code>的值是紧跟在格式化字符串后面的参数。</p>
<p><img src=/blog/image/crackme-03/07.png alt=image-20210923142347785></p>
<p>最后压栈的eax，也就是ebp-0x70的地址，用伪代码表示就是：<code>DoFormatWchar(&var_70, L"%06d", 0x000F18D8)</code>。PS：有点怪，函数签名最左侧是format也就是格式化字符串，最后压栈这个ebp-0x70就有点莫名其妙。</p>
<p><img src=/blog/image/crackme-03/08.png alt=image-20210923143534148></p>
<p>不过用调试器单步步过后就知道用途了，和猜测的一样，存放的是格式化的结果，也就是正确的密码。</p>
<p>既然如此，往回找esi是哪儿赋值的，因为inline了一大堆东西，Cutter连函数都认不出来了，控制流视图也挂了。。一直往上翻，找到<code>0xcc</code>或者<code>push ebp; mov ebp, esp</code>为止。</p>
<p><img src=/blog/image/crackme-03/09.png alt=image-20210923145922049></p>
<p>右键选择在此处定义函数，随便给个名字，然后等Cutter分析好函数体。</p>
<p><img src=/blog/image/crackme-03/10.png alt=image-20210923150100196></p>
<p>这样一来至少图形视图就能看了。粗略扫一眼，在底下找到<code>IsSameAs</code>这个调用，再往回翻哪儿动了<code>esi</code>这个寄存器，很快找到这两段。</p>
<p><img src=/blog/image/crackme-03/11.png alt=image-20210923150438821></p>
<p>有点杂，先看看。还是粗略按意图把指令分下段。<code>esi</code>来源涉及<code>eax</code>和<code>ecx</code>，一路跟着赋值路径往回翻到第一个块，找到<code>ecx</code>的赋值。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=err>0</span><span class=nf>x004062f1</span>      <span class=no>e8</span> <span class=mi>68</span> <span class=no>b3</span> <span class=no>ff</span> <span class=no>ff</span>              <span class=no>call</span>    <span class=no>fcn.0040165e</span>
<span class=err>0</span><span class=nf>x004062f6</span>      <span class=mi>8</span><span class=no>b</span> <span class=mi>08</span>                       <span class=no>mov</span>     <span class=no>ecx</span><span class=p>,</span> <span class=no>dword</span> <span class=p>[</span><span class=no>eax</span><span class=p>]</span>
</code></pre></div><p>一个未知函数，ctrl+左键点击跟进去后发现疑似是 libcrypto 内联的函数，调用了 HMAC-SHA1 算法。</p>
<p><img src=/blog/image/crackme-03/12.png alt=image-20210924092624224></p>
<p>先做个标记，猜测假设这个函数正确返回（下面的je跳转走到最后一个块），那返回结果应该是HMAC-SHA1的结果。这里通过调试器单步验证。</p>
<p>因为 ASLR 的缘故，可执行文件 .text 段映射的地址不是 0x00401000，调试器没法直接转到静态分析工具中的地址，ASLR 确实折磨人&mldr;</p>
<p>anyway&mldr;</p>
<p>我投翔，特立独行是没好结果的，跑去下载了一个 IDA Free ，打开x32dbg确认 .text 段映射的基址后再到 IDA 的菜单 <code>Edit</code> -> <code>Segments</code> -> <code>rebase program ...</code> 重新设定镜像基址，这样在反汇编界面看到的地址就能和调试器对上了。缺陷是每次打开调试器都要对一次镜像基址，比较麻烦。</p>
<p><img src=/blog/image/crackme-03/image-20210924154631893.png alt=image-20210924154631893></p>
<p>对好镜像基址后，把之前想调试的函数调用地址找到（0x003B62F1），下个断点，看调用后的<code>eax</code>值，发现并不像纯c编译出来的结果，<code>eax</code>并没有什么卵用。</p>
<p>稍微往上瞟了一眼，很容易看到一个<code>mov ecx,esi</code>，但没什么卵用。</p>
<p>碰壁几次后决定跟进这个函数看看。无果。恼，作弊之（读过RFC可能注意到几个特殊常量，比如取哈希结果下标19，与0xf，作为偏移值向后再取4字节，作为bin code。跳过这个函数调用，直接看接下来的内容的话，会发现哈希值其实就存在<code>ecx</code>保存的地址上了。）</p>
<p><img src=/blog/image/crackme-03/image-20210924162043275.png alt=image-20210924162043275></p>
<p>只是这里的HMAC_SHA1值因为不是我们熟悉的ASCII表示，所以一眼有点难看出来。</p>
<p>那么直接跳过上面不清不楚的地方，直接看取哈希后的做法。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=nl>.text:</span><span class=err>003</span><span class=nf>B6307</span> <span class=no>movzx</span>   <span class=no>eax</span><span class=p>,</span> <span class=no>byte</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ecx</span><span class=err>+</span><span class=mi>13</span><span class=no>h</span><span class=p>]</span>
<span class=nl>.text:</span><span class=err>003</span><span class=nf>B630B</span> <span class=no>and</span>     <span class=no>eax</span><span class=p>,</span> <span class=mi>0</span><span class=no>Fh</span> <span class=c>; 取 hash[19] &amp; 0xf 作为初始偏移
</span><span class=c></span><span class=no>.text</span><span class=p>:</span><span class=mi>003</span><span class=no>B630E</span> <span class=no>add</span>     <span class=no>ecx</span><span class=p>,</span> <span class=no>eax</span>
<span class=nl>.text:</span><span class=err>003</span><span class=nf>B6310</span> <span class=no>movzx</span>   <span class=no>esi</span><span class=p>,</span> <span class=no>byte</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ecx</span><span class=p>]</span> <span class=c>; 取偏移处第一个字节，无符号
</span><span class=c></span><span class=no>.text</span><span class=p>:</span><span class=mi>003</span><span class=no>B6313</span> <span class=no>movzx</span>   <span class=no>eax</span><span class=p>,</span> <span class=no>byte</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ecx</span><span class=err>+</span><span class=mi>1</span><span class=p>]</span> <span class=c>; 取偏移处第二个字节，无符号
</span><span class=c></span><span class=no>.text</span><span class=p>:</span><span class=mi>003</span><span class=no>B6317</span> <span class=no>and</span>     <span class=no>esi</span><span class=p>,</span> <span class=mi>7</span><span class=no>Fh</span> <span class=c>; 偏移处第一个字节 &amp; 0x7f ，确保符号位归零
</span><span class=c></span><span class=no>.text</span><span class=p>:</span><span class=mi>003</span><span class=no>B631A</span> <span class=no>shl</span>     <span class=no>esi</span><span class=p>,</span> <span class=mi>8</span> <span class=c>; 第一个字节左移8位后 | 第二个字节，就是把四个字节按顺序填进esi
</span><span class=c></span><span class=no>.text</span><span class=p>:</span><span class=mi>003</span><span class=no>B631D</span> <span class=no>or</span>      <span class=no>esi</span><span class=p>,</span> <span class=no>eax</span>
<span class=nl>.text:</span><span class=err>003</span><span class=nf>B631F</span> <span class=no>movzx</span>   <span class=no>eax</span><span class=p>,</span> <span class=no>byte</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ecx</span><span class=err>+</span><span class=mi>2</span><span class=p>]</span>
<span class=nl>.text:</span><span class=err>003</span><span class=nf>B6323</span> <span class=no>shl</span>     <span class=no>esi</span><span class=p>,</span> <span class=mi>8</span>
<span class=nl>.text:</span><span class=err>003</span><span class=nf>B6326</span> <span class=no>or</span>      <span class=no>esi</span><span class=p>,</span> <span class=no>eax</span>
<span class=nl>.text:</span><span class=err>003</span><span class=nf>B6328</span> <span class=no>movzx</span>   <span class=no>eax</span><span class=p>,</span> <span class=no>byte</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ecx</span><span class=err>+</span><span class=mi>3</span><span class=p>]</span>
<span class=nl>.text:</span><span class=err>003</span><span class=nf>B632C</span> <span class=no>shl</span>     <span class=no>esi</span><span class=p>,</span> <span class=mi>8</span>
</code></pre></div><p>取得的就是4字节正整数了，按RFC的例子，接下来应该取模得到最大6位整数。看下一块汇编。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=nl>.text:</span><span class=err>003</span><span class=nf>B6331</span> <span class=no>mov</span>     <span class=no>ecx</span><span class=p>,</span> <span class=p>[</span><span class=no>ebp</span><span class=err>+</span><span class=no>Block</span><span class=p>]</span>
<span class=nl>.text:</span><span class=err>003</span><span class=nf>B6334</span> <span class=no>mov</span>     <span class=no>eax</span><span class=p>,</span> <span class=mi>431</span><span class=no>BDE83h</span> <span class=c>; magic ?
</span><span class=c></span><span class=no>.text</span><span class=p>:</span><span class=mi>003</span><span class=no>B6339</span> <span class=no>imul</span>    <span class=no>esi</span>
<span class=nl>.text:</span><span class=err>003</span><span class=nf>B633B</span> <span class=no>sar</span>     <span class=no>edx</span><span class=p>,</span> <span class=mi>12</span><span class=no>h</span>
<span class=nl>.text:</span><span class=err>003</span><span class=nf>B633E</span> <span class=no>mov</span>     <span class=no>eax</span><span class=p>,</span> <span class=no>edx</span>
<span class=nl>.text:</span><span class=err>003</span><span class=nf>B6340</span> <span class=no>shr</span>     <span class=no>eax</span><span class=p>,</span> <span class=mi>1</span><span class=no>Fh</span>
<span class=nl>.text:</span><span class=err>003</span><span class=nf>B6343</span> <span class=no>add</span>     <span class=no>eax</span><span class=p>,</span> <span class=no>edx</span>
<span class=nl>.text:</span><span class=err>003</span><span class=nf>B6345</span> <span class=no>imul</span>    <span class=no>eax</span><span class=p>,</span> <span class=mi>0</span><span class=no>F4240h</span>
<span class=nl>.text:</span><span class=err>003</span><span class=nf>B634B</span> <span class=no>sub</span>     <span class=no>esi</span><span class=p>,</span> <span class=no>eax</span>
<span class=nl>.text:</span><span class=err>003</span><span class=nf>B634D</span> <span class=no>test</span>    <span class=no>ecx</span><span class=p>,</span> <span class=no>ecx</span>
<span class=nl>.text:</span><span class=err>003</span><span class=nf>B634F</span> <span class=no>jz</span>      <span class=no>short</span> <span class=no>loc_3B638F</span>
</code></pre></div><p><code>431BDE83h</code> 这个魔术常量吓到我了。搜了一下找到篇<a class=link href=https://bbs.pediy.com/thread-100189.htm target=_blank rel=noopener>看雪的帖子</a>，看起来是编译器把一句<code>%1000000</code>取模给编译成了上面这一串满是魔数的汇编。尝试跟到 <code>sub esi,eax</code> 后，<code>esi</code> 寄存器的结果的确变成了6位以内的整数。</p>
<p>这玩意儿有什么特征吗？总不至于多做几次取模，生成的汇编就完全没法看了吧。。。</p>
<h2 id=keygen>keygen？</h2>
<p>实力有限，尽管亲手写下的C++代码真的很简单，但编译后的结果成了无法承受之重&mldr;</p>
<p>上面分析的内容，其实仔细对着RFC推敲（首先，你得知道是照着RFC写的，不然就多读几遍汇编&mldr;），才能很勉强得到个粗糙的算法，至于能不能写出 keygen，我没啥信心。</p>
<h2 id=结论>结论</h2>
<p>很难。</p>
<p>如果说前面的 C 代码是小游戏的话，那 cm03 就是地球online。开启优化的C++无间地狱。</p>
<p>完全溃败。</p>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/blog/tags/%E6%B1%87%E7%BC%96/>汇编</a>
<a href=/blog/tags/%E9%80%86%E5%90%91/>逆向</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
</footer>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>相关文章</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article>
<a href=/blog/p/learning-packer-08/>
<div class=article-details>
<h2 class=article-title>加壳原理08：混淆技术入门</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/learning-packer-07/>
<div class=article-details>
<h2 class=article-title>加壳原理07 - 花指令入门</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/learning-packer-06/>
<div class=article-details>
<h2 class=article-title>加壳原理06：反调试技术入门</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/learning-packer-04-zlib-compression-packer-demo/>
<div class=article-details>
<h2 class=article-title>加壳原理04 - zlib压缩壳案例</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/learning-packer-03-support-no-relocations/>
<div class=article-details>
<h2 class=article-title>加壳原理03 - 支持没有重定位的程序</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class=site-footer>
<section class=copyright>
&copy;
2021 weakptr's 笔记
</section>
<section class=powerby>
<a href=https://beian.miit.gov.cn/>浙ICP备2021032371号-1</a> <br>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.1.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">目录</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#前言>前言</a></li>
<li><a href=#源码>源码</a></li>
<li><a href=#观察>观察</a></li>
<li><a href=#静态分析>静态分析</a>
<ol>
<li><a href=#__thiscall>__thiscall</a></li>
<li><a href=#关键跳>关键跳</a></li>
<li><a href=#寻找密码生成算法>寻找密码生成算法</a></li>
</ol>
</li>
<li><a href=#动态调试>动态调试</a></li>
<li><a href=#keygen>keygen？</a></li>
<li><a href=#结论>结论</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/blog/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>