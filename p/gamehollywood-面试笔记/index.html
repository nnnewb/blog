<!doctype html><html lang=zh-cn>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Intro 面试的职位是 C++后端开发工程师，主要聊的还是 C++。在过程中自我感觉面得还行，至少没上次那么蠢。
聊的内容主要集中在 STL 和线程安全、资源管理的层面。
惯例的，填完面试信息表并简历一起上交，然后等面试官来客套完，就开始聊技术了。
 注意，面试官的提问并非原话，有修饰和脑补。
 0. 预热：你用哪个版本的 C++？ 客套话什么的就略了。
 面试官：&amp;hellip;行，那我们就聊聊 C++吧。你常用哪个版本的 C++？
  我：我比较常用的是 C++11。
 C++版本这个问题面试里应该不多见，不过作为引入的话题还行，标准之神会瞑目的。
对于C++版本这个词，很大概率上大家说的应该就是 C++标准委员会WG21制定的 C++标准了，最新版本的标准文档是 C++17 定稿N4659，制定中的 C++20 标准文档可以访问WG21/docs/papers/2018查阅。
需要注意的是，如果答成了我用 VC6之类的骚话，很大概率会留下不好的映像——或者对方也是忠实的 VC6 神教教徒的话，达成共识也说不定。
闲话少叙。
1. 起手式：std::shared_ptr  面试官：说说std::shared_ptr是怎么实现的？一般怎么去使用它？
  答：shared_ptr是通过引用计数实现的，它可以作为容器元素，在程序里传递 blabal&amp;hellip;..而且shared_ptr不是线程安全的，它不能跨线程传递，要额外做一层包装 blabla&amp;hellip;&amp;hellip;
 正巧最近有想写一篇智能指针相关的博客，面试官的第一问就提到了。
说到智能指针，就必须提一下 RAII 了。
1.1 异常安全和 RAII std::shared_ptr和其他智能指针类型都在&amp;lt;memory&amp;gt;头文件里定义，主要的作用是实现自动化的资源管理，基于RAII的理念设计和实现。
RAII指的是获取资源即初始化，英文全写是Resource Acquisition Is Initialization，属于一种面向对象编程语言中常见的惯用法。
它的思路是这样子的：初始化即获取资源，离开作用域就自动销毁。
RAII 解决的问题是，当异常发生时，如何确保资源释放。这是个异常安全的问题。
常见的非 RAII 风格代码里，如果要确保资源被正确释放，就要用try {} catch() {} finally {}块捕获异常，然后执行资源释放的代码，再将异常重新抛出。"><title>GameHollywood 面试笔记</title>
<link rel=canonical href=https://nnnewb.github.io/blog/p/gamehollywood-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/>
<link rel=stylesheet href=/blog/scss/style.min.css><meta property="og:title" content="GameHollywood 面试笔记">
<meta property="og:description" content="Intro 面试的职位是 C++后端开发工程师，主要聊的还是 C++。在过程中自我感觉面得还行，至少没上次那么蠢。
聊的内容主要集中在 STL 和线程安全、资源管理的层面。
惯例的，填完面试信息表并简历一起上交，然后等面试官来客套完，就开始聊技术了。
 注意，面试官的提问并非原话，有修饰和脑补。
 0. 预热：你用哪个版本的 C++？ 客套话什么的就略了。
 面试官：&amp;hellip;行，那我们就聊聊 C++吧。你常用哪个版本的 C++？
  我：我比较常用的是 C++11。
 C++版本这个问题面试里应该不多见，不过作为引入的话题还行，标准之神会瞑目的。
对于C++版本这个词，很大概率上大家说的应该就是 C++标准委员会WG21制定的 C++标准了，最新版本的标准文档是 C++17 定稿N4659，制定中的 C++20 标准文档可以访问WG21/docs/papers/2018查阅。
需要注意的是，如果答成了我用 VC6之类的骚话，很大概率会留下不好的映像——或者对方也是忠实的 VC6 神教教徒的话，达成共识也说不定。
闲话少叙。
1. 起手式：std::shared_ptr  面试官：说说std::shared_ptr是怎么实现的？一般怎么去使用它？
  答：shared_ptr是通过引用计数实现的，它可以作为容器元素，在程序里传递 blabal&amp;hellip;..而且shared_ptr不是线程安全的，它不能跨线程传递，要额外做一层包装 blabla&amp;hellip;&amp;hellip;
 正巧最近有想写一篇智能指针相关的博客，面试官的第一问就提到了。
说到智能指针，就必须提一下 RAII 了。
1.1 异常安全和 RAII std::shared_ptr和其他智能指针类型都在&amp;lt;memory&amp;gt;头文件里定义，主要的作用是实现自动化的资源管理，基于RAII的理念设计和实现。
RAII指的是获取资源即初始化，英文全写是Resource Acquisition Is Initialization，属于一种面向对象编程语言中常见的惯用法。
它的思路是这样子的：初始化即获取资源，离开作用域就自动销毁。
RAII 解决的问题是，当异常发生时，如何确保资源释放。这是个异常安全的问题。
常见的非 RAII 风格代码里，如果要确保资源被正确释放，就要用try {} catch() {} finally {}块捕获异常，然后执行资源释放的代码，再将异常重新抛出。">
<meta property="og:url" content="https://nnnewb.github.io/blog/p/gamehollywood-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/">
<meta property="og:site_name" content="weakptr's 笔记">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="面试"><meta property="article:tag" content="c++"><meta property="article:published_time" content="2018-06-26T17:22:00+08:00"><meta property="article:modified_time" content="2018-06-26T17:22:00+08:00">
<meta name=twitter:title content="GameHollywood 面试笔记">
<meta name=twitter:description content="Intro 面试的职位是 C++后端开发工程师，主要聊的还是 C++。在过程中自我感觉面得还行，至少没上次那么蠢。
聊的内容主要集中在 STL 和线程安全、资源管理的层面。
惯例的，填完面试信息表并简历一起上交，然后等面试官来客套完，就开始聊技术了。
 注意，面试官的提问并非原话，有修饰和脑补。
 0. 预热：你用哪个版本的 C++？ 客套话什么的就略了。
 面试官：&amp;hellip;行，那我们就聊聊 C++吧。你常用哪个版本的 C++？
  我：我比较常用的是 C++11。
 C++版本这个问题面试里应该不多见，不过作为引入的话题还行，标准之神会瞑目的。
对于C++版本这个词，很大概率上大家说的应该就是 C++标准委员会WG21制定的 C++标准了，最新版本的标准文档是 C++17 定稿N4659，制定中的 C++20 标准文档可以访问WG21/docs/papers/2018查阅。
需要注意的是，如果答成了我用 VC6之类的骚话，很大概率会留下不好的映像——或者对方也是忠实的 VC6 神教教徒的话，达成共识也说不定。
闲话少叙。
1. 起手式：std::shared_ptr  面试官：说说std::shared_ptr是怎么实现的？一般怎么去使用它？
  答：shared_ptr是通过引用计数实现的，它可以作为容器元素，在程序里传递 blabal&amp;hellip;..而且shared_ptr不是线程安全的，它不能跨线程传递，要额外做一层包装 blabla&amp;hellip;&amp;hellip;
 正巧最近有想写一篇智能指针相关的博客，面试官的第一问就提到了。
说到智能指针，就必须提一下 RAII 了。
1.1 异常安全和 RAII std::shared_ptr和其他智能指针类型都在&amp;lt;memory&amp;gt;头文件里定义，主要的作用是实现自动化的资源管理，基于RAII的理念设计和实现。
RAII指的是获取资源即初始化，英文全写是Resource Acquisition Is Initialization，属于一种面向对象编程语言中常见的惯用法。
它的思路是这样子的：初始化即获取资源，离开作用域就自动销毁。
RAII 解决的问题是，当异常发生时，如何确保资源释放。这是个异常安全的问题。
常见的非 RAII 风格代码里，如果要确保资源被正确释放，就要用try {} catch() {} finally {}块捕获异常，然后执行资源释放的代码，再将异常重新抛出。">
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=https://nnnewb.github.io/blog class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>返回</span>
</a>
</div>
<main class="main full-width">
<article class=main-article>
<header class=article-header>
<div class=article-details>
<header class=article-category>
<a href=/blog/categories/c++/>
c++
</a>
</header>
<h2 class=article-title>
<a href=/blog/p/gamehollywood-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/>GameHollywood 面试笔记</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2018年 6月 26日</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
阅读时长: 3 分钟
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<h2 id=intro>Intro</h2>
<p>面试的职位是 C++后端开发工程师，主要聊的还是 C++。在过程中自我感觉面得还行，至少没<a class=link href=https://my.oschina.net/u/3888259/blog/1833040 target=_blank rel=noopener>上次</a>那么蠢。</p>
<p>聊的内容主要集中在 STL 和线程安全、资源管理的层面。</p>
<p>惯例的，填完面试信息表并简历一起上交，然后等面试官来客套完，就开始聊技术了。</p>
<blockquote>
<p>注意，面试官的提问并非原话，有修饰和脑补。</p>
</blockquote>
<h2 id=0-预热你用哪个版本的-c>0. 预热：你用哪个版本的 C++？</h2>
<p>客套话什么的就略了。</p>
<blockquote>
<p>面试官：&mldr;行，那我们就聊聊 C++吧。你常用哪个版本的 C++？</p>
</blockquote>
<blockquote>
<p>我：我比较常用的是 C++11。</p>
</blockquote>
<p>C++版本这个问题面试里应该不多见，不过作为引入的话题还行，标准之神会瞑目的。</p>
<p>对于<strong>C++版本</strong>这个词，很大概率上大家说的应该就是 C++标准委员会<a class=link href=http://www.open-std.org/JTC1/SC22/WG21/ target=_blank rel=noopener>WG21</a>制定的 C++标准了，最新版本的标准文档是 C++17 定稿<a class=link href=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf target=_blank rel=noopener>N4659</a>，制定中的 C++20 标准文档可以访问<a class=link href=http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2018/ target=_blank rel=noopener>WG21/docs/papers/2018</a>查阅。</p>
<p>需要注意的是，如果答成了<strong>我用 VC6</strong>之类的骚话，很大概率会留下不好的映像——或者对方也是忠实的 VC6 神教教徒的话，达成共识也说不定。</p>
<p>闲话少叙。</p>
<h2 id=1-起手式stdshared_ptr>1. 起手式：<code>std::shared_ptr</code></h2>
<blockquote>
<p>面试官：说说<code>std::shared_ptr</code>是怎么实现的？一般怎么去使用它？</p>
</blockquote>
<blockquote>
<p>答：<code>shared_ptr</code>是通过<strong>引用计数</strong>实现的，它可以作为容器元素，在程序里传递 blabal&mldr;..而且<code>shared_ptr</code><strong>不是线程安全的</strong>，它不能跨线程传递，要额外做一层包装 blabla&mldr;&mldr;</p>
</blockquote>
<p>正巧最近有想写一篇智能指针相关的博客，面试官的第一问就提到了。</p>
<p>说到智能指针，就必须提一下 RAII 了。</p>
<h3 id=11-异常安全和-raii>1.1 异常安全和 RAII</h3>
<p><code>std::shared_ptr</code>和其他智能指针类型都在<code>&lt;memory></code>头文件里定义，主要的作用是实现自动化的资源管理，基于<strong>RAII</strong>的理念设计和实现。</p>
<p><strong>RAII</strong>指的是<strong>获取资源即初始化</strong>，英文全写是<strong>Resource Acquisition Is Initialization</strong>，属于一种面向对象编程语言中常见的惯用法。</p>
<p>它的思路是这样子的：初始化即获取资源，离开作用域就自动销毁。</p>
<p>RAII 解决的问题是，当异常发生时，如何确保资源释放。这是个<strong>异常安全</strong>的问题。</p>
<p>常见的非 RAII 风格代码里，如果要确保资源被正确释放，就要用<code>try {} catch() {} finally {}</code>块捕获异常，然后执行资源释放的代码，再将异常重新抛出。</p>
<p>而 RAII 的理念是，让资源的生命周期和一个栈上的对象严格绑定，确保栈上对象被析构的时候，资源也就被一同释放了。</p>
<p>在 C++中，有大量的代码都是以 RAII 风格进行设计的，其中智能指针也是。</p>
<h3 id=12-stdshared_ptr的实现>1.2 <code>std::shared_ptr</code>的实现</h3>
<p>引用计数，大概了解过智能指针的人都能回答得出来。</p>
<p>虽然说实现方式并没有规定只能是引用计数，但实际上大家都是这么写的，万一哪天有个 GC 实现的<code>std::shared_ptr</code>也别太震惊。</p>
<p>实现思路也挺简单。</p>
<p>所有指向同一实例的<code>std::shared_ptr</code>应当持有同一个引用计数，来保持所有<code>std::shared_ptr</code>计数同步，所以它们共同拥有一个计数器指针<code>long *p</code>。</p>
<p>在复制时，<code>shared_ptr</code>管理的对象指针和引用计数器指针被同时复制，然后引用计数器指针保存的引用计数+1——销毁同理，减少引用，直到删除。</p>
<h3 id=13-stdshared_ptr和copyassignable>1.3 <code>std::shared_ptr</code>和<code>CopyAssignable</code></h3>
<p><code>std::shared_ptr</code>满足<code>CopyContructiable</code>、<code>CopyAssignable</code>和<code>LessThanComparable</code>这些标准库的<a class=link href=https://zh.cppreference.com/w/cpp/named_req target=_blank rel=noopener>具名要求</a>，因此可以作为 STL 容器的元素。</p>
<blockquote>
<p>顺便一提 <code>Concept</code> 有很大可能出现在 C++20 标准里。</p>
</blockquote>
<h3 id=14-线程安全性>1.4 线程安全性</h3>
<p><code>std::shared_ptr</code>不是线程安全的，不然不满足 C++对<code>Zero Cost Abstraction</code>的要（吹）求（逼）。</p>
<p>依据官方说法，多线程访问不同的<code>std::shared_ptr</code>实例是没问题的（大多容器也是）；多线程访问同一个<code>std::shared_ptr</code>实例，但是只调用<code>const</code>方法，那么也是没问题的（多线程读）；多线程访问同一个<code>std::shared_ptr</code>实例，调用非<code>const</code>方法，那么会产生数据竞争（多线程读写）。</p>
<p>如果希望在线程间传递 <code>std::shared_ptr</code> 得靠 STL 提供的原子操作库<code>std::atomic</code>。</p>
<p><code>std::atomic</code>可以快速帮助包装一个线程安全的对象或者指针，不过这东西对<code>std::shared_ptr</code>的特化是目前还在制定的<code>C++20</code>标准的一部分，所以能不用则不用，直到标准制定完成稳定，并且各编译器支持完善后再行考虑。</p>
<p>除此之外，如果确实有这方面的考虑，引入<code>boost</code>是一个不错的选择。</p>
<p>无论如何，跨线程使用<code>std::shared_ptr</code>我不怎么支持。</p>
<p>跨线程传递<code>std::shared_ptr</code>本身就是个非常危险的行为。<code>std::shared_ptr</code>作为标准库的一员，背负了 C++的历史包袱，它随时可能被取出裸指针使用，或者意外复制了一次或几次，而这些对线程安全几乎就是意味着作死的行为却没有任何管束。</p>
<h3 id=15-其他智能指针>1.5 其他智能指针</h3>
<ul>
<li><code>std::auto_ptr</code></li>
<li><code>std::weak_ptr</code></li>
<li><code>std::unique_ptr</code></li>
</ul>
<p>其中<code>std::auto_ptr</code>已经被扫进历史的垃圾堆了，作为替代者，<code>std::unique_ptr</code>有更明确的语义和更高的可定制性。</p>
<p><code>std::weak_ptr</code>是对于<code>std::shared_ptr</code>的补充，对于希望使用<code>std::shared_ptr</code>作为使用了指针的数据结构之间的连接方式，又不希望产生循环引用恶劣情况的一个解决方案。弱指针的存在不影响引用计数工作。</p>
<p>最后是<code>std::unique_ptr</code>，它的语义是明确唯一持有某一资源，依照约定，被<code>std::unique_ptr</code>持有的资源不应该再有第二人持有，<code>std::unique_ptr</code>是唯一访问该资源的入口。</p>
<p>这些智能指针都有一个共同点：为了兼容 C 代码，所以它们随时可以被取出裸指针而不影响自身的工作，但这种使用方式造成的一切后果自负。</p>
<h2 id=2-stdvector>2. <code>std::vector</code></h2>
<blockquote>
<p>面试官：&mldr;知道<code>std::vector</code>吧？讲讲它是怎么实现的。</p>
</blockquote>
<blockquote>
<p>我：vector 保存了一个一定长度的 buffer，当插入时可以避免插入一次就分配一次空间 blabla&mldr;当插入长度超过了 buffer 长度，buffer 会依照内部算法来重新分配一次内存，扩张长度。</p>
</blockquote>
<p>回答不全对。其实面试官之后又强调了一次，但面试时没有听出来。</p>
<blockquote>
<p>面试官：那之前分配的 buffer 呢？</p>
<p>我：之前分配的 buffer 先复制到新的 buffer 里，然后旧 buffer 会被释放。</p>
</blockquote>
<p>这里对于释放旧 buffer 的说法其实是有问题的，可以具体看看下面。</p>
<h3 id=21-内存布局>2.1 内存布局</h3>
<p><code>std::vector</code>的<strong>内存布局是连续的</strong>，这一点除了几乎每个人都有所了解之外（&mldr;），标准给出的要求也可以看出点端倪。</p>
<blockquote>
<p>26.3.11.1 Class template vector overview</p>
<p>A vector is a sequence container that supports (amortized) constant time insert and erase operations at the end; insert and erase in the middle take linear time. Storage management is handled automatically, though hints can be given to improve eﬃciency.</p>
</blockquote>
<p>关键点集中在这里：</p>
<blockquote>
<p>&mldr; constant time insert and erase operations at the end;</p>
</blockquote>
<p>末端插入和删除是常数时间</p>
<blockquote>
<p>&mldr; insert and erase in the middle take linear time.</p>
</blockquote>
<p>中间插入和删除需要线性时间（就是 <code>O(n)</code>）。</p>
<p>典型的数组插入和删除的特征，不同的是<code>std::vector</code>可以变长，所以真正插入大量数据的时候会有多次重新分配内存和复制的操作。</p>
<h3 id=22-copyassignable的约定>2.2 <code>CopyAssignable</code>的约定</h3>
<p><code>std::vector</code>要求储存的对象满足<code>DefautConstructible</code>、<code>CopyContructiable</code>和<code>CopyAssignable</code>的具名要求，文档参考<code>26.3.11.1</code>第 2 节。</p>
<blockquote>
<p>26.3.11.1</p>
<p>A vector satisﬁes all of the requirements of a container and of a reversible container (given in two tables in 26.2), of a sequence container, including most of the optional sequence container requirements (26.2.3), of an allocator-aware container (Table 86), and, for an element type other than bool, of a contiguous container (26.2.1).</p>
</blockquote>
<p>其中提到的<code>Table 86</code>中列出了<code>DefaultConstructible</code>、<code>CopyAssignable</code>和<code>CopyConstructiable</code>。</p>
<p>发挥一下脑洞，这些要求完美符合了之前对于重新分配内存的猜测对不对？</p>
<p>对象要可以被默认构造，因为<code>vector</code>的实现可能是<code>new</code>了一个新的对象数组（更可能是字节数组，到时候再<code>placement new</code>）；对象要可以被复制构造，因为对象可能被从旧数组移动到新数组；对象要可以被复制构造&mldr;..</p>
<p>当然更可能的原因是<code>vector</code>本身是可复制的，上面的就当我吹逼吧。</p>
<p>除此之外还有<code>CopyInsertable</code>和<code>MoveInsertable</code>的具名需求，就像其字面意义那样，不多做解释。</p>
<h3 id=23-内存重新分配的方式>2.3 内存重新分配的方式</h3>
<p>对 C 稍有经验的人应该知道 C 语言有一个 API 叫做<code>realloc</code>，它做的事情是这样的：</p>
<ol>
<li>如果可能的话，扩张原先分配的内存的长度。</li>
<li>否则重新分配一块内存，然后把旧的内存复制过去，释放旧内存，返回新指针。</li>
<li>如果找不到足够长度的连续内存，则返回 NULL，不释放旧内存。</li>
</ol>
<p>C++自然不会少。</p>
<p>面试时没有想起来，本来认为是一种优化方案，但 STL 本身就算是优化方案了吧（&mldr;）。正确的解答应该是</p>
<blockquote>
<p>用 realloc 的方式尝试扩展 buffer 长度，如果无法扩展长度，则拷贝旧 buffer 到新 buffer，再释放旧 buffer。</p>
</blockquote>
<p>还行，失误就是失误，认错复习一遍。</p>
<h2 id=3-比较三个容器vectormaplist>3. 比较三个容器：<code>vector</code>,<code>map</code>,<code>list</code></h2>
<blockquote>
<p>面试官：说说看<code>vector</code>、<code>list</code>、<code>map</code>有什么不同，分别在什么样的上下文环境里去使用它们吧。</p>
<p>我：vector 可以被随机访问，支持随机访问迭代器，迭代器算法有些不适用在<code>list</code>和<code>map</code>上 blabla&mldr;<code>list</code>通常是链表实现，在插入删除的性能上有优势 blabla&mldr;&mldr;</p>
</blockquote>
<p>顺便一提还没说到<code>map</code>，面试官就换话题了。</p>
<p>这一题我大概又没有 get 到面试官的 point，单谈论容器的话可说的东西不少，我觉得面试官可能更想了解下我对这些容器的性能和内存方面的认知，可惜我答的有些太浅白了。</p>
<h3 id=31-迭代器>3.1 迭代器</h3>
<p>先从迭代器的角度比较三个容器。</p>
<p><code>vector</code>是个典型的随机访问容器，显然支持<code>forward iterator</code>、<code>reversible iterator</code>和<code>random access iterator</code>。典型的实现是<a class=link href=https://en.wikipedia.org/wiki/Dynamic_array target=_blank rel=noopener><code>dynamic array</code></a>。</p>
<p><code>list</code>是个线性结构容器，支持<code>forward iterator</code>、<code>reversible iterator</code>。典型的实现是链表。</p>
<p><code>map</code>是个树形容器，支持<code>forward iterator</code>和<code>reversible iterator</code>。典型的实现是红黑树。</p>
<h3 id=32-内存布局和访问效率>3.2 内存布局和访问效率</h3>
<p>讨论常见实现。</p>
<p><code>vector</code>是连续分配，访问成本低，插入和删除的成本高，会重分配内存。</p>
<p><code>list</code>是不连续分配，访问成本高，任意位置插入删除成本相对低，插入删除不会导致重新分配整块内存。</p>
<p><code>map</code>是不连续分配，插入删除访问成本不应和线性容器比较，毕竟它是关联容器。插入删除的成本都比较高，因为需要重新平衡树。访问时间在标准中的要求是对数时间复杂度，插入时间懒得继续翻标准文档了。</p>
<h3 id=33-使用上下文>3.3 使用上下文</h3>
<p>显而易见<code>vector</code>适合高频读，而<code>list</code>适合大量插入删除，<code>map</code>和前面两个迭代器都搭不上调，在需要复杂索引的地方再合适不过了。</p>
<h3 id=34-线程安全性>3.4 线程安全性</h3>
<p>这些容器都不是线程安全的。</p>
<p>依照标准，多线程访问不同的容器实例一切都安好，访问同一个实例的<code>const</code>方法也 ok，但是非<code>const</code>方法就会引起数据竞争。</p>
<p>尤其注意迭代器的选择，这玩意儿有时候不比指针好多少。</p>
<h2 id=4-如何管理内存资源>4. 如何管理内存资源</h2>
<blockquote>
<p>面试官：你在项目里一般是怎么管理内存的呢？</p>
<p>我：一个是尽可能用智能指针，然后是需要频繁构造对象的场合下可以用 placement new blabla&mldr;</p>
</blockquote>
<p>内存管理是一个非常广阔的话题，我的回答太过于浅显了。常见的内存管理策略有很多，智能指针只能算是 RAII 这种常见的范式，placement new 算是内存池/对象池的一种写法大概，还有其他很多策略我并不了解也未能涉及。</p>
<h3 id=41-再论-raii>4.1 再论 RAII</h3>
<p>RAII 的范式可以确保异常安全，避免手贱忘记回收内存以及底层设计变更抛出的异常无法处理时导致意外的资源泄露。</p>
<p>诸如此类等等。</p>
<p>有一些约定可以关注一下。</p>
<h4 id=411-获取资源失败抛异常>4.1.1 获取资源失败抛异常</h4>
<p>首先 RAII 的全写是<strong>获取资源即初始化</strong>，连资源都没能获取的话，构造理应失败，而不是静默给出一个无效的对象。</p>
<h4 id=412-析构绝不抛异常>4.1.2 析构绝不抛异常</h4>
<p>很好理解，如果析构又抛个异常出来的话，这个对象还析构不析构？父类还析构不析构？</p>
<h4 id=423-常见设计>4.2.3 常见设计</h4>
<p>在 STL 里除了智能指针以 RAII 设计以外，还有加锁解锁相关的内容也是：<code>std::lock_guard</code>。</p>
<p>诸如此类的<code>guard</code>模式也在其他语言中有出现：比如说 C#的<code>using (var file = File.Open(...)) {}</code>。</p>
<h3 id=42-内存池和对象池>4.2 内存池和对象池</h3>
<p>内存池和对象池算是常见的设计范式，基本考虑到大量对象的构造删除的情况都会考虑到使用这两个模式，因为真的很好用（</p>
<p>内存池的模式主要是预先分配内存，然后在这片内存上构造对象，主要的适用场景是大量频繁构造小对象，构造成本低，生命周期短，内存分配成本居高不下的情况。当然，不仅是这里提到的场景，根据具体业务逻辑可能还会有不同的理由去选择内存池模式。</p>
<p>对象池区别于内存池的地方在于，对象池的对象构造成本要更高，频繁构造和析构是无法接受的，这种时候就需要一个候选备用的对象池，对象池实现需要对象本身允许被复用在不同的地方，一般来说性能会比较好。内存池则没这个顾虑：反正你需要就构造一个呗。</p>
<p>这两个池都可以用<code>factory</code>模式来提供构造对象的服务，而工厂的消费者不需要了解对象是怎么构造出来的。结合 RAII 的话，内存池、对象池里的对象还可以用一层 RAII 设计的“智能指针”封装，使其完成使命后能自动返还资源，等待下一个工厂访客。</p>
<h2 id=5-玩过哪些游戏对游戏制作流程了解多少>5. 玩过哪些游戏，对游戏制作流程了解多少？</h2>
<blockquote>
<p>面试官：喜欢玩游戏吗？都玩过哪些游戏？</p>
<p>我：我的话&mldr;主要玩的是音游，和贵公司业务可能并没有太多关联。</p>
<p>面试官：除了音乐游戏，有玩过 RPG、ARPG 类型的游戏吗？</p>
<p>我：像是辐射啊，老滚啊这些&mldr;开放世界类型的游戏游戏性没那么好，比起来我更喜欢电影式的游戏，比如说最近比较火的《底特律：变人》。</p>
<p>面试官：&mldr;&mldr;（你丫来捣乱的是吧）</p>
<p>面试官：说说你对游戏行业的看法吧。</p>
<p>我：游戏行业前景好啊 blablabla&mldr;娱乐崛起 blabla&mldr;经济增长 blabla&mldr;.</p>
<p>面试官：&mldr;&mldr;（？？？？）</p>
<p>面试官：你上一家公司也是制作游戏的吧？就是说，你们游戏制作啊，都有哪方面的人在负责做什么东西，大概是怎么个分工合作的样子。（提醒+强调）
我：哦！哦哦，大概就是一个人负责策划整个游戏的玩法和系统，设计每个细节，然后程序负责去实现，自动测试 blabla&mldr;内部试玩 blabla&mldr;</p>
</blockquote>
<p>还行，这波操作其实我也是挺佩服自己的。</p>
<h3 id=51-陷阱玩过哪些游戏>5.1 陷阱：玩过哪些游戏</h3>
<p>我注意到一件事：在多次面试游戏行业的职位时，都提到这这个问题：</p>
<blockquote>
<p>你玩过哪些游戏？</p>
</blockquote>
<p>也许形式上有所区别：</p>
<blockquote>
<p>你玩过的游戏里，有哪些特别喜欢的？</p>
</blockquote>
<p>换位思考，如果我是面试官，我为什么要问这个问题？我想知道什么？</p>
<blockquote>
<p>熟悉游戏吗？</p>
<p>知道游戏有哪些元素吗？</p>
<p>能理解（我们招你进来要做的游戏）要你做什么吗？</p>
</blockquote>
<p>不必太过刻意地表达出对游戏行业的崇拜或者抬高之类的，这一关主要的目的还是引出下文，聊聊对游戏制作流程的理解。如果对面试的公司出的产品有所了解的话可能算是加分项。</p>
<p>但是，从一个游戏玩家的角度出发，表现出不好的情绪容易留下坏映像——<strong>特别是，绝对不要明显地表达出对国产网游、手游、页游的鄙视！！</strong></p>
<p>从一个玩家的角度出发，我也不喜欢<strong>大部分</strong>国产的页游手游，但是当着游戏行业公司的面试官的面，表现出<strong>我看不起你</strong>的态度，知道什么叫作死吗？</p>
<p>更何况并不是<strong>所有国产游戏</strong>都是屎，举例来说我现在超喜欢 MUSE DASH 这款国产音游的，手感比兰空 voze、节奏大师之类的好得多，界面也没有像节奏大师那样糊成屎，要不是我的 Unity3D 水平太差我真想给这家 pero pero game 工作室（公司？）投个简历看看。</p>
<p>除此之外还有就是抱着<strong>拯救国产游戏</strong>的想法或者态度，又或者<strong>劳资教你们什么才是真正的游戏</strong>这样的想法或者态度，作死无极限啊。</p>
<p>比较稳妥的回答方案应该是常见的几个网游，比如说 LOL，DNF，王者荣耀，诸如此类。实际上玩过没玩过&mldr;..咳，不被戳穿就无所谓了。</p>
<h3 id=52-游戏行业>5.2 游戏行业</h3>
<p>加班是家常便饭，好像所有游戏行业的公司都会这么说。</p>
<p>大概了解下几个术语，算是加班界的黑话吧。</p>
<p>一个是 996。什么意思呢？上午 9 点上班，晚上 9 点下班，一周上 6 天，加班费不用考虑了，不存在的，最多给调休。</p>
<p>再有一个是大小周。一周上 6 天，一周上 5 天，如此循环。同样，大周加班不算加班费，给调休。</p>
<p>另外就是调休。如果加班一天，将来某天就可以不扣工资休息一天，直白吧。攒下半年的调休然后一口气给自己放 6 个月假这种事情还是做梦比较好，调休基本上就等于无偿加班了，忙起来的时候劝你别休，不然人手就不够了；那闲下来的时候还能让你一周休 6 天？你敢休公司也不敢让你随便休啊，其他员工怎么看。</p>
<p>发薪日。网上有人总结，发薪日越接近月中的，或者超过月中的，大多都是怕员工流失的公司，而这些公司往往都不是什么好公司。听起来还是挺有道理的（</p>
<p>当然，最后还是要靠自己的眼睛去确认这一点。</p>
<h3 id=53-游戏的制作流程>5.3 游戏的制作流程</h3>
<p>之前待得确实是一家小公司，甚至算得上工作室级别的超小初创公司，游戏制作方面的知识储备不算充足，写这篇博客的时候又去补习了一下。</p>
<p>主要的工种分为策划、美术、程序。</p>
<p>细分的话，策划可能有数值方面的，世界背景人物背景方面的，对话文本方面的，甚至可能有长篇幅的资料啊故事啊这方面的需求。</p>
<p>美术有 UI 方面的，人物、场景的原画师，3d 模型制作，动画制作，骨骼制作，特效制作，等等方面的。程序经常需要和美术方面的沟通交流。</p>
<p>程序的话主要分前后端和测试，再加上运维和 DBA 之类的角色。</p>
<p>细分的话前端根据开发平台不同也有不同的技术栈，图像特效上可能会有更专业的大牛负责，team leader 带队设计架构，分配工作，诸如此类。后端也一样，根据不同的技术抉择，可能整体的人员配置也有所区别，但大家都是程序嘛。</p>
<p>测试算是比较独立的，编写测试代码是一件很痛苦的事情（</p>
<p>所以这份疼痛有专人负责承受了：）</p>
<p>持续集成啊什么的也被承包了，测试或者运维会去负责的。</p>
<p>DBA 一般公司也用不到，运维多少会两手 SQL，规模更大的公司可能会设置这个专门职位。</p>
<p>流程上来说，策划给出游戏方案，美术可能会配合做个初稿效果图之类的（更可能是策划自己做个简单的效果图之类的方便说明），程序疯狂实现（崩溃-爆发-认命 循环），测试则配合给出反馈，让程序的脱发状况持续恶化，最后发布，项目黄了。</p>
<p>哦不是，我是说项目火了，程序们一跃成为 CTO，迎娶白富美，走上人生巅峰。</p>
<p>（并没有）</p>
<h2 id=6-尾声>6. 尾声</h2>
<p>其实这次面试的自我感觉还是不错的，没有犯下太蠢的错误，但是可以改进的地方依然很多，语言组织能力需要进一步提高。</p>
<p>这篇博客的目的是自我反省，但是这次自我反省的效果并不算好，因为面试官的问题基本上都戳在我懂，但又没真正去深入挖掘的领域。日常使用自然没有问题，但理解却谈不上了。</p>
<p>如果面试官在细节上稍作追究：比如说 placement new 和 user-defined new 之类的话题上深入，异常安全，或者问个 map 用红黑树实现，红黑树什么原理，那么这次我基本又要挂了。</p>
<p>关于给出的待遇的问题&mldr;&mldr;我其实很好奇&mldr;&mldr;</p>
<p>因为我真的才工作一年，不懂啊&mldr;</p>
<p>一年工作年限，C++我也不知道算什么水平，不知道怎么去横向对比，要 8k 是要多了么&mldr;</p>
<p>初级职位的意思是待遇初级还是能力初级啊&mldr;</p>
<p>还有主程一般指的是 team leader 对吗，游戏行业程序是不是干到 team leader 就算到头了&mldr;只能转管理岗了&mldr;</p>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/blog/tags/%E9%9D%A2%E8%AF%95/>面试</a>
<a href=/blog/tags/c++/>c++</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
</footer>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>相关文章</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article>
<a href=/blog/p/how-to-compile-lief-on-windows/>
<div class=article-details>
<h2 class=article-title>编译LIEF的各种姿势</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/%E5%9C%A8c-%E4%B8%AD%E5%B5%8C%E5%85%A5python%E8%A7%A3%E9%87%8A%E5%99%A8/>
<div class=article-details>
<h2 class=article-title>在C++中嵌入Python解释器</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/%E5%8F%AF%E9%87%8D%E5%85%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E5%AE%89%E5%85%A8/>
<div class=article-details>
<h2 class=article-title>可重入和异步安全</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/%E9%B2%B8%E9%B1%BC%E6%B8%B8%E6%88%8F%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/>
<div class=article-details>
<h2 class=article-title>鲸鱼游戏面试笔记</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class=site-footer>
<section class=copyright>
&copy;
2021 weakptr's 笔记
</section>
<section class=powerby>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.1.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">目录</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#intro>Intro</a></li>
<li><a href=#0-预热你用哪个版本的-c>0. 预热：你用哪个版本的 C++？</a></li>
<li><a href=#1-起手式stdshared_ptr>1. 起手式：<code>std::shared_ptr</code></a>
<ol>
<li><a href=#11-异常安全和-raii>1.1 异常安全和 RAII</a></li>
<li><a href=#12-stdshared_ptr的实现>1.2 <code>std::shared_ptr</code>的实现</a></li>
<li><a href=#13-stdshared_ptr和copyassignable>1.3 <code>std::shared_ptr</code>和<code>CopyAssignable</code></a></li>
<li><a href=#14-线程安全性>1.4 线程安全性</a></li>
<li><a href=#15-其他智能指针>1.5 其他智能指针</a></li>
</ol>
</li>
<li><a href=#2-stdvector>2. <code>std::vector</code></a>
<ol>
<li><a href=#21-内存布局>2.1 内存布局</a></li>
<li><a href=#22-copyassignable的约定>2.2 <code>CopyAssignable</code>的约定</a></li>
<li><a href=#23-内存重新分配的方式>2.3 内存重新分配的方式</a></li>
</ol>
</li>
<li><a href=#3-比较三个容器vectormaplist>3. 比较三个容器：<code>vector</code>,<code>map</code>,<code>list</code></a>
<ol>
<li><a href=#31-迭代器>3.1 迭代器</a></li>
<li><a href=#32-内存布局和访问效率>3.2 内存布局和访问效率</a></li>
<li><a href=#33-使用上下文>3.3 使用上下文</a></li>
<li><a href=#34-线程安全性>3.4 线程安全性</a></li>
</ol>
</li>
<li><a href=#4-如何管理内存资源>4. 如何管理内存资源</a>
<ol>
<li><a href=#41-再论-raii>4.1 再论 RAII</a>
<ol>
<li><a href=#411-获取资源失败抛异常>4.1.1 获取资源失败抛异常</a></li>
<li><a href=#412-析构绝不抛异常>4.1.2 析构绝不抛异常</a></li>
<li><a href=#423-常见设计>4.2.3 常见设计</a></li>
</ol>
</li>
<li><a href=#42-内存池和对象池>4.2 内存池和对象池</a></li>
</ol>
</li>
<li><a href=#5-玩过哪些游戏对游戏制作流程了解多少>5. 玩过哪些游戏，对游戏制作流程了解多少？</a>
<ol>
<li><a href=#51-陷阱玩过哪些游戏>5.1 陷阱：玩过哪些游戏</a></li>
<li><a href=#52-游戏行业>5.2 游戏行业</a></li>
<li><a href=#53-游戏的制作流程>5.3 游戏的制作流程</a></li>
</ol>
</li>
<li><a href=#6-尾声>6. 尾声</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/blog/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>