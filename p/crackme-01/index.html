<!doctype html><html lang=zh-cn>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="前言 总之得有个前言。从前有个老和尚（不是，掉光了头发的攻城狮），&amp;hellip;&amp;hellip;
以上略，于是作为萌新含量110%的萌新，出于练手、熟悉下反汇编调试的环境之类的目的，还是自己写crackme来把玩吧。
CM01 介绍 于是这个 CrackMe 就叫 CM01 好了，命令行无界面。适合差不多对这些东西懂个大概或者打算学习的萌新：
 反汇编/调试工具 寄存器（主要是 ebp、esp、eip、eax） 函数调用（cdecl） 栈/栈帧 内存模型和寻址  CM01 源码 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt; size_t getline(char **lineptr, size_t *n, FILE *stream) { char *bufptr = NULL; char *p = bufptr; size_t size; int c; if (lineptr == NULL) { return -1; } if (stream == NULL) { return -1; } if (n == NULL) { return -1; } bufptr = *lineptr; size = *n; c = fgetc(stream); if (c == EOF) { return -1; } if (bufptr == NULL) { bufptr = malloc(128); if (bufptr == NULL) { return -1; } size = 128; } p = bufptr; while (c !"><title>自娱自乐 CrackMe-1</title>
<link rel=canonical href=https://nnnewb.github.io/blog/p/crackme-01/>
<link rel=stylesheet href=/blog/scss/style.min.css><meta property="og:title" content="自娱自乐 CrackMe-1">
<meta property="og:description" content="前言 总之得有个前言。从前有个老和尚（不是，掉光了头发的攻城狮），&amp;hellip;&amp;hellip;
以上略，于是作为萌新含量110%的萌新，出于练手、熟悉下反汇编调试的环境之类的目的，还是自己写crackme来把玩吧。
CM01 介绍 于是这个 CrackMe 就叫 CM01 好了，命令行无界面。适合差不多对这些东西懂个大概或者打算学习的萌新：
 反汇编/调试工具 寄存器（主要是 ebp、esp、eip、eax） 函数调用（cdecl） 栈/栈帧 内存模型和寻址  CM01 源码 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt; size_t getline(char **lineptr, size_t *n, FILE *stream) { char *bufptr = NULL; char *p = bufptr; size_t size; int c; if (lineptr == NULL) { return -1; } if (stream == NULL) { return -1; } if (n == NULL) { return -1; } bufptr = *lineptr; size = *n; c = fgetc(stream); if (c == EOF) { return -1; } if (bufptr == NULL) { bufptr = malloc(128); if (bufptr == NULL) { return -1; } size = 128; } p = bufptr; while (c !">
<meta property="og:url" content="https://nnnewb.github.io/blog/p/crackme-01/">
<meta property="og:site_name" content="weakptr's 笔记">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="汇编"><meta property="article:tag" content="逆向"><meta property="article:published_time" content="2021-09-10T09:49:00+08:00"><meta property="article:modified_time" content="2021-09-10T09:49:00+08:00">
<meta name=twitter:title content="自娱自乐 CrackMe-1">
<meta name=twitter:description content="前言 总之得有个前言。从前有个老和尚（不是，掉光了头发的攻城狮），&amp;hellip;&amp;hellip;
以上略，于是作为萌新含量110%的萌新，出于练手、熟悉下反汇编调试的环境之类的目的，还是自己写crackme来把玩吧。
CM01 介绍 于是这个 CrackMe 就叫 CM01 好了，命令行无界面。适合差不多对这些东西懂个大概或者打算学习的萌新：
 反汇编/调试工具 寄存器（主要是 ebp、esp、eip、eax） 函数调用（cdecl） 栈/栈帧 内存模型和寻址  CM01 源码 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt; size_t getline(char **lineptr, size_t *n, FILE *stream) { char *bufptr = NULL; char *p = bufptr; size_t size; int c; if (lineptr == NULL) { return -1; } if (stream == NULL) { return -1; } if (n == NULL) { return -1; } bufptr = *lineptr; size = *n; c = fgetc(stream); if (c == EOF) { return -1; } if (bufptr == NULL) { bufptr = malloc(128); if (bufptr == NULL) { return -1; } size = 128; } p = bufptr; while (c !">
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=https://nnnewb.github.io/blog class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>返回</span>
</a>
</div>
<main class="main full-width">
<article class=main-article>
<header class=article-header>
<div class=article-details>
<header class=article-category>
<a href=/blog/categories/%E9%80%86%E5%90%91/>
逆向
</a>
</header>
<h2 class=article-title>
<a href=/blog/p/crackme-01/>自娱自乐 CrackMe-1</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2021年 9月 10日</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
阅读时长: 3 分钟
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<h2 id=前言>前言</h2>
<p>总之得有个前言。从前有个老和尚（不是，掉光了头发的攻城狮），&mldr;&mldr;</p>
<p>以上略，于是作为萌新含量110%的萌新，出于练手、熟悉下反汇编调试的环境之类的目的，还是自己写crackme来把玩吧。</p>
<h2 id=cm01-介绍>CM01 介绍</h2>
<p>于是这个 CrackMe 就叫 CM01 好了，命令行无界面。适合差不多对这些东西懂个大概或者打算学习的萌新：</p>
<ul>
<li>反汇编/调试工具</li>
<li>寄存器（主要是 ebp、esp、eip、eax）</li>
<li>函数调用（cdecl）</li>
<li>栈/栈帧</li>
<li>内存模型和寻址</li>
</ul>
<h2 id=cm01-源码>CM01 源码</h2>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=n>size_t</span> <span class=nf>getline</span><span class=p>(</span><span class=kt>char</span> <span class=o>**</span><span class=n>lineptr</span><span class=p>,</span> <span class=n>size_t</span> <span class=o>*</span><span class=n>n</span><span class=p>,</span> <span class=n>FILE</span> <span class=o>*</span><span class=n>stream</span><span class=p>)</span> <span class=p>{</span>
  <span class=kt>char</span> <span class=o>*</span><span class=n>bufptr</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
  <span class=kt>char</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>bufptr</span><span class=p>;</span>
  <span class=n>size_t</span> <span class=n>size</span><span class=p>;</span>
  <span class=kt>int</span> <span class=n>c</span><span class=p>;</span>

  <span class=k>if</span> <span class=p>(</span><span class=n>lineptr</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>stream</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=n>bufptr</span> <span class=o>=</span> <span class=o>*</span><span class=n>lineptr</span><span class=p>;</span>
  <span class=n>size</span> <span class=o>=</span> <span class=o>*</span><span class=n>n</span><span class=p>;</span>

  <span class=n>c</span> <span class=o>=</span> <span class=n>fgetc</span><span class=p>(</span><span class=n>stream</span><span class=p>);</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>c</span> <span class=o>==</span> <span class=n>EOF</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>bufptr</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>bufptr</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>128</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>bufptr</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>size</span> <span class=o>=</span> <span class=mi>128</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=n>p</span> <span class=o>=</span> <span class=n>bufptr</span><span class=p>;</span>
  <span class=k>while</span> <span class=p>(</span><span class=n>c</span> <span class=o>!=</span> <span class=n>EOF</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>((</span><span class=n>p</span> <span class=o>-</span> <span class=n>bufptr</span><span class=p>)</span> <span class=o>&gt;</span> <span class=p>(</span><span class=n>size</span> <span class=o>-</span> <span class=mi>1</span><span class=p>))</span> <span class=p>{</span>
      <span class=n>size</span> <span class=o>=</span> <span class=n>size</span> <span class=o>+</span> <span class=mi>128</span><span class=p>;</span>
      <span class=n>bufptr</span> <span class=o>=</span> <span class=n>realloc</span><span class=p>(</span><span class=n>bufptr</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
      <span class=k>if</span> <span class=p>(</span><span class=n>bufptr</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
      <span class=p>}</span>
    <span class=p>}</span>
    <span class=o>*</span><span class=n>p</span><span class=o>++</span> <span class=o>=</span> <span class=n>c</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>c</span> <span class=o>==</span> <span class=sc>&#39;\n&#39;</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>c</span> <span class=o>=</span> <span class=n>fgetc</span><span class=p>(</span><span class=n>stream</span><span class=p>);</span>
  <span class=p>}</span>

  <span class=o>*</span><span class=n>p</span><span class=o>++</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
  <span class=o>*</span><span class=n>lineptr</span> <span class=o>=</span> <span class=n>bufptr</span><span class=p>;</span>
  <span class=o>*</span><span class=n>n</span> <span class=o>=</span> <span class=n>size</span><span class=p>;</span>

  <span class=k>return</span> <span class=n>p</span> <span class=o>-</span> <span class=n>bufptr</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pwd</span> <span class=o>=</span> <span class=s>&#34;secret&#34;</span><span class=p>;</span>
  <span class=kt>char</span> <span class=o>*</span><span class=n>line</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
  <span class=n>size_t</span> <span class=n>len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  <span class=kt>long</span> <span class=kt>int</span> <span class=n>linesize</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

  <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;password:&#34;</span><span class=p>);</span>
    <span class=n>linesize</span> <span class=o>=</span> <span class=n>getline</span><span class=p>(</span><span class=o>&amp;</span><span class=n>line</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>,</span> <span class=n>stdin</span><span class=p>);</span>
    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=n>strncmp</span><span class=p>(</span><span class=n>line</span><span class=p>,</span> <span class=n>pwd</span><span class=p>,</span> <span class=mi>6</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>rc</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Good job!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
      <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;wrong pwd!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>编译工具链：</p>
<ul>
<li>因为VC++对单纯C的支持比较垃圾，所以用LLVM（Clang）-12.0.1，Clang</li>
</ul>
<p>编译指令</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell>clang cm01.c -o cm01-easy.exe -m32 -O0
clang cm01.c -o cm01-normal.exe -m32 -O1
clang cm01.c -o cm01-hard.exe -m32 -O2
</code></pre></div><h2 id=观察>观察</h2>
<p>假装没看到源码，先观察下程序的行为，确定目标。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain>weakptr in assembly-play ❯ .\cm01-easy.exe
password:password?
wrong pwd!
password:asdf
wrong pwd!
password:wrong pwd!
password:
</code></pre></div><p>一个 <em>password:</em> 提示符，随便输入了点什么会提示 <em>wrong pwd!</em> 。</p>
<p>确定目标是找出正确的密码。</p>
<h2 id=静态分析>静态分析</h2>
<h3 id=思路>思路</h3>
<p>在逆向中有个说法叫*“关键跳转”*，如分析固定密码，字符串比较后跳转成功或跳转失败就是关键跳。对于简单的问题，找到关键跳即可破局。</p>
<h3 id=反汇编---easy>反汇编 - Easy</h3>
<p>Easy难度下，<code>-O0</code>参数关闭了编译器优化，生成的汇编代码非常死板，基本能直接对照到C源码上。</p>
<p>直接拿IDA打开。</p>
<p><img src=/blog/image/crackme-01/cm01-easy-1.png alt=image-20210912172521751></p>
<p>直接跳到了<code>main</code>函数。接着看IDA汇编窗口中的的细节。</p>
<p><img src=/blog/image/crackme-01/cm01-easy-2.png alt=image-20210912173539972></p>
<p>IDA反汇编界面是包含一些伪代码的，有助于分析。</p>
<p>左侧有长条和箭头的部分是控制流示意，箭头指的就是跳转方向。</p>
<p>越过伪代码的部分，就能看到函数体开头例行公事的部分了。随后的便是函数体代码。</p>
<p>具体看函数体前，先了解下IDA还提供了另一种控制流可视化的视图，可以极大帮助对函数逻辑的分析。</p>
<p>在汇编视图里右键，选择 Graph View，即可进入控制流视图。</p>
<p><img src=/blog/image/crackme-01/cm01-easy-3.png alt=image-20210912174233891></p>
<p>在图片左下角的是视图的全览，原本的汇编文本变成了图中箭头连接的小汇编代码块，箭头指示了跳转的方向。</p>
<p>在这个视图可以很清楚地看到所谓的关键跳：</p>
<p><img src=/blog/image/crackme-01/cm01-easy-4.png alt=image-20210912174738919></p>
<p><code>_strncmp</code>是经过了 name mangling 的 c 标准库函数<code>strncmp</code>，函数如名字所示，用途就是比较字符串。</p>
<p>又根据<code>cdecl</code>调用约定，函数参数通过栈传递，参数从右往左压栈。我们看这个<code>call</code>指令前的三句<code>mov</code>。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=nf>mov</span>     <span class=p>[</span><span class=no>esp</span><span class=err>+</span><span class=mi>24</span><span class=no>h</span><span class=err>+</span><span class=no>Ix</span><span class=p>],</span> <span class=no>ecx</span> <span class=c>; Str1
</span><span class=c></span><span class=no>mov</span>     <span class=p>[</span><span class=no>esp</span><span class=err>+</span><span class=mi>24</span><span class=no>h</span><span class=err>+</span><span class=no>Str2</span><span class=p>],</span> <span class=no>eax</span> <span class=c>; Str2
</span><span class=c></span><span class=no>mov</span>     <span class=p>[</span><span class=no>esp</span><span class=err>+</span><span class=mi>24</span><span class=no>h</span><span class=err>+</span><span class=no>MaxCount</span><span class=p>],</span> <span class=mi>6</span> <span class=c>; MaxCount
</span></code></pre></div><p>需要注意的是没有用<code>push</code>指令，所以三个<code>mov</code>在栈上的顺序要根据偏移算。我们偷个懒直接看<code>strncmp</code>函数的签名就行，IDA也分析出了压栈的地址在注释里。往上看，看看<code>ecx</code>和<code>eax</code>又是哪儿来的。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=nf>mov</span>     <span class=no>eax</span><span class=p>,</span> <span class=p>[</span><span class=no>ebp</span><span class=err>+</span><span class=no>var_8</span><span class=p>]</span>
<span class=nf>mov</span>     <span class=no>ecx</span><span class=p>,</span> <span class=p>[</span><span class=no>ebp</span><span class=err>+</span><span class=no>Str1</span><span class=p>]</span>
</code></pre></div><p>再看<code>ebp+var_8</code>和<code>ebp+str1</code>又是什么。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=nf>lea</span>     <span class=no>eax</span><span class=p>,</span> <span class=no>aSecret</span>    <span class=c>; &#34;secret&#34;
</span><span class=c></span><span class=no>mov</span>     <span class=p>[</span><span class=no>ebp</span><span class=err>+</span><span class=no>var_8</span><span class=p>],</span> <span class=no>eax</span>
</code></pre></div><p>所以有一个参数是字符串 <code>"secret"</code>，作为关键跳前 <code>_strncmp</code> 的参数。</p>
<p>让我们尝试一下。</p>
<p><img src=/blog/image/crackme-01/cm01-easy-7.png alt=image-20210912181959230></p>
<p>成功完成。</p>
<h3 id=反汇编---normal>反汇编 - Normal</h3>
<p>接下来看使用<code>-O1</code>编译，开启了部分编译器优化的版本。</p>
<p><img src=/blog/image/crackme-01/cm01-normal-1.png alt=image-20210912183427553></p>
<p>可以看到，因为编译器优化的缘故，原本清晰的分支变成了一个仅有一个循环。</p>
<p>还是先找到关键跳，肉眼过一遍循环中的函数调用，<code>sub_401180</code>从参数看应该是一个往终端打印字符串的函数，忽略。<code>___acrt_iob_func</code>意义不明也忽略。下一个<code>sub_401000</code>依然有点意义不明，先跳过。再往下就看到了老熟人了，<code>_strncmp</code>，<code>"secret"</code>参数更是直接用一个push给压栈了，分析到此结束？</p>
<p>不过还有一个问题没解决：失败的提示我们看到了，成功的跳转在哪儿呢？</p>
<p>从<code>call _strncmp</code>开始往下看。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=nf>call</span>    <span class=no>_strncmp</span> <span class=c>; 调用，cdecl约定下，返回值在 eax
</span><span class=c></span><span class=no>add</span>     <span class=no>esp</span><span class=p>,</span> <span class=mi>0</span><span class=no>Ch</span> <span class=c>; 清栈
</span><span class=c></span><span class=no>mov</span>     <span class=no>esi</span><span class=p>,</span> <span class=no>eax</span> <span class=c>; 函数返回值存入 esi
</span><span class=c></span><span class=no>test</span>    <span class=no>eax</span><span class=p>,</span> <span class=no>eax</span> <span class=c>; TEST 指令把操作数按位与并设置标志位，如果 eax 是 0 则 ZF 会设置成 1，否则就是 0。
</span><span class=c></span><span class=no>mov</span>     <span class=no>eax</span><span class=p>,</span> <span class=no>offset</span> <span class=no>aWrongPwd</span> <span class=c>; eax = &#34;wrong pwd!\n&#34;
</span><span class=c>; ebp 被设置为了字符串 &#34;Good job!\n&#34;
</span><span class=c>; cmovz 或者说 cmov* 系列的函数用后缀的单个字符表示用哪个标志位来决定是否mov，比如cmovz就是用ZF标志位决定是否执行mov。
</span><span class=c></span><span class=no>cmovz</span>   <span class=no>eax</span><span class=p>,</span> <span class=no>ebp</span> 
<span class=no>push</span>    <span class=no>eax</span> <span class=c>; 如果 strncmp 返回 0 则是 Good job!\n ，反则 wrong pwd!\n
</span><span class=c></span><span class=no>call</span>    <span class=no>sub_401180</span> <span class=c>; 调用一个输出字符串的函数
</span></code></pre></div><p>用伪代码来表示，就是</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Good job!</span><span class=se>\n</span><span class=s2>&#34;</span> <span class=k>if</span> <span class=n>compare_result</span> <span class=o>==</span> <span class=mi>0</span> <span class=k>else</span> <span class=s2>&#34;wrong pwd!</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</code></pre></div><h3 id=反汇编---hard>反汇编 - Hard</h3>
<p>Hard启用了<code>-O2</code>，也就是开启了大部分编译器优化。用IDA打开。</p>
<p><img src=/blog/image/crackme-01/cm01-hard-1.png alt=image-20210912185949657></p>
<p>因为编译器十分聪明地把一些函数给内联编译进了 main 函数，现在 main 函数的控制流已经乱的一批。挨个读下去虽然还可行，但实在费神费力。</p>
<p>不过在这个条件下依然还有解决办法：我们可以通过错误或成功的提示字符串找关键跳。</p>
<p>已知错误时会输出"wrong pwd!"，我们在IDA找到字符串视图。</p>
<p><img src=/blog/image/crackme-01/cm01-hard-2.png alt=image-20210912190657661></p>
<p>然后在视图中找到字符串。</p>
<p><img src=/blog/image/crackme-01/cm01-hard-3.png alt=image-20210912190827657></p>
<p>其实就是在内存数据段（Data Segment）或者PE的数据节（Data Section）中的字符串啦，一般手写的字符串字面量都会直接编译到这里。</p>
<p>在我们要找的字符串上双击，就会跳到汇编视图中的字符串位置。</p>
<p><img src=/blog/image/crackme-01/cm01-hard-4.png alt=image-20210912191125747></p>
<p>然后再双击图中位置。</p>
<p><img src=/blog/image/crackme-01/cm01-hard-5.png alt=image-20210912191344967></p>
<p>即可跳转到引用。</p>
<p><img src=/blog/image/crackme-01/cm01-hard-6.png alt=image-20210912191435672></p>
<p>接着看跳转到的上下文，又变成了十分熟悉的正确错误分支。往前找到 <code>_strncmp</code>的参数。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=nf>push</span>    <span class=mi>6</span>
<span class=nf>push</span>    <span class=no>offset</span> <span class=no>Str2</span>     <span class=c>; &#34;secret&#34;
</span><span class=c></span><span class=no>push</span>    <span class=no>edx</span>             <span class=c>; Str1
</span><span class=c></span><span class=no>mov</span>     <span class=no>ebp</span><span class=p>,</span> <span class=no>edx</span>
<span class=nf>call</span>    <span class=no>_strncmp</span>
</code></pre></div><p>也就是 <code>strncmp(edx,"secret",6)</code>，密钥就是 <code>"secret"</code>没错了。</p>
<h2 id=总结>总结</h2>
<p>这个 CrackMe （以后也许还有）的主要用途是学习逆向和汇编的基础知识，巩固记忆，学习和熟悉工具。所以尽可能去除干扰项，只保留想要巩固学习的部分，看起来很傻，基本没啥挑战性。</p>
<p>有些公共的前置知识（比如寄存器和栈，调用约定，内存模型）我做了个笔记，大概是入不了大佬的眼的。可以在[这里](<a class=link href=https://nnnewb.github.io/blog/p/assembly-learning-note/ target=_blank rel=noopener>32位 Windows x86 汇编语言学习 (nnnewb.github.io)</a>)看看。</p>
<p>目前能找到很多 Delphi 和 VB 编写的 CrackMe，Delphi 现在搜搜还能看到些 <em>Delphi still alive</em> 的文章，不过确实比较少见了吧。提到学 GUI 编程，不是推荐 C++/Qt 就是 .Net 全家桶。VB 更是早已完蛋（不是VB.Net），老实说这些 CrackMe 不知道转了几手，还能玩是还能玩，虽然但是吧，总之对我还是略难，看别人的 CrackMe 题解也挺迷茫。</p>
<p>不过自己会编程就好了嘛！</p>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/blog/tags/%E6%B1%87%E7%BC%96/>汇编</a>
<a href=/blog/tags/%E9%80%86%E5%90%91/>逆向</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
</footer>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>相关文章</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article>
<a href=/blog/p/learning-packer-08/>
<div class=article-details>
<h2 class=article-title>加壳原理08：混淆技术入门</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/learning-packer-07/>
<div class=article-details>
<h2 class=article-title>加壳原理07 - 花指令入门</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/learning-packer-06/>
<div class=article-details>
<h2 class=article-title>加壳原理06：反调试技术入门</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/learning-packer-04-zlib-compression-packer-demo/>
<div class=article-details>
<h2 class=article-title>加壳原理04 - zlib压缩壳案例</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/learning-packer-03-support-no-relocations/>
<div class=article-details>
<h2 class=article-title>加壳原理03 - 支持没有重定位的程序</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class=site-footer>
<section class=copyright>
&copy;
2021 weakptr's 笔记
</section>
<section class=powerby>
GitHub Pages <br>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.1.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">目录</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#前言>前言</a></li>
<li><a href=#cm01-介绍>CM01 介绍</a></li>
<li><a href=#cm01-源码>CM01 源码</a></li>
<li><a href=#观察>观察</a></li>
<li><a href=#静态分析>静态分析</a>
<ol>
<li><a href=#思路>思路</a></li>
<li><a href=#反汇编---easy>反汇编 - Easy</a></li>
<li><a href=#反汇编---normal>反汇编 - Normal</a></li>
<li><a href=#反汇编---hard>反汇编 - Hard</a></li>
</ol>
</li>
<li><a href=#总结>总结</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/blog/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>