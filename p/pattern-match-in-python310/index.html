<!doctype html><html lang=zh-cn>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="说明 简单机翻润色一下 PEP-636
概要 这个PEP是PEP 634引入的模式匹配教程。
PEP 622提出了模式匹配的语法，社区和指导委员会对此进行了详细讨论。一个常见的问题是解释(和学习)这个特性是否容易。这个PEP关注的是提供开发人员可以用来学习Python中的模式匹配的文档类型。
PEP 636 被认为是PEP 634(模式匹配的技术规范)和PEP 635(模式匹配的添加动机和理由与设计考虑)的支持材料。
对于想要快速回顾而不是教程的读者，请参阅附录a。
教程 作为本教程的一个例子，你将编写一个文本冒险游戏。这是一种互动小说形式，用户输入文本命令与虚构世界进行互动，并接收关于所发生事情的文本描述。命令将是简化形式的自然语言，如get sword，attack dragon，go north，enter shop或but cheese。
匹配序列 你的主循环将需要从用户那里获取输入，并将它分割成单词，例如一个像这样的字符串列表:
command = input(&amp;#34;What are you doing next? &amp;#34;) # analyze the result of command.split() 下一步是解读这些单词。我们的大多数命令都有两个词:一个动作和一个对象。所以你可能会忍不住这样做:
[action, obj] = command.split() ... # interpret action, obj 这行代码的问题在于它遗漏了一些东西：如果用户输入的单词多于或少于2个单词怎么办?为了防止这个问题，您可以检查单词列表的长度，或者捕获上面的语句将引发的ValueError。
或者，你可以使用match语句来代替:
match command.split(): case [action, obj]: ... # interpret action, obj match语句计算**“subject”**(match关键字后面的值)，并根据模式(case旁边的代码)检查它。一个模式可以做两件不同的事情:
 验证 subject 具有一定的结构。在您的示例中，[action, obj]模式匹配任何恰好包含两个元素的序列。这叫做 maching。 它将模式中的一些名称绑定到 subject 的组件元素。在本例中，如果列表有两个元素，它将绑定action = subject[0]和obj = subject[1]。  如果匹配，则case块内的语句将与绑定的变量一起执行。如果没有匹配，则什么也不发生，然后执行match之后的语句。"><title>pattern-match-in-python310</title>
<link rel=canonical href=https://nnnewb.github.io/blog/p/pattern-match-in-python310/>
<link rel=stylesheet href=/blog/scss/style.min.css><meta property="og:title" content="pattern-match-in-python310">
<meta property="og:description" content="说明 简单机翻润色一下 PEP-636
概要 这个PEP是PEP 634引入的模式匹配教程。
PEP 622提出了模式匹配的语法，社区和指导委员会对此进行了详细讨论。一个常见的问题是解释(和学习)这个特性是否容易。这个PEP关注的是提供开发人员可以用来学习Python中的模式匹配的文档类型。
PEP 636 被认为是PEP 634(模式匹配的技术规范)和PEP 635(模式匹配的添加动机和理由与设计考虑)的支持材料。
对于想要快速回顾而不是教程的读者，请参阅附录a。
教程 作为本教程的一个例子，你将编写一个文本冒险游戏。这是一种互动小说形式，用户输入文本命令与虚构世界进行互动，并接收关于所发生事情的文本描述。命令将是简化形式的自然语言，如get sword，attack dragon，go north，enter shop或but cheese。
匹配序列 你的主循环将需要从用户那里获取输入，并将它分割成单词，例如一个像这样的字符串列表:
command = input(&amp;#34;What are you doing next? &amp;#34;) # analyze the result of command.split() 下一步是解读这些单词。我们的大多数命令都有两个词:一个动作和一个对象。所以你可能会忍不住这样做:
[action, obj] = command.split() ... # interpret action, obj 这行代码的问题在于它遗漏了一些东西：如果用户输入的单词多于或少于2个单词怎么办?为了防止这个问题，您可以检查单词列表的长度，或者捕获上面的语句将引发的ValueError。
或者，你可以使用match语句来代替:
match command.split(): case [action, obj]: ... # interpret action, obj match语句计算**“subject”**(match关键字后面的值)，并根据模式(case旁边的代码)检查它。一个模式可以做两件不同的事情:
 验证 subject 具有一定的结构。在您的示例中，[action, obj]模式匹配任何恰好包含两个元素的序列。这叫做 maching。 它将模式中的一些名称绑定到 subject 的组件元素。在本例中，如果列表有两个元素，它将绑定action = subject[0]和obj = subject[1]。  如果匹配，则case块内的语句将与绑定的变量一起执行。如果没有匹配，则什么也不发生，然后执行match之后的语句。">
<meta property="og:url" content="https://nnnewb.github.io/blog/p/pattern-match-in-python310/">
<meta property="og:site_name" content="weakptr's 笔记">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="python"><meta property="article:published_time" content="2021-03-19T10:19:06+08:00"><meta property="article:modified_time" content="2021-03-19T10:19:06+08:00">
<meta name=twitter:title content="pattern-match-in-python310">
<meta name=twitter:description content="说明 简单机翻润色一下 PEP-636
概要 这个PEP是PEP 634引入的模式匹配教程。
PEP 622提出了模式匹配的语法，社区和指导委员会对此进行了详细讨论。一个常见的问题是解释(和学习)这个特性是否容易。这个PEP关注的是提供开发人员可以用来学习Python中的模式匹配的文档类型。
PEP 636 被认为是PEP 634(模式匹配的技术规范)和PEP 635(模式匹配的添加动机和理由与设计考虑)的支持材料。
对于想要快速回顾而不是教程的读者，请参阅附录a。
教程 作为本教程的一个例子，你将编写一个文本冒险游戏。这是一种互动小说形式，用户输入文本命令与虚构世界进行互动，并接收关于所发生事情的文本描述。命令将是简化形式的自然语言，如get sword，attack dragon，go north，enter shop或but cheese。
匹配序列 你的主循环将需要从用户那里获取输入，并将它分割成单词，例如一个像这样的字符串列表:
command = input(&amp;#34;What are you doing next? &amp;#34;) # analyze the result of command.split() 下一步是解读这些单词。我们的大多数命令都有两个词:一个动作和一个对象。所以你可能会忍不住这样做:
[action, obj] = command.split() ... # interpret action, obj 这行代码的问题在于它遗漏了一些东西：如果用户输入的单词多于或少于2个单词怎么办?为了防止这个问题，您可以检查单词列表的长度，或者捕获上面的语句将引发的ValueError。
或者，你可以使用match语句来代替:
match command.split(): case [action, obj]: ... # interpret action, obj match语句计算**“subject”**(match关键字后面的值)，并根据模式(case旁边的代码)检查它。一个模式可以做两件不同的事情:
 验证 subject 具有一定的结构。在您的示例中，[action, obj]模式匹配任何恰好包含两个元素的序列。这叫做 maching。 它将模式中的一些名称绑定到 subject 的组件元素。在本例中，如果列表有两个元素，它将绑定action = subject[0]和obj = subject[1]。  如果匹配，则case块内的语句将与绑定的变量一起执行。如果没有匹配，则什么也不发生，然后执行match之后的语句。">
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"dark")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=/blog class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>返回</span>
</a>
</div>
<main class="main full-width">
<article class=main-article>
<header class=article-header>
<div class=article-details>
<header class=article-category>
<a href=/blog/categories/python/>
python
</a>
</header>
<h2 class=article-title>
<a href=/blog/p/pattern-match-in-python310/>pattern-match-in-python310</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2021年 3月 19日</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
阅读时长: 5 分钟
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<h2 id=说明>说明</h2>
<p>简单机翻润色一下 PEP-636</p>
<h2 id=概要>概要</h2>
<p>这个PEP是PEP 634引入的模式匹配教程。</p>
<p>PEP 622提出了模式匹配的语法，社区和指导委员会对此进行了详细讨论。一个常见的问题是解释(和学习)这个特性是否容易。这个PEP关注的是提供开发人员可以用来学习Python中的模式匹配的文档类型。</p>
<p>PEP 636 被认为是PEP 634(模式匹配的技术规范)和PEP 635(模式匹配的添加动机和理由与设计考虑)的支持材料。</p>
<p>对于想要快速回顾而不是教程的读者，请参阅附录a。</p>
<h2 id=教程>教程</h2>
<p>作为本教程的一个例子，你将编写一个文本冒险游戏。这是一种互动小说形式，用户输入文本命令与虚构世界进行互动，并接收关于所发生事情的文本描述。命令将是简化形式的自然语言，如<code>get sword</code>，<code>attack dragon</code>，<code>go north</code>，<code>enter shop</code>或<code>but cheese</code>。</p>
<h3 id=匹配序列>匹配序列</h3>
<p>你的主循环将需要从用户那里获取输入，并将它分割成单词，例如一个像这样的字符串列表:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>command</span> <span class=o>=</span> <span class=nb>input</span><span class=p>(</span><span class=s2>&#34;What are you doing next? &#34;</span><span class=p>)</span>
<span class=c1># analyze the result of command.split()</span>
</code></pre></div><p>下一步是解读这些单词。我们的大多数命令都有两个词:一个动作和一个对象。所以你可能会忍不住这样做:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=p>[</span><span class=n>action</span><span class=p>,</span> <span class=n>obj</span><span class=p>]</span> <span class=o>=</span> <span class=n>command</span><span class=o>.</span><span class=n>split</span><span class=p>()</span>
<span class=o>...</span> <span class=c1># interpret action, obj</span>
</code></pre></div><p>这行代码的问题在于它遗漏了一些东西：如果用户输入的单词多于或少于2个单词怎么办?为了防止这个问题，您可以检查单词列表的长度，或者捕获上面的语句将引发的<code>ValueError</code>。</p>
<p>或者，你可以使用<code>match</code>语句来代替:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>match</span> <span class=n>command</span><span class=o>.</span><span class=n>split</span><span class=p>():</span>
    <span class=n>case</span> <span class=p>[</span><span class=n>action</span><span class=p>,</span> <span class=n>obj</span><span class=p>]:</span>
        <span class=o>...</span> <span class=c1># interpret action, obj</span>
</code></pre></div><p><code>match</code>语句计算**“subject”**(<code>match</code>关键字后面的值)，并根据模式(<code>case</code>旁边的代码)检查它。一个模式可以做两件不同的事情:</p>
<ul>
<li>验证 subject 具有一定的结构。在您的示例中，<code>[action, obj]</code>模式匹配任何恰好包含两个元素的序列。这叫做 <strong>maching</strong>。</li>
<li>它将模式中的一些名称绑定到 subject 的组件元素。在本例中，如果列表有两个元素，它将绑定<code>action = subject[0]</code>和<code>obj = subject[1]</code>。</li>
</ul>
<p>如果匹配，则<code>case</code>块内的语句将与绑定的变量一起执行。如果没有匹配，则什么也不发生，然后执行<code>match</code>之后的语句。</p>
<p>注意，与解包赋值(unpacking assignments)的方式类似，您可以使用圆括号、方括号或逗号分隔，它们含义相同。所以你可以写<code>case action, obj</code>或者<code>case (action, obj)</code>。上述任意形式都将匹配序列类型(例如<code>list</code>或<code>tuple</code>)。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=c1># 译者补充，下述case等效</span>
<span class=n>match</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>]:</span> <span class=c1># match (1,2,3) 也一样</span>
    <span class=n>case</span> <span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>,</span><span class=n>c</span><span class=p>:</span>
        <span class=o>...</span>
    <span class=n>case</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>,</span><span class=n>c</span><span class=p>):</span>
        <span class=o>...</span>
    <span class=n>case</span> <span class=p>[</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>,</span><span class=n>c</span><span class=p>]:</span>
        <span class=o>...</span>
</code></pre></div><h3 id=匹配多个模式>匹配多个模式</h3>
<p>即使大多数命令都是动作/对象形式，你也可能想要不同长度的用户命令。例如，你可能希望添加没有对象(如<code>look</code>或<code>quit</code>)的单个动词。一个<code>match</code>语句可以(而且很可能)有不止一种情况:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>match</span> <span class=n>command</span><span class=o>.</span><span class=n>split</span><span class=p>():</span>
    <span class=n>case</span> <span class=p>[</span><span class=n>action</span><span class=p>]:</span>
        <span class=o>...</span> <span class=c1># interpret single-verb action</span>
    <span class=n>case</span> <span class=p>[</span><span class=n>action</span><span class=p>,</span> <span class=n>obj</span><span class=p>]:</span>
        <span class=o>...</span> <span class=c1># interpret action, obj</span>
</code></pre></div><p><code>match</code>语句将从上到下检查模式。如果模式与 subject 不匹配，将尝试下一个模式。但是，一旦找到第一个匹配的模式，就会执行该<code>case</code>的主体，并忽略所有后续的<code>case</code>。这类似于<code>if</code>/<code>elif</code>/<code>elif</code>/…语句的工作方式。</p>
<h3 id=匹配特定值>匹配特定值</h3>
<p>你的代码仍然需要查看特定的操作，并根据特定的操作有条件地执行不同的逻辑(例如，<code>quit</code>、<code>attack</code>或<code>buy</code>)。你可以使用<code>if</code>/<code>elif</code>/<code>elif</code>/…，或者使用函数字典，但是这里我们将利用模式匹配来解决这个任务。除了变量，你可以在模式中使用字面值(如<code>"quit"</code>、<code>42</code>或<code>None</code>)。这允许你这样写:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>match</span> <span class=n>command</span><span class=o>.</span><span class=n>split</span><span class=p>():</span>
    <span class=n>case</span> <span class=p>[</span><span class=s2>&#34;quit&#34;</span><span class=p>]:</span>
        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Goodbye!&#34;</span><span class=p>)</span>
        <span class=n>quit_game</span><span class=p>()</span>
    <span class=n>case</span> <span class=p>[</span><span class=s2>&#34;look&#34;</span><span class=p>]:</span>
        <span class=n>current_room</span><span class=o>.</span><span class=n>describe</span><span class=p>()</span>
    <span class=n>case</span> <span class=p>[</span><span class=s2>&#34;get&#34;</span><span class=p>,</span> <span class=n>obj</span><span class=p>]:</span>
        <span class=n>character</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=n>current_room</span><span class=p>)</span>
    <span class=n>case</span> <span class=p>[</span><span class=s2>&#34;go&#34;</span><span class=p>,</span> <span class=n>direction</span><span class=p>]:</span>
        <span class=n>current_room</span> <span class=o>=</span> <span class=n>current_room</span><span class=o>.</span><span class=n>neighbor</span><span class=p>(</span><span class=n>direction</span><span class=p>)</span>
    <span class=c1># The rest of your commands go here</span>
</code></pre></div><p>像<code>["get"， obj]</code>这样的模式将只匹配第一个元素等于<code>"get"</code>的2个元素的序列。它还将绑定<code>obj = subject[1]</code>。</p>
<p>正如您在上述代码的<code>go</code>模式中看到的，我们还可以在不同的模式中使用不同的变量名。</p>
<p>除了与<code>is</code>操作符比较的常量<code>True</code>、<code>False</code>和<code>None</code>之外，其他字面值是用<code>==</code>操作符比较的。</p>
<h3 id=匹配多个值>匹配多个值</h3>
<p>玩家可以通过使用一系列的命令来投掷多个物品，如:<code>drop key</code>, <code>drop sword</code>, <code>drop cheese</code>。这个接口可能很麻烦，您可能希望允许在一个命令中添加多个项，比如<code>drop key sword cheese</code>。在这种情况下，你事先不知道命令中有多少个单词，但是你可以在模式中使用扩展解包(extended unpacking)，就像它们在解包赋值里的写法:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>match</span> <span class=n>command</span><span class=o>.</span><span class=n>split</span><span class=p>():</span>
    <span class=n>case</span> <span class=p>[</span><span class=s2>&#34;drop&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>objects</span><span class=p>]:</span>
        <span class=k>for</span> <span class=n>obj</span> <span class=ow>in</span> <span class=n>objects</span><span class=p>:</span>
            <span class=n>character</span><span class=o>.</span><span class=n>drop</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=n>current_room</span><span class=p>)</span>
    <span class=c1># The rest of your commands go here</span>
</code></pre></div><p>这将匹配任何以<code>“drop”</code>作为第一个元素的序列。所有剩余的元素都将在一个列表对象中被捕获，该列表对象将绑定到<code>objects</code>变量。</p>
<p>这种语法与序列解包有类似的限制:在一个模式中不能有多个带星号的名称。</p>
<h3 id=添加通配符>添加通配符</h3>
<p>您可能希望打印一条错误消息，说明当所有模式都失败时，无法识别该命令。您可以使用我们刚刚学习的特性，并将<code>case [*ignored_words]</code>作为您的最后一个模式。然而，有一个更简单的方法:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>match</span> <span class=n>command</span><span class=o>.</span><span class=n>split</span><span class=p>():</span>
    <span class=n>case</span> <span class=p>[</span><span class=s2>&#34;quit&#34;</span><span class=p>]:</span> <span class=o>...</span> <span class=c1># Code omitted for brevity</span>
    <span class=n>case</span> <span class=p>[</span><span class=s2>&#34;go&#34;</span><span class=p>,</span> <span class=n>direction</span><span class=p>]:</span> <span class=o>...</span>
    <span class=n>case</span> <span class=p>[</span><span class=s2>&#34;drop&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>objects</span><span class=p>]:</span> <span class=o>...</span>
    <span class=o>...</span> <span class=c1># Other cases</span>
    <span class=n>case</span> <span class=n>_</span><span class=p>:</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Sorry, I couldn&#39;t understand </span><span class=si>{</span><span class=n>command</span><span class=si>!r}</span><span class=s2>&#34;</span><span class=p>)</span>
</code></pre></div><p>这个特殊的模式被写成<code>_</code>(称为通配符)。不管 subject 是什么它总是能匹配到，但它不绑定任何变量。</p>
<p>注意，这将匹配任何对象，而不仅仅是序列。因此，只有将它单独作为最后一个模式才有意义(为了防止错误，Python会阻止您在其他<code>case</code>之前使用它)。</p>
<h3 id=模式组合>模式组合</h3>
<p>这是一个很好的时机，可以从示例中退后一步，了解您一直在使用的模式是如何构建的。模式可以相互嵌套，我们已经在上面的例子中隐式地这样做了。</p>
<p>我们已经看到了一些“简单”模式(这里的“简单”意味着它们不包含其他模式):</p>
<ul>
<li>捕获模式 Capture patterns (独立名称，如方向、动作、对象)。我们从未单独讨论过这些，而是将它们作为其他模式的一部分使用。</li>
<li>字面值模式 Literal patterns (字符串字面值、数字字面值、<code>True</code>、<code>False</code>和<code>None</code>)</li>
<li>通配符模式 Wildcard pattern <code>_</code></li>
</ul>
<p>到目前为止，我们实验过的唯一一个非简单模式是序列模式。序列模式中的每个元素实际上都可以是任何其他模式。这意味着您可以编写像<code>["first"， (left, right)， _， *rest]</code>这样的模式。匹配的 subject 是一个至少包含三个元素的序列，其中第一个元素等于<code>"first"</code>，第二个元素依次是两个元素的序列。它也会绑定<code>left=subject[1][0]</code>， <code>right=subject[1][1]</code>，<code>rest =subject[3:]</code></p>
<h3 id=or-模式>or 模式</h3>
<p>回到冒险游戏的例子中，你可能会发现你想要一些导致相同结果的模式。例如，您可能希望命令<code>north</code>和<code>go north</code>相等。您可能还希望为<code>get X</code>可以有一些别名如<code>pick x up</code>和<code>pick up x</code>。</p>
<p>模式中的|符号将它们组合为可选项。你可以这样写:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>match</span> <span class=n>command</span><span class=o>.</span><span class=n>split</span><span class=p>():</span>
    <span class=o>...</span> <span class=c1># Other cases</span>
    <span class=n>case</span> <span class=p>[</span><span class=s2>&#34;north&#34;</span><span class=p>]</span> <span class=o>|</span> <span class=p>[</span><span class=s2>&#34;go&#34;</span><span class=p>,</span> <span class=s2>&#34;north&#34;</span><span class=p>]:</span>
        <span class=n>current_room</span> <span class=o>=</span> <span class=n>current_room</span><span class=o>.</span><span class=n>neighbor</span><span class=p>(</span><span class=s2>&#34;north&#34;</span><span class=p>)</span>
    <span class=n>case</span> <span class=p>[</span><span class=s2>&#34;get&#34;</span><span class=p>,</span> <span class=n>obj</span><span class=p>]</span> <span class=o>|</span> <span class=p>[</span><span class=s2>&#34;pick&#34;</span><span class=p>,</span> <span class=s2>&#34;up&#34;</span><span class=p>,</span> <span class=n>obj</span><span class=p>]</span> <span class=o>|</span> <span class=p>[</span><span class=s2>&#34;pick&#34;</span><span class=p>,</span> <span class=n>obj</span><span class=p>,</span> <span class=s2>&#34;up&#34;</span><span class=p>]:</span>
        <span class=o>...</span> <span class=c1># Code for picking up the given object</span>
</code></pre></div><p>这被称为<strong>or模式</strong>，并将产生预期的结果。模式从左到右尝试；如果有多个可选匹配，通过从左至右这一规则可以知道是匹配到了哪个模式。在编写or模式时，一个重要的限制是所有备选项都应该绑定相同的变量。所以模式<code>[1,x] | [2, y]</code>是不允许的，因为它会使匹配成功后绑定哪个变量变得不清楚。<code>[1, x] | [2, x]</code>非常好，如果成功，将始终绑定<code>x</code>。</p>
<h3 id=捕获匹配的子模式>捕获匹配的子模式</h3>
<p>我们的<code>“go”</code>命令的第一个版本是用<code>[“go”，direction]</code>模式编写的。我们在上一个版本中使用模式<code>["north"] | ["go"， "north"]</code>所做的改变有一些好处，但也有一些缺点:最新版本允许别名，但也有硬编码的方向别名<code>"north"</code>，这将迫使我们实际上有独立的模式，<code>north</code>/<code>south</code>/<code>east</code>/<code>west</code>。这将导致一些代码重复，但同时我们得到了更好的输入验证，并且如果用户输入的命令是<code>“go figure!”</code>而不是方向，我们将不会进入那个分支。</p>
<p>我们可以试着在两个方面都做到最好(为了简洁，我省略了不使用<code>“go”</code>的别名版本):</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>match</span> <span class=n>command</span><span class=o>.</span><span class=n>split</span><span class=p>():</span>
    <span class=n>case</span> <span class=p>[</span><span class=s2>&#34;go&#34;</span><span class=p>,</span> <span class=p>(</span><span class=s2>&#34;north&#34;</span> <span class=o>|</span> <span class=s2>&#34;south&#34;</span> <span class=o>|</span> <span class=s2>&#34;east&#34;</span> <span class=o>|</span> <span class=s2>&#34;west&#34;</span><span class=p>)]:</span>
        <span class=n>current_room</span> <span class=o>=</span> <span class=n>current_room</span><span class=o>.</span><span class=n>neighbor</span><span class=p>(</span><span class=o>...</span><span class=p>)</span>
        <span class=c1># how do I know which direction to go?</span>
</code></pre></div><p>这段代码是一个单独的分支，它验证<code>“go”</code>之后的单词是否确实是一个方向。但移动玩家的代码需要知道选择了哪一个，但却无法做到这一点。我们需要的是一个行为类似于or模式但同时进行捕获的模式。我们可以使用<strong>as模式</strong>:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>match</span> <span class=n>command</span><span class=o>.</span><span class=n>split</span><span class=p>():</span>
    <span class=n>case</span> <span class=p>[</span><span class=s2>&#34;go&#34;</span><span class=p>,</span> <span class=p>(</span><span class=s2>&#34;north&#34;</span> <span class=o>|</span> <span class=s2>&#34;south&#34;</span> <span class=o>|</span> <span class=s2>&#34;east&#34;</span> <span class=o>|</span> <span class=s2>&#34;west&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>direction</span><span class=p>]:</span>
        <span class=n>current_room</span> <span class=o>=</span> <span class=n>current_room</span><span class=o>.</span><span class=n>neighbor</span><span class=p>(</span><span class=n>direction</span><span class=p>)</span>
</code></pre></div><p>as模式匹配左边的任何模式，同时也将值绑定到名称。</p>
<h3 id=添加条件到模式>添加条件到模式</h3>
<p>我们上面探讨的模式可以做一些强大的数据过滤，但有时您可能希望得到布尔表达式的全部功能。假设您实际上希望只允许<code>“go”</code>命令出现在基于从<code>current_room</code>的可能出口的受限方向集合中。我们可以通过在我们的案例中增加一个 <strong>guard</strong> 来实现这一点。guard 由 if 关键字后跟任意表达式组成:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>match</span> <span class=n>command</span><span class=o>.</span><span class=n>split</span><span class=p>():</span>
    <span class=n>case</span> <span class=p>[</span><span class=s2>&#34;go&#34;</span><span class=p>,</span> <span class=n>direction</span><span class=p>]</span> <span class=k>if</span> <span class=n>direction</span> <span class=ow>in</span> <span class=n>current_room</span><span class=o>.</span><span class=n>exits</span><span class=p>:</span>
        <span class=n>current_room</span> <span class=o>=</span> <span class=n>current_room</span><span class=o>.</span><span class=n>neighbor</span><span class=p>(</span><span class=n>direction</span><span class=p>)</span>
    <span class=n>case</span> <span class=p>[</span><span class=s2>&#34;go&#34;</span><span class=p>,</span> <span class=n>_</span><span class=p>]:</span>
        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Sorry, you can&#39;t go that way&#34;</span><span class=p>)</span>
</code></pre></div><p>guard 不是模式的一部分，而是 case 的一部分。它只在模式匹配，并且所有模式变量都被绑定之后检查(这就是为什么条件可以在上面的例子中使用<code>direction</code>变量)。如果模式匹配且条件为真，则 case body 正常执行。如果模式匹配，但条件为假，<code>match</code>语句继续检查下一个条件，就好像模式没有匹配一样(可能的副作用是已经绑定了一些变量)。</p>
<h3 id=添加ui-匹配对象>添加UI: 匹配对象</h3>
<p>你的冒险游戏正走向成功，你被请求为游戏实现一个图形界面。您所选择的UI工具包允许您编写一个事件循环，您可以通过调用<code>event.get()</code>来获取一个新的事件对象。根据用户的动作，结果对象可以有不同的类型和属性，例如:</p>
<ul>
<li>当用户按下某个键时，将生成<code>KeyPress</code>对象。它有一个<code>key_name</code>属性，其中包含所按键的名称，以及一些有关修饰符的其他属性。</li>
<li>当用户单击鼠标时，将生成一个<code>Click</code>对象。它有一个指针坐标的属性<code>position</code>。</li>
<li>当用户点击游戏窗口的关闭按钮时，会生成一个<code>Quit</code>对象。</li>
</ul>
<p>与其编写多个<code>isinstance()</code>检查，你可以使用模式来识别不同类型的对象，也可以将模式应用到其属性上:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>match</span> <span class=n>event</span><span class=o>.</span><span class=n>get</span><span class=p>():</span>
    <span class=n>case</span> <span class=n>Click</span><span class=p>(</span><span class=n>position</span><span class=o>=</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)):</span>
        <span class=n>handle_click_at</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span>
    <span class=n>case</span> <span class=n>KeyPress</span><span class=p>(</span><span class=n>key_name</span><span class=o>=</span><span class=s2>&#34;Q&#34;</span><span class=p>)</span> <span class=o>|</span> <span class=n>Quit</span><span class=p>():</span>
        <span class=n>game</span><span class=o>.</span><span class=n>quit</span><span class=p>()</span>
    <span class=n>case</span> <span class=n>KeyPress</span><span class=p>(</span><span class=n>key_name</span><span class=o>=</span><span class=s2>&#34;up arrow&#34;</span><span class=p>):</span>
        <span class=n>game</span><span class=o>.</span><span class=n>go_north</span><span class=p>()</span>
    <span class=o>...</span>
    <span class=n>case</span> <span class=n>KeyPress</span><span class=p>():</span>
        <span class=k>pass</span> <span class=c1># Ignore other keystrokes</span>
    <span class=n>case</span> <span class=n>other_event</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Unrecognized event: </span><span class=si>{</span><span class=n>other_event</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</code></pre></div><p>像<code>Click(position=(x, y))</code>这样的模式仅在事件类型是<code>Click</code>类的子类时才匹配。它还要求事件具有一个与<code>(x, y)</code>模式匹配的位置属性。如果匹配，则局部变量<code>x</code>和<code>y</code>将得到期望的值。</p>
<p>像<code>KeyPress()</code>这样不带参数的模式将匹配任何<code>KeyPress</code>类实例的对象。只有在模式中指定的属性才会匹配，其他任何属性都将被忽略。</p>
<h3 id=匹配位置属性>匹配位置属性</h3>
<p>前一节描述了在进行对象匹配时如何匹配命名属性。对于某些对象，可以方便地根据位置描述匹配的参数(特别是当只有几个属性并且它们有“标准”排序时)。如果您正在使用的类是命名元组 <code>namedtuple</code> 或数据类 <code>dataclass</code>，那么您可以按照构造对象时使用的相同顺序来实现这一点。例如，如果上面的UI框架像这样定义它们的类:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>dataclasses</span> <span class=kn>import</span> <span class=n>dataclass</span>

<span class=nd>@dataclass</span>
<span class=k>class</span> <span class=nc>Click</span><span class=p>:</span>
    <span class=n>position</span><span class=p>:</span> <span class=nb>tuple</span>
    <span class=n>button</span><span class=p>:</span> <span class=n>Button</span>
</code></pre></div><p>然后你可以重写你的匹配语句来匹配上面的 subject:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>match</span> <span class=n>event</span><span class=o>.</span><span class=n>get</span><span class=p>():</span>
    <span class=n>case</span> <span class=n>Click</span><span class=p>((</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)):</span>
        <span class=n>handle_click_at</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span>
</code></pre></div><p><code>(x, y)</code>模式将自动匹配<code>position</code>属性，因为模式中的第一个参数对应于数据类定义中的第一个属性。</p>
<p>其他类的属性没有自然的顺序，因此需要在模式中使用显式名称来匹配它们的属性。但是，也可以手动指定属性的顺序，允许位置匹配，就像下面这个替代定义:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=k>class</span> <span class=nc>Click</span><span class=p>:</span>
    <span class=n>__match_args__</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;position&#34;</span><span class=p>,</span> <span class=s2>&#34;button&#34;</span><span class=p>]</span>
    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>position</span><span class=p>,</span> <span class=n>button</span><span class=p>):</span>
        <span class=o>...</span>
</code></pre></div><p><code>__match_args__</code>特殊属性定义了可以在<code>case Click((x,y))</code>等模式中使用的属性的显式顺序。</p>
<h3 id=匹配常量和枚举>匹配常量和枚举</h3>
<p>上面的模式对所有鼠标按钮都一视同仁，但您已经决定只接受鼠标左键单击事件，而忽略其他鼠标按键。在做这一修改时，您注意到<code>button</code>属性被定义为一个<code>Button</code>，这是一个用<code>enum.Enum</code>构建的枚举。实际上，你可以像这样匹配枚举值:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>match</span> <span class=n>event</span><span class=o>.</span><span class=n>get</span><span class=p>():</span>
    <span class=n>case</span> <span class=n>Click</span><span class=p>((</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>),</span> <span class=n>button</span><span class=o>=</span><span class=n>Button</span><span class=o>.</span><span class=n>LEFT</span><span class=p>):</span>  <span class=c1># This is a left click</span>
        <span class=n>handle_click_at</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span>
    <span class=n>case</span> <span class=n>Click</span><span class=p>():</span>
        <span class=k>pass</span>  <span class=c1># ignore other clicks</span>
</code></pre></div><p>这将适用于任何带点的名称(如<code>math.pi</code>)。然而，非限定名称(即没有点的裸名称)将总是被解释为捕获模式，因此在模式中始终使用限定常量可以避免这种歧义。</p>
<h3 id=走进云服务匹配字典>走进云服务：匹配字典</h3>
<p>你决定制作游戏的在线版本。您的所有逻辑都将在服务器中，而客户端中的UI将使用JSON消息进行通信。通过json模块，这些将被映射到Python字典、列表和其他内置对象。</p>
<p>我们的客户端将收到一个字典列表(从JSON解析)，包含了要采取的动作，每个元素的查找示例如下:</p>
<ul>
<li><code>{"text": "The shop keeper says 'Ah! We have Camembert, yes sir'", "color": "blue"}</code></li>
<li>如果客户端应该暂停<code>{"sleep": 3}</code></li>
<li>播放声音 <code>{"sound": "filename.ogg", "format": "ogg"}</code></li>
</ul>
<p>到目前为止，我们的模式已经处理了序列，但是也有一些模式可以根据它们当前的键匹配映射。在这种情况下，你可以使用:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=k>for</span> <span class=n>action</span> <span class=ow>in</span> <span class=n>actions</span><span class=p>:</span>
    <span class=n>match</span> <span class=n>action</span><span class=p>:</span>
        <span class=n>case</span> <span class=p>{</span><span class=s2>&#34;text&#34;</span><span class=p>:</span> <span class=n>message</span><span class=p>,</span> <span class=s2>&#34;color&#34;</span><span class=p>:</span> <span class=n>c</span><span class=p>}:</span>
            <span class=n>ui</span><span class=o>.</span><span class=n>set_text_color</span><span class=p>(</span><span class=n>c</span><span class=p>)</span>
            <span class=n>ui</span><span class=o>.</span><span class=n>display</span><span class=p>(</span><span class=n>message</span><span class=p>)</span>
        <span class=n>case</span> <span class=p>{</span><span class=s2>&#34;sleep&#34;</span><span class=p>:</span> <span class=n>duration</span><span class=p>}:</span>
            <span class=n>ui</span><span class=o>.</span><span class=n>wait</span><span class=p>(</span><span class=n>duration</span><span class=p>)</span>
        <span class=n>case</span> <span class=p>{</span><span class=s2>&#34;sound&#34;</span><span class=p>:</span> <span class=n>url</span><span class=p>,</span> <span class=s2>&#34;format&#34;</span><span class=p>:</span> <span class=s2>&#34;ogg&#34;</span><span class=p>}:</span>
            <span class=n>ui</span><span class=o>.</span><span class=n>play</span><span class=p>(</span><span class=n>url</span><span class=p>)</span>
        <span class=n>case</span> <span class=p>{</span><span class=s2>&#34;sound&#34;</span><span class=p>:</span> <span class=n>_</span><span class=p>,</span> <span class=s2>&#34;format&#34;</span><span class=p>:</span> <span class=n>_</span><span class=p>}:</span>
            <span class=n>warning</span><span class=p>(</span><span class=s2>&#34;Unsupported audio format&#34;</span><span class=p>)</span>
</code></pre></div><p>映射模式中的键需要是字面值，但是值可以是任何模式。与序列模式一样，所有子模式都必须匹配通用模式才能匹配。</p>
<p>您可以在映射模式中使用<code>**rest</code>来捕获 subject 中的附加键。请注意，如果你忽略了这一点，在匹配时，主题中的额外键将被忽略，例如，消息<code>{"text": "foo"， "color": "red"， "style": "bold"}</code>将匹配上面例子中的第一个模式。</p>
<h3 id=匹配内建类-builtin-classes>匹配内建类 builtin classes</h3>
<p>上面的代码可以需要一些验证。如果消息来自外部源，则字段的类型可能是错误的，从而导致错误或安全问题。</p>
<p>任何类都是有效的匹配目标，其中包括<code>bool</code>、<code>str</code>或<code>int</code>等内置类，这允许我们将上面的代码与类模式结合起来。因此，我们可以使用 <code>{"text": str() as message, "color": str() as c}</code>来代替<code>{"text": message, "color": c}</code>来确保<code>message</code>和<code>c</code>都是字符串。对于许多内置类(参见PEP-634了解整个列表)，可以使用位置参数作为简写，写成<code>str(c)</code>而不是<code>str() as c</code>。完全重写的版本如下所示:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=k>for</span> <span class=n>action</span> <span class=ow>in</span> <span class=n>actions</span><span class=p>:</span>
    <span class=n>match</span> <span class=n>action</span><span class=p>:</span>
        <span class=n>case</span> <span class=p>{</span><span class=s2>&#34;text&#34;</span><span class=p>:</span> <span class=nb>str</span><span class=p>(</span><span class=n>message</span><span class=p>),</span> <span class=s2>&#34;color&#34;</span><span class=p>:</span> <span class=nb>str</span><span class=p>(</span><span class=n>c</span><span class=p>)}:</span>
            <span class=n>ui</span><span class=o>.</span><span class=n>set_text_color</span><span class=p>(</span><span class=n>c</span><span class=p>)</span>
            <span class=n>ui</span><span class=o>.</span><span class=n>display</span><span class=p>(</span><span class=n>message</span><span class=p>)</span>
        <span class=n>case</span> <span class=p>{</span><span class=s2>&#34;sleep&#34;</span><span class=p>:</span> <span class=nb>float</span><span class=p>(</span><span class=n>duration</span><span class=p>)}:</span>
            <span class=n>ui</span><span class=o>.</span><span class=n>wait</span><span class=p>(</span><span class=n>duration</span><span class=p>)</span>
        <span class=n>case</span> <span class=p>{</span><span class=s2>&#34;sound&#34;</span><span class=p>:</span> <span class=nb>str</span><span class=p>(</span><span class=n>url</span><span class=p>),</span> <span class=s2>&#34;format&#34;</span><span class=p>:</span> <span class=s2>&#34;ogg&#34;</span><span class=p>}:</span>
            <span class=n>ui</span><span class=o>.</span><span class=n>play</span><span class=p>(</span><span class=n>url</span><span class=p>)</span>
        <span class=n>case</span> <span class=p>{</span><span class=s2>&#34;sound&#34;</span><span class=p>:</span> <span class=n>_</span><span class=p>,</span> <span class=s2>&#34;format&#34;</span><span class=p>:</span> <span class=n>_</span><span class=p>}:</span>
            <span class=n>warning</span><span class=p>(</span><span class=s2>&#34;Unsupported audio format&#34;</span><span class=p>)</span>
</code></pre></div><h2 id=附录a----快速入门>附录A &ndash; 快速入门</h2>
<p><code>match</code>语句接受一个表达式，并将其值与作为一个或多个<code>case</code>块给出的模式进行比较。这看起来类似于C、Java或JavaScript(以及许多其他语言)中的<code>switch</code>语句，但功能要强大得多。</p>
<p>最简单的形式是将一个 subject 值与一个或多个字面值进行比较:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>http_error</span><span class=p>(</span><span class=n>status</span><span class=p>):</span>
    <span class=n>match</span> <span class=n>status</span><span class=p>:</span>
        <span class=n>case</span> <span class=mi>400</span><span class=p>:</span>
            <span class=k>return</span> <span class=s2>&#34;Bad request&#34;</span>
        <span class=n>case</span> <span class=mi>404</span><span class=p>:</span>
            <span class=k>return</span> <span class=s2>&#34;Not found&#34;</span>
        <span class=n>case</span> <span class=mi>418</span><span class=p>:</span>
            <span class=k>return</span> <span class=s2>&#34;I&#39;m a teapot&#34;</span>
        <span class=n>case</span> <span class=n>_</span><span class=p>:</span>
            <span class=k>return</span> <span class=s2>&#34;Something&#39;s wrong with the Internet&#34;</span>
</code></pre></div><p>注意最后一块:“变量名”<code>_</code>充当通配符，永远不会失败。</p>
<p>你可以使用<code>|</code> (&ldquo;or&rdquo;)将几个字面值组合在一个模式中:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>case</span> <span class=mi>401</span> <span class=o>|</span> <span class=mi>403</span> <span class=o>|</span> <span class=mi>404</span><span class=p>:</span>
    <span class=k>return</span> <span class=s2>&#34;Not allowed&#34;</span>
</code></pre></div><p>模式看起来就像解包赋值，可以用来绑定变量:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=c1># point is an (x, y) tuple</span>
<span class=n>match</span> <span class=n>point</span><span class=p>:</span>
    <span class=n>case</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>):</span>
        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Origin&#34;</span><span class=p>)</span>
    <span class=n>case</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Y=</span><span class=si>{</span><span class=n>y</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
    <span class=n>case</span> <span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=mi>0</span><span class=p>):</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;X=</span><span class=si>{</span><span class=n>x</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
    <span class=n>case</span> <span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;X=</span><span class=si>{</span><span class=n>x</span><span class=si>}</span><span class=s2>, Y=</span><span class=si>{</span><span class=n>y</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
    <span class=n>case</span> <span class=n>_</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&#34;Not a point&#34;</span><span class=p>)</span>
</code></pre></div><p>仔细研究一下那个!第一个模式有两个字面量，可以认为是上面所示字面量模式的扩展。但是接下来的两个模式组合了一个字面量和一个变量，变量绑定来自 subject (<code>point</code>)的值。第四个模式捕获两个值，这使得它在概念上类似于解包赋值<code>(x, y) = point</code>。</p>
<p>如果你使用类来构造数据，你可以使用类名后跟一个类似构造函数的参数列表，但是可以将属性捕获到变量中:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=k>class</span> <span class=nc>Point</span><span class=p>:</span>
    <span class=n>x</span><span class=p>:</span> <span class=nb>int</span>
    <span class=n>y</span><span class=p>:</span> <span class=nb>int</span>

<span class=k>def</span> <span class=nf>where_is</span><span class=p>(</span><span class=n>point</span><span class=p>):</span>
    <span class=n>match</span> <span class=n>point</span><span class=p>:</span>
        <span class=n>case</span> <span class=n>Point</span><span class=p>(</span><span class=n>x</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=mi>0</span><span class=p>):</span>
            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Origin&#34;</span><span class=p>)</span>
        <span class=n>case</span> <span class=n>Point</span><span class=p>(</span><span class=n>x</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=n>y</span><span class=p>):</span>
            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Y=</span><span class=si>{</span><span class=n>y</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
        <span class=n>case</span> <span class=n>Point</span><span class=p>(</span><span class=n>x</span><span class=o>=</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=mi>0</span><span class=p>):</span>
            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;X=</span><span class=si>{</span><span class=n>x</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
        <span class=n>case</span> <span class=n>Point</span><span class=p>():</span>
            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Somewhere else&#34;</span><span class=p>)</span>
        <span class=n>case</span> <span class=n>_</span><span class=p>:</span>
            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Not a point&#34;</span><span class=p>)</span>
</code></pre></div><p>你可以在一些内置类中使用位置参数，这些类为它们的属性(例如数据类)提供排序。你也可以通过在你的类中设置<code>__match_args__</code>特殊属性来定义模式中属性的特定位置。如果它被设置为<code>("x"， "y")</code>，以下模式都是等价的(并且都将<code>y</code>属性绑定到<code>var</code>变量):</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>Point</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>var</span><span class=p>)</span>
<span class=n>Point</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=n>var</span><span class=p>)</span>
<span class=n>Point</span><span class=p>(</span><span class=n>x</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=n>var</span><span class=p>)</span>
<span class=n>Point</span><span class=p>(</span><span class=n>y</span><span class=o>=</span><span class=n>var</span><span class=p>,</span> <span class=n>x</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
</code></pre></div><p>模式可以任意嵌套。例如，如果我们有一个简短的点列表，我们可以这样匹配:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>match</span> <span class=n>points</span><span class=p>:</span>
    <span class=n>case</span> <span class=p>[]:</span>
        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;No points&#34;</span><span class=p>)</span>
    <span class=n>case</span> <span class=p>[</span><span class=n>Point</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)]:</span>
        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;The origin&#34;</span><span class=p>)</span>
    <span class=n>case</span> <span class=p>[</span><span class=n>Point</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)]:</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Single point </span><span class=si>{</span><span class=n>x</span><span class=si>}</span><span class=s2>, </span><span class=si>{</span><span class=n>y</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
    <span class=n>case</span> <span class=p>[</span><span class=n>Point</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>y1</span><span class=p>),</span> <span class=n>Point</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>y2</span><span class=p>)]:</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Two on the Y axis at </span><span class=si>{</span><span class=n>y1</span><span class=si>}</span><span class=s2>, </span><span class=si>{</span><span class=n>y2</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
    <span class=n>case</span> <span class=n>_</span><span class=p>:</span>
        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Something else&#34;</span><span class=p>)</span>
</code></pre></div><p>我们可以向模式添加一个<code>if</code>子句，称为“guard”。如果 guard 为假，<code>match</code> 继续尝试下一个<code>case</code>块。注意，值捕获发生在guard求值之前:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>match</span> <span class=n>point</span><span class=p>:</span>
    <span class=n>case</span> <span class=n>Point</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span> <span class=k>if</span> <span class=n>x</span> <span class=o>==</span> <span class=n>y</span><span class=p>:</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Y=X at </span><span class=si>{</span><span class=n>x</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
    <span class=n>case</span> <span class=n>Point</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Not on the diagonal&#34;</span><span class=p>)</span>
</code></pre></div><p>其他几个关键功能:</p>
<ul>
<li>
<p>与解包赋值一样，元组和列表模式具有完全相同的含义，并且实际上匹配任意序列。一个重要的异常是它们<strong>不匹配</strong>迭代器或字符串。(技术上讲，subject 必须是<code>collections.abc.Sequence</code>的一个实例。)</p>
</li>
<li>
<p>序列模式支持通配符:<code>[x, y， *rest]</code>和<code>(x, y， *rest)</code>在解包赋值时的工作类似于通配符。*后面的名称也可以是<code>_</code>，所以<code>(x, y， *_)</code>匹配至少有两个项的序列，而不绑定其余的项。</p>
</li>
<li>
<p>映射模式:<code>{"bandwidth": b， "latency": l}</code>从字典中捕获<code>"bandwidth"</code>和<code>"latency"</code>值。与序列模式不同，额外的键被忽略。还支持通配符<code>**rest</code>。(但是<code>**_</code>是多余的，所以不允许。)</p>
</li>
<li>
<p>可以使用as关键字捕获子模式:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>case</span> <span class=p>(</span><span class=n>Point</span><span class=p>(</span><span class=n>x1</span><span class=p>,</span> <span class=n>y1</span><span class=p>),</span> <span class=n>Point</span><span class=p>(</span><span class=n>x2</span><span class=p>,</span> <span class=n>y2</span><span class=p>)</span> <span class=k>as</span> <span class=n>p2</span><span class=p>):</span> <span class=o>...</span>
</code></pre></div></li>
<li>
<p>大多数字面值的比较是<code>==</code>的，但是单例的<code>True</code>、<code>False</code>和<code>None</code>是通过<code>id</code>进行比较的。</p>
</li>
<li>
<p>模式可以使用命名的常量。这些必须用点命名，以防止它们被解释为捕获变量:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>enum</span> <span class=kn>import</span> <span class=n>Enum</span>
<span class=k>class</span> <span class=nc>Color</span><span class=p>(</span><span class=n>Enum</span><span class=p>):</span>
    <span class=n>RED</span> <span class=o>=</span> <span class=mi>0</span>
    <span class=n>GREEN</span> <span class=o>=</span> <span class=mi>1</span>
    <span class=n>BLUE</span> <span class=o>=</span> <span class=mi>2</span>

<span class=n>match</span> <span class=n>color</span><span class=p>:</span>
    <span class=n>case</span> <span class=n>Color</span><span class=o>.</span><span class=n>RED</span><span class=p>:</span>
        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;I see red!&#34;</span><span class=p>)</span>
    <span class=n>case</span> <span class=n>Color</span><span class=o>.</span><span class=n>GREEN</span><span class=p>:</span>
        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Grass is green&#34;</span><span class=p>)</span>
    <span class=n>case</span> <span class=n>Color</span><span class=o>.</span><span class=n>BLUE</span><span class=p>:</span>
        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;I&#39;m feeling the blues :(&#34;</span><span class=p>)</span>
</code></pre></div></li>
</ul>
<h2 id=原文档版权声明>原文档版权声明</h2>
<p>This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.</p>
<p>Source: <a class=link href=https://github.com/python/peps/blob/master/pep-0636.rst target=_blank rel=noopener>https://github.com/python/peps/blob/master/pep-0636.rst</a></p>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/blog/tags/python/>python</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
</footer>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>相关文章</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article>
<a href=/blog/p/b-tree/>
<div class=article-details>
<h2 class=article-title>B树</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/avl-tree/>
<div class=article-details>
<h2 class=article-title>AVL树</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/flask%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0wsgi/>
<div class=article-details>
<h2 class=article-title>Flask源码阅读笔记：WSGI</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/django-%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3/>
<div class=article-details>
<h2 class=article-title>Django 的各种关系字段详解</h2>
</div>
</a>
</article>
<article>
<a href=/blog/p/%E8%BD%BB%E9%87%8F%E7%BA%A7-django-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%9C%80%E5%B0%8F%E7%9A%84-django-%E5%BA%94%E7%94%A8/>
<div class=article-details>
<h2 class=article-title>轻量级 django 阅读笔记：最小的 django 应用</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<link rel=stylesheet href=https://unpkg.com/vssue/dist/vssue.min.css>
<div id=vssue></div>
<script src=https://unpkg.com/vue/dist/vue.runtime.min.js></script>
<script src=https://unpkg.com/vssue/dist/vssue.github.min.js></script>
<script>new Vue({el:"#vssue",render:a=>a("Vssue",{props:{title:"pattern-match-in-python310",options:{autoCreateIssue:!1,owner:"nnnewb",repo:"blog",clientId:"285910fdc1567a1a23e3",clientSecret:"f00da5438d9ac82c4a86024866c7a916ae411edc"}}})})</script>
<footer class=site-footer>
<section class=copyright>
&copy;
2021 -
2022 weakptr's 笔记
</section>
<section class=powerby>
GitHub Pages <br>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.5.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">目录</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#说明>说明</a></li>
<li><a href=#概要>概要</a></li>
<li><a href=#教程>教程</a>
<ol>
<li><a href=#匹配序列>匹配序列</a></li>
<li><a href=#匹配多个模式>匹配多个模式</a></li>
<li><a href=#匹配特定值>匹配特定值</a></li>
<li><a href=#匹配多个值>匹配多个值</a></li>
<li><a href=#添加通配符>添加通配符</a></li>
<li><a href=#模式组合>模式组合</a></li>
<li><a href=#or-模式>or 模式</a></li>
<li><a href=#捕获匹配的子模式>捕获匹配的子模式</a></li>
<li><a href=#添加条件到模式>添加条件到模式</a></li>
<li><a href=#添加ui-匹配对象>添加UI: 匹配对象</a></li>
<li><a href=#匹配位置属性>匹配位置属性</a></li>
<li><a href=#匹配常量和枚举>匹配常量和枚举</a></li>
<li><a href=#走进云服务匹配字典>走进云服务：匹配字典</a></li>
<li><a href=#匹配内建类-builtin-classes>匹配内建类 builtin classes</a></li>
</ol>
</li>
<li><a href=#附录a----快速入门>附录A &ndash; 快速入门</a></li>
<li><a href=#原文档版权声明>原文档版权声明</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/blog/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>