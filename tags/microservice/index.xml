<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>microservice on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/tags/microservice/</link><description>Recent content in microservice on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 23 Feb 2022 17:30:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/tags/microservice/index.xml" rel="self" type="application/rss+xml"/><item><title>gRPC-Gateway 用作多个 gRPC 服务的网关</title><link>https://nnnewb.github.io/blog/p/grpc-gateway-used-as-multiple-grpc-server-gateway/</link><pubDate>Wed, 23 Feb 2022 17:30:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/grpc-gateway-used-as-multiple-grpc-server-gateway/</guid><description>前言 众所周知，API网关是微服务架构的重要组件，起到一个整流过滤的作用。虽然 gRPC-Gateway 要啥没啥，和 API 网关的模式也扯不上太多关系，但总之先起个高调。
然后就是真正遇到的问题了。在旧的架构里，gRPC-Gateway 的用法，是对每个需要暴露 HTTP 服务的 gRPC 服务都起一个对应的 gRPC-Gateway 。最早的做法是 gRPC-Gateway 服务单独作为一个 POD ，gRPC 服务实现也单独一个 POD 。后来我改成了 Gateway 和 服务在同一个 POD 内，起两个 container 。
之前的做法都存在一个问题，就是 gRPC-Gateway 要分配少量的 CPU 和内存配额，虽然每个 gRPC-Gateway 服务分到的内存和CPU都很少，但架不住服务多，内存和 CPU 的配额都占用了不少，实际用到的少得可怜，大部分配额都是浪费。
下面具体分析下怎么把 gateway 单独提取成一个 POD，给所有 gRPC 服务当网关，同时保持负载均衡发挥作用，提供无缝扩容。
实现网关 官方demo // Create a client connection to the gRPC server we just started // This is where the gRPC-Gateway proxies the requests conn, err := grpc.DialContext( context.</description></item></channel></rss>