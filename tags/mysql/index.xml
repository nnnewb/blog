<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>mysql on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/tags/mysql/</link><description>Recent content in mysql on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 31 Dec 2021 18:30:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/tags/mysql/index.xml" rel="self" type="application/rss+xml"/><item><title>记一次API响应时间优化</title><link>https://nnnewb.github.io/blog/p/an-api-response-time-optimize/</link><pubDate>Fri, 31 Dec 2021 18:30:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/an-api-response-time-optimize/</guid><description>前言 刚接手管理后台的后端服务，先随便挑个什么东西下手看看。正好注意到一个简单的接口返回时间都蛮长的，于是拿刚从 opentelemetry 的 issue/pr 里抄来的 sqlmw 包装驱动来分析优化下性能。
0x01 性能分析 预判 下手前预估下可能存在瓶颈的地方。对于这次下手的接口（get_users），整个实现也没几行代码，只有两三个查询，数据量也不大，但是耗时有80ms+。
其他接口有快有慢，并没有表现出同时增加耗时，而且开发服务器架在内网，排除网络原因，大概还是服务本身的存在的问题。于是考虑瓶颈在数据库或代码中，但具体肯定是要看代码去分析的。既然判断是代码里的问题，那下一步就是测量下耗时情况了。
对于go，pprof虽然是个不错的主意，但实话说部署在 kubernetes 里，配 pprof 去拉结果有点麻烦，而且还有点点用不惯。正好这个项目里早就配置了 opentracing+jaeger做分布式跟踪，所以就直接抄一下 opentelemetry 的 otelsql ，把SQL查询的详细耗时情况记录下来，就可以开始分析了。
opentracing收集数据 otelsql 原理是用 sqlmw 在 sql 驱动层级上进行包装sql ==&amp;gt; sqlmw.Driver{mysql.Driver} 。go的sql调用sqlmw.Driver，sqlmw.Driver调用mysql.Driver，如此而已，具体不解释。
从otelsql借鉴下思路即可，现在 opentracing 已经和 opencensus 合并成了 opentelemetry，但项目也没法说升级就升级，毕竟项目架构设计稀烂，太多地方和 opentracing、jaeger-client 强耦合了。把otelsql里用sqlmw的部分抄出来，改成opentracing的方式创建span完事。
func (in *sqlInterceptor) ConnExecContext(ctx context.Context, conn driver.ExecerContext, query string, args []driver.NamedValue) (driver.Result, error) { span, ctx := opentracing.StartSpanFromContext(ctx, &amp;#34;ConnExecContext&amp;#34;) defer span.Finish() span.LogKV(&amp;#34;sql.query&amp;#34;, query) return conn.ExecContext(ctx, query, args) } 如此一来， 当go的sql库访问数据库的时候，就会在jaeger里记录一个span，可以清晰地看到耗时情况。</description></item><item><title>XA 事务从理论到实践</title><link>https://nnnewb.github.io/blog/p/xa-transaction-theory-to-practice/</link><pubDate>Thu, 16 Dec 2021 15:00:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/xa-transaction-theory-to-practice/</guid><description>前言 有言道，纸上得来终觉浅，绝知此事要躬行。分布式事务的具体方案，看几篇文章就基本有了概念，但实际应用的机会很少。这不有点闲暇，就试试看把理论化作代码，在实践中检验。
#1 案例设计 采用分布式事务经典的转账案例：用户从银行A转账到银行B，银行A扣除余额，银行B增加余额。
XA事务官方规范文档给出的示意图如下。
事务模型
用 XA 事务描述，用户的转账操作发生在AP，AP调用TM注册全局事务后，调用银行A（RM）完成扣款（PREPARE），调用银行B（RM）完成增加余额（PREPARE），然后调用TM提交全局事务，TM回调银行A和B提交本地事务。
图示如下。
xa事务时序图
上面的时序图是读了 github.com/yedf/dtm 代码后胡乱分析出来的，图略去了错误处理的部分。根据这个时序图可以做出一个简单的服务划分设计。
案例服务划分
为了更好地观察服务的交互情况，引入了 Jaeger ，如果是为了简化整个案例代码考虑也可以不要。但大部分时候 Jaeger 应该是没什么存在感的。
nginx 反向代理将 AP 的接口还有 Bank1/Bank2的接口导出给用户访问，实际上案例中没有需要访问 Bank1/Bank2 接口的情况，所以 去掉 nginx 反向代理应该也没什么大关系。
#2 技术栈 所有服务使用docker-compose部署，kubernetes也没问题。
MySQL使用5.7版本，jaeger和nginx最新稳定版。AP/Bank服务都使用 Go 语言编写， 使用 Gin 作为 HTTP 服务框架，OpenTelemetry 跟踪，sqlx 做 ORM。
#3 接口设计 接口url设计有参考 Google APIs 规范，但并不是硬套 RESTful 。
AP服务提供接口
/v1alpha1/transfer 转账接口 Bank服务提供接口
/v1alpha1/trans_in 余额转入 /v1alpha1/trans_out 余额转出 /v1alpha1/tm_callback 事务回调，当AP提交事务或者回滚时，TM回调这个接口并告知需要提交还是回滚 TM服务提供接口</description></item><item><title>MySQL XA 事务和分布式事务处理模型：2阶段提交</title><link>https://nnnewb.github.io/blog/p/mysql-xa-distributed-transaction-processing-model-2pc/</link><pubDate>Fri, 09 Jul 2021 09:29:22 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/mysql-xa-distributed-transaction-processing-model-2pc/</guid><description>关于 MySQL XA 事务和 2PC（两阶段提交）分布式事务处理模型（Distributed Transaction Processing, DTP Model）的学习笔记。
事务 分布式事务XA 介绍 MySQL内建分布式事务支持（XA），参考文档列出如下
[MySQL Manual - XA](MySQL :: MySQL 8.0 Reference Manual :: MySQL Glossary) [MySQL Manual - XA Transaction](MySQL :: MySQL 8.0 Reference Manual :: 13.3.8 XA Transactions) [MySQL Manual - XA Transaction Statements](MySQL :: MySQL 8.0 Reference Manual :: 13.3.8.1 XA Transaction SQL Statements) [MySQL Manual - XA Transaction State](MySQL :: MySQL 8.0 Reference Manual :: 13.3.8.2 XA Transaction States) XA 事务在 InnoDB 引擎中可用。MySQL XA 事务实现基于 X/Open CAE 文档 《Distributed Transaction Processing: The XA Specification》。这份文档由 Open Group 发布，可以在 http://www.</description></item><item><title>MySQL 24小时入门笔记 - 4</title><link>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-4/</link><pubDate>Sat, 23 Jun 2018 22:34:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-4/</guid><description>创建表 CREATE TABLE CREATE TABLE的作用是创建表。不多说，先创建个简单的学生表。
CREATETABLEstudents(idint,namechar(16)NOTNULL,primarykey(id));这里没写 ENGINE=InnoDB，因为这是新 MariaDB 的默认值。
那么进入正题，CREATE TABLE的语法如下。
CREATETABLE[表名]([列名][类型][约束和其他属性],[列名][类型][约束和其他属性],....[其他表配置]);很容易看出，括号里面写的是表的相关配置，包括列定义，主键定义，索引定义等等。
默认值 在创建表时可以指定默认值，有默认值的列在插入时可以不填。
语法如下。
CREATETABLE[表]([列][类型]DEFAULT[值],);即可为一个列设定默认值。
非空 非空约束非常常见。比如说，我们要记录学生信息，包括学号、成绩、姓名，那么学生姓名能不能留空呢？显然不行，因为没有姓名的记录让谁看都是一脸懵逼，这破坏了一条记录的完整性。
创建非空约束的语法如下。
CREATETABLE[表]([列][类型]NOTNULL,);这就创建了非空约束。非空约束下，插入数据时不能不填写这个列。
如果需要要求可空，那么这样做。但一般不用特地写，很多DBMS的列默认创建就是可空的。
CREATETABLE[表]([列][类型]NULL,);修改表 ALTER TABLE ALTER TABLE可以修改表定义，添加删除列，修改约束，等等。
添加列 举例，在一个只有学号和姓名两个列的学生表加入一个新的成绩列，代码如下。
ALTERTABLEstudentsADDscoreint;语法基本是这样。
ALTERTABLE[表名]ADD[列名][类型][其他属性和约束];后面列的定义写法基本和CREATE TABLE时差不多。
删除列 和添加列差不多，但删除的关键字不是DELETE，而是DROP。
ALTERTABLE[表名]DROP[列名];添加外键约束 外键约束其实保证的是引用完整性，外键约束的列的值必须引用了一个有效的行，或者是NULL。
举例来说，我们先有两个表。
学生表
id name class 1 student 1 1 2 student 2 2 3 student 3 3 班级表
id level 1 Lv5 2 Lv4 3 Lv3 为了让学生表的class关联到班级表的id，我们要这样做。</description></item><item><title>MySQL 24小时入门笔记 - 3</title><link>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-3/</link><pubDate>Sat, 23 Jun 2018 21:51:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-3/</guid><description>插入 INSERT INSERT用法非常简单。现在我们有表students如下。
列名 类型 约束 id int primary key name char(16) NOT NULL 向里面插入一条学号为1，姓名为学姐的学生，只需要写如下SQL语句。
INSERTINTOstudentsVALUES(1,&amp;#39;学姐&amp;#39;);语法
INSERTINTO[表]VALUES(列值1,列值2,...);其中INSERT语句有一个简单的变体，能比较明确地指明将值交付给哪个列。
INSERTINTOstudents(id,name)VALUES(1,&amp;#39;学妹&amp;#39;);这样写相当于指明了1应该是id，'学妹'应该是name。
插入多条也很简单，只要在VALUES后面跟更多小括号包围的值集合就行了，记得拿括号分隔，下面给个例子。
INSERTINTOstudents(id,name)VALUES(1,&amp;#39;学渣&amp;#39;),(2,&amp;#39;学霸&amp;#39;),(3,&amp;#39;学神&amp;#39;);INSERT SELECT 这个写法比较有意思，从一个表查询出数据，并插入另一个表。
举个例子来说，我们有两个班级表，分别叫学渣班和补习班，一旦学渣成绩烂到一定程度，那么我们就要把他分配到补习班里去强制补习。
怎么做呢？看下面啦。
INSERTINTO补习班(name,score)SELECT学渣班.name,学渣班.scoreFROM学渣班WHERE学渣班.score&amp;lt;10;值得注意的是，INSERT 填充补习班表时用的并不是你SELECT的列名，而是SELECT后列名的顺序，来对应到要INSERT的表的列上。
其他的写法和SELECT相同。
修改 UPDATE UPDATE语句的作用是修改现存行的数据，非常值得注意的是用UPDATE语句时一定要小心写WHERE子句，不然就等着删库跑路吧。
依然举个实际栗子，学号为10的学生成绩由于作弊而被取消了，我们要更新他的成绩为 0 分，这真是个悲伤的故事:P
UPDATEstudentsSETscore=0WHEREid=10;语法是这样的。
UPDATE[表名]SET[列名]=[新值]WHERE[条件];更新多条的话是这样的
UPDATE[表名]SET[列1]=[新值],[列2]=[新值],...[列N]=[新值]WHERE[条件]; 千万小心，如果没有 WHERE子句的话，指定的列会全部被设置成这个值。这样一来，所有的学生都变成了 0 分&amp;hellip;&amp;hellip;你会被手撕了的。
删除 DELETE DELETE的作用是删除行，同样的，万分注意WHERE子句一定要正确编写，不然真的要删库跑路了。
同样以之前那位作弊的同学为例，很遗憾，他又一次作弊被抓住了，传说中的高科技 AR 技术作弊眼镜也没能让他逃过监考员的火眼金睛，于是他被退学了&amp;hellip;&amp;hellip;
另一个悲伤的故事:P
DELETEFROMstudentsWHEREid=10;语法是这样子的。
DELETEFROM[表名]WHERE[条件];如果不写WHERE的话&amp;hellip;&amp;hellip;找个好点的新工作吧，不要再去写SQL了，ORM 多好。
注意，不写WHERE子句会删除这个表里的所有行。</description></item><item><title>MySQL 24小时入门笔记 - 2</title><link>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/</link><pubDate>Sat, 23 Jun 2018 15:41:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-2/</guid><description>查询 SELECT SELECT是一个特殊的关键字，它的语义是查询，取出结果。
注意：仅为个人理解。
FROM FROM子句，标识要查询的对象的来源，来源可能是多个的。在查询有多个来源表的情况下，称之为联结查询（Join query）。
最常见的常规写法是SELECT column FROM table，表示从特定表取出所有行的特定列。
WHERE WHERE子句用于过滤查询的行，只有满足条件的行会被查询出来。
常见的用法有SELECT column FROM table WHERE column &amp;lt;&amp;gt; 0，表示在table表中查询column非空的行，返回这些行的column。
其中的二元关系运算符&amp;lt;&amp;gt;表示不等于，其他常见的关系运算符还有这些。
运算符 含义 = 相等 &amp;gt; 大于 &amp;lt; 小于 &amp;gt;= 大于等于 &amp;lt;= 小于等于 != 不等于 &amp;lt;&amp;gt; 不等于 此外还有一些SQL关键字可以辅助编写判断逻辑。
SQL关键字IN可以用于判断元素是否在集合中。举例，SELECT 1 IN (1,2,3)，查询1是否在1,2,3这个集合中。被判断的集合需要被小括号包围，并且以逗号分隔元素。
SQL关键字BETWEEN可以判断元素是否在一定区间中。举例，SELECT 1 BETWEEN 0 and 10，查询1是否在0到10的区间内。语法是BETWEEN [low] AND [high]，区间较小的一端必须在左侧，较大的一端必须在右侧。</description></item><item><title>MySQL 24小时入门笔记 - 1</title><link>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-1/</link><pubDate>Sat, 23 Jun 2018 02:24:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/mysql-24%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-1/</guid><description>1. 数据库概念 1.1 数据和储存 数据库本质上做的工作是储存和查询数据。理论上而言，MySQL应该叫做DBMS，也就是数据库管理系统，而不是数据库。
DBMS提供了统一的建立、使用、管理数据库的接口，常见的DBMS有postgreSQL、MariaDB、SQL Server等。
1.2 数据库和Schema 通常来说，一个DBMS会支持多个数据库共存。这里所说的数据库指的是特定数据库管理系统管理下的数据库，而不是上一节说的DBMS。
而Schema的中译术语一般叫模式，Schema描述了数据库的结构，比如说有哪些表，表有哪些字段，字段分别有哪些限制，有哪些声明了的函数，等等。
通常的DBMS往往是这样的结构：位于DBMS管理最顶层的是一个或多个数据库，数据库里存放表，表里以行为单位存放数据。
1.3 表、列、键、行 1.3.1 表 表的英语术语是Table。
用过 Excl 吗？
id name 1 Mike 2 John 直观的表就是一个二维的“表”，有行，有列。
1.3.2 列 列的术语是 Column。
每个列都应该有一个特定的类型（type），使该列仅仅储存指定类型的数据。
1.3.3 键&amp;hellip;&amp;hellip;或者叫码 键的术语是 Key。
通常指的是Primary Key，也就是主键。主键可以是任意一个列。但是如果列是主键，那么这个列必须每个行都保证不和其他行重复。
主键也可以是多个列，如果是多个列，那么必须保证这些列的组合不重复。
举例来说
db table id name aa aaaaa 11 xxxx aa bbbbb 11 xxxx 其中db和table还有id都是主键，只要保证没有两个行同时存在相同的db/table/id就算是满足了主键约束。</description></item></channel></rss>