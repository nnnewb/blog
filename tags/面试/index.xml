<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>面试 on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/tags/%E9%9D%A2%E8%AF%95/</link><description>Recent content in 面试 on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 27 May 2022 18:33:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/tags/%E9%9D%A2%E8%AF%95/index.xml" rel="self" type="application/rss+xml"/><item><title>2022年5月27日 面试记录</title><link>https://nnnewb.github.io/blog/p/2022-05-27-interview-note/</link><pubDate>Fri, 27 May 2022 18:33:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/2022-05-27-interview-note/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>面试完，结果只能说我对自己也不算很满意，顺带反思了一下是不是表现得太着急了。&lt;/p>
&lt;p>原本以为一个小时足矣，结果面到快12点，才结束完面试，还没出门就碰到泼水一样的暴雨。花了一个多钟头到家，已经是下午1点十几分了。原本打算去公司继续上下午的班，但累到没有一点心情，于是把上午的假延长到下午。&lt;/p>
&lt;p>typora 建好文件后就着住房改造家的视频吃了午饭，再看会儿 boss 上的的 jd ，还是劝自己把面试的复盘写完，迟早都是要写的。&lt;/p>
&lt;h2 id="技术面">技术面&lt;/h2>
&lt;p>开场技术面，自我介绍、关于离职原因一类的问题就略了。我不记得所有问题，所以就单独把还有映像的问题拿出来复盘下。鉴于我技术栈两门语言，面试官 Python 和 Go 的题混合问的，我回忆的顺序大概也对不上实际面试中问的顺序。&lt;/p>
&lt;h2 id="简答题">简答题&lt;/h2>
&lt;h3 id="深浅拷贝">深浅拷贝&lt;/h3>
&lt;p>基础题。复盘中自我感觉回答应该没什么遗漏，但沟通中感觉和面试官就 &lt;strong>拷贝&lt;/strong> 意指 &lt;code>a=b&lt;/code> 还是 &lt;code>a=list(b)&lt;/code> 有点误会，但总之问题不大。&lt;/p>
&lt;h3 id="哈希冲突哈希表时间复杂度哈希表实现dict是不是哈希表">哈希冲突、哈希表时间复杂度、哈希表实现、dict是不是哈希表&lt;/h3>
&lt;p>简单的算法和一点CPython实现细节。&lt;/p>
&lt;p>哈希冲突实质是摘要函数输入空间和输出空间不对等，冲突无法避免。&lt;/p>
&lt;p>哈希表的时间复杂度是 &lt;code>O(1)&lt;/code> ，面试官还问了为什么是 &lt;code>O(1)&lt;/code>，emm，我的回答是直接拿哈希值当索引的情况下空间换时间，最理想的情况一条指令就能取到元素了。回答不太准，问了下谷歌说是最坏O(n)，平均O1。显然最坏的情况就是碰撞了。&lt;/p>
&lt;p>哈希表实现的话，当时没敢答。现在想想的话，在 leetcode 做过相关的题，简单的实现比如把ascii码表（或者随便什么序列）映射到一块连续内存上然后就能直接去索引了，复杂的实现问谷歌回答是 Java 的 HashMap 是红黑树实现，Go 的 map 也是哈希表，但实现也不是我说的那种直接映射到一块内存上。总之就是各有不同吧。&lt;/p>
&lt;p>&lt;code>dict&lt;/code> 底层也是哈希表，下次记得问 &lt;code>map&lt;/code>/&lt;code>dict&lt;/code> 都回答哈希表就是了。&lt;/p>
&lt;p>具体 Go 和 Python 的实现抽时间再找解析看看，不行就硬读源码了。&lt;/p>
&lt;h3 id="并发和并行">并发和并行&lt;/h3>
&lt;p>可能是几年前看过，但当时印象不深，太偏理论了，实践中很少能碰到抠这俩字眼的情况。重温下。&lt;/p>
&lt;p>并发是 concurrent，并行是 parallel ，有个比较形象的说法是并发是同一时间发生几件事，并行是这几件事同时发生。&lt;/p>
&lt;p>放到操作系统原理来解释就是并发可以是单核CPU给两个进程都分了时间片，所以 &lt;strong>看起来&lt;/strong> 两者同时执行，但实际上两者还是有先后，或者交错进行的。并行就是多核 CPU &lt;strong>同时&lt;/strong>在跑两个进程的代码，两个程序是真的同时处于运行状态。&lt;/p>
&lt;h3 id="gil">GIL&lt;/h3>
&lt;p>基础题。我当时回答是执行字节码的时候加的锁，确保同时只有一个线程在执行字节码，目的是简化编程，后来因为各种原因就变成了历史遗留，各种去除GIL改成细粒度锁的尝试目前还没有很好的结果。&lt;/p>
&lt;p>特地回顾了下python文档，确定了文档的说法和我记忆中是一样的。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/2022-05-27-interview-note/image-20220527170018461.png"
width="815"
height="103"
srcset="https://nnnewb.github.io/blog/blog/p/2022-05-27-interview-note/image-20220527170018461_hud3e9d34ad8ba2fd890523a9182bdfc8d_29027_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/2022-05-27-interview-note/image-20220527170018461_hud3e9d34ad8ba2fd890523a9182bdfc8d_29027_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20220527170018461"
class="gallery-image"
data-flex-grow="791"
data-flex-basis="1899px"
>&lt;/p>
&lt;p>但感觉面试官不太满意的样子…为啥呢。&lt;/p>
&lt;h3 id="gmp">GMP&lt;/h3>
&lt;p>基础题。但没背八股，照着映像乱讲一通了。&lt;/p>
&lt;p>G就是goroutine，M是操作系统线程，P是处理器。好像也有管P叫管理器。&lt;/p>
&lt;p>整个模型就是 M 绑定 P，M 有个 G 队列，然后就是抢占式调度。&lt;/p>
&lt;p>要说遗漏的内容的话 emm&lt;/p>
&lt;ul>
&lt;li>GMP 还有个全局 G 队列&lt;/li>
&lt;li>work stealing：M 在没有任务的时候会抢其他 M 队列里的 G 去调度&lt;/li>
&lt;li>hand off：M 阻塞的时候会释放 P，让其他线程跑。（不太理解）&lt;/li>
&lt;li>P 数量不一定对应物理核心或者逻辑核心数量，可以调。&lt;/li>
&lt;li>M 是 Go runtime 阻塞的时候自动创建新的，有上限。&lt;/li>
&lt;li>M0 和 G0&lt;/li>
&lt;/ul>
&lt;p>漏的东西还挺多的。因为面 Python 都忘了要看下 Go 的经典八股。&lt;/p>
&lt;h3 id="gc">GC&lt;/h3>
&lt;p>基础题。Go的 GC 是从 Mark-Sweep 到三色标记算法（黑白灰），面试中具体的算法内容没提。还提到Go的内存返还机制，但没表达清楚。&lt;code>MADV_FREE&lt;/code> 的坑也没提。&lt;/p>
&lt;h3 id="混合写屏障">混合写屏障&lt;/h3>
&lt;p>GC进阶一点的题？面试时没答上来。讲真应该把Go的八股先看看的…&lt;/p>
&lt;p>写屏障是一个无STW场景才存在的问题，STW的话就不会在扫描的时候有谁在写了。写屏障是为了解决扫描的时候有人在写对象的问题，避免三色标记错误。&lt;/p>
&lt;p>混合写屏障是混合了两种写屏障算法（ Dijkstra 插入屏障和 Yuasa 删除屏障）。&lt;/p>
&lt;p>具体的我先放个链接在这里吧=。=&lt;/p>
&lt;p>懒得抄一遍。&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch08gc/barrier/#heading2" target="_blank" rel="noopener"
>写屏障技术 - Go语言原本&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.jianshu.com/p/4c5a303af470" target="_blank" rel="noopener"
>Golang 三色标记、混合写屏障GC模式图文全分析&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="innodb">InnoDB&lt;/h3>
&lt;p>数据库题。问题有点宽泛到摸不着头脑，但真要我介绍下 InnoDB 是个啥有啥特性我也真说不上来。&lt;/p>
&lt;p>先留个链接等之后再细读。&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-introduction.html" target="_blank" rel="noopener"
>mysql 5.7 innodb introduction&lt;/a>&lt;/li>
&lt;li>《MySQL技术内幕（InnoDB引擎）》&lt;/li>
&lt;/ul>
&lt;p>面试官居然问你们不用MySQL的吗…我…&lt;/p>
&lt;p>行吧……&lt;/p>
&lt;p>简直是暴击。&lt;/p>
&lt;h3 id="docker隔离原理">docker隔离原理&lt;/h3>
&lt;p>基础题吧。&lt;/p>
&lt;p>基本原理就是利用内核的 namespace 隔离了 pid、mount、network，chroot 隔离了文件系统，cgroup 控制资源使用。&lt;/p>
&lt;p>面试的时候忘记了一个 &lt;code>UTS&lt;/code> ，就是隔离 hostname ，还有 IPC，还有 USER 。另外就是 cgroup 也是有 namespace 的。&lt;/p>
&lt;p>具体可以看 &lt;code>unshare&lt;/code>，直接 &lt;code>man unshare&lt;/code> 就行。&lt;/p>
&lt;h2 id="论述题">论述题&lt;/h2>
&lt;h3 id="python给函数加超时装饰器">python给函数加超时装饰器&lt;/h3>
&lt;p>面试的时候回答是&lt;code>async def&lt;/code> 可以直接用 &lt;code>future&lt;/code> 实现。普通函数可以用线程，完成后信号量统治下调用方。当时就中途返回的问题拉扯了一下，感觉还是没讲清楚。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="kn">import&lt;/span> &lt;span class="nn">threading&lt;/span>
&lt;span class="kn">from&lt;/span> &lt;span class="nn">time&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">sleep&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">timeout&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">seconds&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">float&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">wrapper&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">wrapped&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">kwargs&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="c1"># 构造一个 0 信号量&lt;/span>
&lt;span class="n">s&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">threading&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Semaphore&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">None&lt;/span>
&lt;span class="c1"># 包装一下，任务完成时返回结果并发出完成信号&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">_f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sem&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">threading&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Semaphore&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">nonlocal&lt;/span> &lt;span class="n">result&lt;/span>
&lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">kwargs&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">sem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">release&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">threading&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Thread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">lambda&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">_f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="c1"># acquire 会把信号量 -1 ，不满足时等待，这里利用了 acquire 自带的 timeout 参数&lt;/span>
&lt;span class="c1"># 如果问到更底层的话比如C/C++甚至汇编，可能要依赖OS功能（信号机制之类的）来唤醒，大概这样。&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">acquire&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">timeout&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">seconds&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="kc">False&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">raise&lt;/span> &lt;span class="ne">Exception&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;timeout&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">wrapped&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">wrapper&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="vm">__name__&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;__main__&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nd">@timeout&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">3.0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">seconds&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">seconds&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">seconds&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s1">&amp;#39;hahaha&amp;#39;&lt;/span>
&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">1.0&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">2.0&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">3.0&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这就是我说的信号量解法。但面试官后来又问是不是每个装饰器都要一个信号量，我猜面试官对这个解还不满意。&lt;/p>
&lt;p>不使用信号量也能实现，但无论如何这个等待和唤醒要依赖一个异步通知机制，总是没法避免。&lt;/p>
&lt;p>分离到另一个线程里执行也是个比较头疼的做法，但面试那儿会想不出更好的主意。&lt;/p>
&lt;h3 id="三个goroutine循环输出abc">三个goroutine循环输出abc&lt;/h3>
&lt;p>面试的时候下意识回答用&lt;code>mutex&lt;/code>，但拿纸笔整理了下思路，改成了用&lt;code>chan&lt;/code>感觉更好。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="s">&amp;#34;sync&amp;#34;&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">c&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">wg&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">WaitGroup&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">go&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;a&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">wg&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">go&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;b&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">b&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">wg&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">go&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">wg&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">a&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span>
&lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Wait&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">in&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">out&lt;/span> &lt;span class="kd">chan&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{},&lt;/span> &lt;span class="nx">wg&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">sync&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">WaitGroup&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">defer&lt;/span> &lt;span class="nx">wg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Done&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">_&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span>&lt;span class="nx">in&lt;/span>
&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">out&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="kd">struct&lt;/span>&lt;span class="p">{}{}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// abcabcabcabcabc
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>面试官还问到是不是无buffer的 &lt;code>chan&lt;/code>，我说是1 。当时没想那么多，实际分析代码会发现必须是1，不能是无缓冲的，因为循环末尾&lt;code>c&lt;/code>会再发信号给&lt;code>a&lt;/code>，而那时候&lt;code>a&lt;/code>已经退出了，无缓冲的情况下&lt;code>c&lt;/code>会阻塞死，会报错 &lt;code>all goroutines are asleep&lt;/code> 。但1缓冲就不会有这个问题。&lt;/p>
&lt;h3 id="分布式追踪架构和实现侵入非侵入">分布式追踪架构和实现（侵入/非侵入）&lt;/h3>
&lt;p>这个主要是吹逼。&lt;/p>
&lt;p>讲了下分布式追踪基本的架构，也就是从 &lt;code>Agent&lt;/code> 到 &lt;code>Collector&lt;/code> 再到存储，然后前端从存储查数据展示，基本数据结构 Span 啦什么的。&lt;/p>
&lt;p>面试官还问能不能非侵入，非侵入和侵入有什么区别，这部分就是吹水了。侵入的话自然是什么都能做，把分布式追踪当日志用。非侵入的话就是外面挂 sidecar，代理流量，也能拿到 RPC 调用、HTTP请求之类的数据，举例就是服务网格。当然还有 pprof 也能拿到一些统计数据但那个是时序性的，应该叫 metrics ，和追踪又不太一样。&lt;/p>
&lt;p>但后来发现和面试官理解有点偏差，面试官只想不侵入业务代码，但应用代码是可以侵入的，那就好办多了。不管是 sql.driver 还是自定义 logger 都行，很多组件都支持插中间件，这种情况下基本和侵入业务代码差不多了，除了一些更细致的像是统计某个循环跑了多久之类的还需要单独写 span 办不到之外（要是封装个&lt;code>timeit&lt;/code>之类的也不算侵入的话那就0限制了，想干啥都行）。&lt;/p>
&lt;h3 id="upv-登录界面几个接口">UPV 登录界面几个接口&lt;/h3>
&lt;p>面试官画了个图问这界面要几个后端接口。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/2022-05-27-interview-note/image-20220527181148464.png"
width="800"
height="600"
srcset="https://nnnewb.github.io/blog/blog/p/2022-05-27-interview-note/image-20220527181148464_hu060edb4cd2e9977ccffafca537a042b4_41474_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/2022-05-27-interview-note/image-20220527181148464_hu060edb4cd2e9977ccffafca537a042b4_41474_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20220527181148464"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="320px"
>&lt;/p>
&lt;p>U是用户名，P是密码，V是验证码。&lt;/p>
&lt;p>我的回答是2~3个，看验证码刷新要不要单独给个接口。&lt;/p>
&lt;p>然后又问你会怎么实现这个登录接口。&lt;/p>
&lt;p>emm，感觉题有点怪，想考察思维全面不全面？答了几个点：&lt;/p>
&lt;ul>
&lt;li>密码加盐哈希，一般就直接 HMAC&lt;/li>
&lt;li>SESSION_ID 取正确验证码来验证&lt;/li>
&lt;li>给 ratelimit，验证码刷新和登录尝试都要限&lt;/li>
&lt;li>CSRF Token，可以是直接从服务端返回（服务端渲染）或者Ajax 拿到&lt;/li>
&lt;/ul>
&lt;p>现在的话想起来几个新的点&lt;/p>
&lt;ul>
&lt;li>用户量很大的话查数据库压力太大，可以加一层缓存，验证密码的时候不访问数据库了&lt;/li>
&lt;li>错误信息控制，防止爆破用户名&lt;/li>
&lt;li>响应时间控制，防止 Timing Attack （虽然可能性真的很低，但结合下数据库压力，能让走数据库和不走数据库的请求有明显时间差异的话还是可能爆出用户名的，感觉是非常极端的情况了）&lt;/li>
&lt;li>前后端分离的情况下前端单独nginx部署肯定是没有后端返回的会话ID或者验证码ID什么的，这种情况下会话标识、CSRF Token 都只能 Ajax 拿。最近PHP看多了感觉思路在往后端渲染跑。前后端分离最少也要2个接口，CSRF、验证码+验证码ID（或者会话ID，总之要把登录请求和验证码联系起来）&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>薄弱点基本确定了。&lt;/p>
&lt;p>一个是Go方面，八股背熟真的有用。&lt;/p>
&lt;p>另一个是MySQL，一方面是需要切实再深入一下，另外MySQL的八股也得找找。&lt;/p>
&lt;p>虽然面完让我有点幻灭的感觉，安全行业不止卷还抠=。=&lt;/p>
&lt;p>虽然让我等联系，但估计也没下文了。骑驴找马还得继续。&lt;/p></description></item><item><title>GameHollywood 面试笔记</title><link>https://nnnewb.github.io/blog/p/gamehollywood-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</link><pubDate>Tue, 26 Jun 2018 17:22:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/gamehollywood-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</guid><description>&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>面试的职位是 C++后端开发工程师，主要聊的还是 C++。在过程中自我感觉面得还行，至少没&lt;a class="link" href="https://my.oschina.net/u/3888259/blog/1833040" target="_blank" rel="noopener"
>上次&lt;/a>那么蠢。&lt;/p>
&lt;p>聊的内容主要集中在 STL 和线程安全、资源管理的层面。&lt;/p>
&lt;p>惯例的，填完面试信息表并简历一起上交，然后等面试官来客套完，就开始聊技术了。&lt;/p>
&lt;blockquote>
&lt;p>注意，面试官的提问并非原话，有修饰和脑补。&lt;/p>
&lt;/blockquote>
&lt;h2 id="0-预热你用哪个版本的-c">0. 预热：你用哪个版本的 C++？&lt;/h2>
&lt;p>客套话什么的就略了。&lt;/p>
&lt;blockquote>
&lt;p>面试官：&amp;hellip;行，那我们就聊聊 C++吧。你常用哪个版本的 C++？&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>我：我比较常用的是 C++11。&lt;/p>
&lt;/blockquote>
&lt;p>C++版本这个问题面试里应该不多见，不过作为引入的话题还行，标准之神会瞑目的。&lt;/p>
&lt;p>对于&lt;strong>C++版本&lt;/strong>这个词，很大概率上大家说的应该就是 C++标准委员会&lt;a class="link" href="http://www.open-std.org/JTC1/SC22/WG21/" target="_blank" rel="noopener"
>WG21&lt;/a>制定的 C++标准了，最新版本的标准文档是 C++17 定稿&lt;a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf" target="_blank" rel="noopener"
>N4659&lt;/a>，制定中的 C++20 标准文档可以访问&lt;a class="link" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2018/" target="_blank" rel="noopener"
>WG21/docs/papers/2018&lt;/a>查阅。&lt;/p>
&lt;p>需要注意的是，如果答成了&lt;strong>我用 VC6&lt;/strong>之类的骚话，很大概率会留下不好的映像——或者对方也是忠实的 VC6 神教教徒的话，达成共识也说不定。&lt;/p>
&lt;p>闲话少叙。&lt;/p>
&lt;h2 id="1-起手式stdshared_ptr">1. 起手式：&lt;code>std::shared_ptr&lt;/code>&lt;/h2>
&lt;blockquote>
&lt;p>面试官：说说&lt;code>std::shared_ptr&lt;/code>是怎么实现的？一般怎么去使用它？&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>答：&lt;code>shared_ptr&lt;/code>是通过&lt;strong>引用计数&lt;/strong>实现的，它可以作为容器元素，在程序里传递 blabal&amp;hellip;..而且&lt;code>shared_ptr&lt;/code>&lt;strong>不是线程安全的&lt;/strong>，它不能跨线程传递，要额外做一层包装 blabla&amp;hellip;&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;p>正巧最近有想写一篇智能指针相关的博客，面试官的第一问就提到了。&lt;/p>
&lt;p>说到智能指针，就必须提一下 RAII 了。&lt;/p>
&lt;h3 id="11-异常安全和-raii">1.1 异常安全和 RAII&lt;/h3>
&lt;p>&lt;code>std::shared_ptr&lt;/code>和其他智能指针类型都在&lt;code>&amp;lt;memory&amp;gt;&lt;/code>头文件里定义，主要的作用是实现自动化的资源管理，基于&lt;strong>RAII&lt;/strong>的理念设计和实现。&lt;/p>
&lt;p>&lt;strong>RAII&lt;/strong>指的是&lt;strong>获取资源即初始化&lt;/strong>，英文全写是&lt;strong>Resource Acquisition Is Initialization&lt;/strong>，属于一种面向对象编程语言中常见的惯用法。&lt;/p>
&lt;p>它的思路是这样子的：初始化即获取资源，离开作用域就自动销毁。&lt;/p>
&lt;p>RAII 解决的问题是，当异常发生时，如何确保资源释放。这是个&lt;strong>异常安全&lt;/strong>的问题。&lt;/p>
&lt;p>常见的非 RAII 风格代码里，如果要确保资源被正确释放，就要用&lt;code>try {} catch() {} finally {}&lt;/code>块捕获异常，然后执行资源释放的代码，再将异常重新抛出。&lt;/p>
&lt;p>而 RAII 的理念是，让资源的生命周期和一个栈上的对象严格绑定，确保栈上对象被析构的时候，资源也就被一同释放了。&lt;/p>
&lt;p>在 C++中，有大量的代码都是以 RAII 风格进行设计的，其中智能指针也是。&lt;/p>
&lt;h3 id="12-stdshared_ptr的实现">1.2 &lt;code>std::shared_ptr&lt;/code>的实现&lt;/h3>
&lt;p>引用计数，大概了解过智能指针的人都能回答得出来。&lt;/p>
&lt;p>虽然说实现方式并没有规定只能是引用计数，但实际上大家都是这么写的，万一哪天有个 GC 实现的&lt;code>std::shared_ptr&lt;/code>也别太震惊。&lt;/p>
&lt;p>实现思路也挺简单。&lt;/p>
&lt;p>所有指向同一实例的&lt;code>std::shared_ptr&lt;/code>应当持有同一个引用计数，来保持所有&lt;code>std::shared_ptr&lt;/code>计数同步，所以它们共同拥有一个计数器指针&lt;code>long *p&lt;/code>。&lt;/p>
&lt;p>在复制时，&lt;code>shared_ptr&lt;/code>管理的对象指针和引用计数器指针被同时复制，然后引用计数器指针保存的引用计数+1——销毁同理，减少引用，直到删除。&lt;/p>
&lt;h3 id="13-stdshared_ptr和copyassignable">1.3 &lt;code>std::shared_ptr&lt;/code>和&lt;code>CopyAssignable&lt;/code>&lt;/h3>
&lt;p>&lt;code>std::shared_ptr&lt;/code>满足&lt;code>CopyContructiable&lt;/code>、&lt;code>CopyAssignable&lt;/code>和&lt;code>LessThanComparable&lt;/code>这些标准库的&lt;a class="link" href="https://zh.cppreference.com/w/cpp/named_req" target="_blank" rel="noopener"
>具名要求&lt;/a>，因此可以作为 STL 容器的元素。&lt;/p>
&lt;blockquote>
&lt;p>顺便一提 &lt;code>Concept&lt;/code> 有很大可能出现在 C++20 标准里。&lt;/p>
&lt;/blockquote>
&lt;h3 id="14-线程安全性">1.4 线程安全性&lt;/h3>
&lt;p>&lt;code>std::shared_ptr&lt;/code>不是线程安全的，不然不满足 C++对&lt;code>Zero Cost Abstraction&lt;/code>的要（吹）求（逼）。&lt;/p>
&lt;p>依据官方说法，多线程访问不同的&lt;code>std::shared_ptr&lt;/code>实例是没问题的（大多容器也是）；多线程访问同一个&lt;code>std::shared_ptr&lt;/code>实例，但是只调用&lt;code>const&lt;/code>方法，那么也是没问题的（多线程读）；多线程访问同一个&lt;code>std::shared_ptr&lt;/code>实例，调用非&lt;code>const&lt;/code>方法，那么会产生数据竞争（多线程读写）。&lt;/p>
&lt;p>如果希望在线程间传递 &lt;code>std::shared_ptr&lt;/code> 得靠 STL 提供的原子操作库&lt;code>std::atomic&lt;/code>。&lt;/p>
&lt;p>&lt;code>std::atomic&lt;/code>可以快速帮助包装一个线程安全的对象或者指针，不过这东西对&lt;code>std::shared_ptr&lt;/code>的特化是目前还在制定的&lt;code>C++20&lt;/code>标准的一部分，所以能不用则不用，直到标准制定完成稳定，并且各编译器支持完善后再行考虑。&lt;/p>
&lt;p>除此之外，如果确实有这方面的考虑，引入&lt;code>boost&lt;/code>是一个不错的选择。&lt;/p>
&lt;p>无论如何，跨线程使用&lt;code>std::shared_ptr&lt;/code>我不怎么支持。&lt;/p>
&lt;p>跨线程传递&lt;code>std::shared_ptr&lt;/code>本身就是个非常危险的行为。&lt;code>std::shared_ptr&lt;/code>作为标准库的一员，背负了 C++的历史包袱，它随时可能被取出裸指针使用，或者意外复制了一次或几次，而这些对线程安全几乎就是意味着作死的行为却没有任何管束。&lt;/p>
&lt;h3 id="15-其他智能指针">1.5 其他智能指针&lt;/h3>
&lt;ul>
&lt;li>&lt;code>std::auto_ptr&lt;/code>&lt;/li>
&lt;li>&lt;code>std::weak_ptr&lt;/code>&lt;/li>
&lt;li>&lt;code>std::unique_ptr&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>其中&lt;code>std::auto_ptr&lt;/code>已经被扫进历史的垃圾堆了，作为替代者，&lt;code>std::unique_ptr&lt;/code>有更明确的语义和更高的可定制性。&lt;/p>
&lt;p>&lt;code>std::weak_ptr&lt;/code>是对于&lt;code>std::shared_ptr&lt;/code>的补充，对于希望使用&lt;code>std::shared_ptr&lt;/code>作为使用了指针的数据结构之间的连接方式，又不希望产生循环引用恶劣情况的一个解决方案。弱指针的存在不影响引用计数工作。&lt;/p>
&lt;p>最后是&lt;code>std::unique_ptr&lt;/code>，它的语义是明确唯一持有某一资源，依照约定，被&lt;code>std::unique_ptr&lt;/code>持有的资源不应该再有第二人持有，&lt;code>std::unique_ptr&lt;/code>是唯一访问该资源的入口。&lt;/p>
&lt;p>这些智能指针都有一个共同点：为了兼容 C 代码，所以它们随时可以被取出裸指针而不影响自身的工作，但这种使用方式造成的一切后果自负。&lt;/p>
&lt;h2 id="2-stdvector">2. &lt;code>std::vector&lt;/code>&lt;/h2>
&lt;blockquote>
&lt;p>面试官：&amp;hellip;知道&lt;code>std::vector&lt;/code>吧？讲讲它是怎么实现的。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>我：vector 保存了一个一定长度的 buffer，当插入时可以避免插入一次就分配一次空间 blabla&amp;hellip;当插入长度超过了 buffer 长度，buffer 会依照内部算法来重新分配一次内存，扩张长度。&lt;/p>
&lt;/blockquote>
&lt;p>回答不全对。其实面试官之后又强调了一次，但面试时没有听出来。&lt;/p>
&lt;blockquote>
&lt;p>面试官：那之前分配的 buffer 呢？&lt;/p>
&lt;p>我：之前分配的 buffer 先复制到新的 buffer 里，然后旧 buffer 会被释放。&lt;/p>
&lt;/blockquote>
&lt;p>这里对于释放旧 buffer 的说法其实是有问题的，可以具体看看下面。&lt;/p>
&lt;h3 id="21-内存布局">2.1 内存布局&lt;/h3>
&lt;p>&lt;code>std::vector&lt;/code>的&lt;strong>内存布局是连续的&lt;/strong>，这一点除了几乎每个人都有所了解之外（&amp;hellip;），标准给出的要求也可以看出点端倪。&lt;/p>
&lt;blockquote>
&lt;p>26.3.11.1 Class template vector overview&lt;/p>
&lt;p>A vector is a sequence container that supports (amortized) constant time insert and erase operations at the end; insert and erase in the middle take linear time. Storage management is handled automatically, though hints can be given to improve eﬃciency.&lt;/p>
&lt;/blockquote>
&lt;p>关键点集中在这里：&lt;/p>
&lt;blockquote>
&lt;p>&amp;hellip; constant time insert and erase operations at the end;&lt;/p>
&lt;/blockquote>
&lt;p>末端插入和删除是常数时间&lt;/p>
&lt;blockquote>
&lt;p>&amp;hellip; insert and erase in the middle take linear time.&lt;/p>
&lt;/blockquote>
&lt;p>中间插入和删除需要线性时间（就是 &lt;code>O(n)&lt;/code>）。&lt;/p>
&lt;p>典型的数组插入和删除的特征，不同的是&lt;code>std::vector&lt;/code>可以变长，所以真正插入大量数据的时候会有多次重新分配内存和复制的操作。&lt;/p>
&lt;h3 id="22-copyassignable的约定">2.2 &lt;code>CopyAssignable&lt;/code>的约定&lt;/h3>
&lt;p>&lt;code>std::vector&lt;/code>要求储存的对象满足&lt;code>DefautConstructible&lt;/code>、&lt;code>CopyContructiable&lt;/code>和&lt;code>CopyAssignable&lt;/code>的具名要求，文档参考&lt;code>26.3.11.1&lt;/code>第 2 节。&lt;/p>
&lt;blockquote>
&lt;p>26.3.11.1&lt;/p>
&lt;p>A vector satisﬁes all of the requirements of a container and of a reversible container (given in two tables in 26.2), of a sequence container, including most of the optional sequence container requirements (26.2.3), of an allocator-aware container (Table 86), and, for an element type other than bool, of a contiguous container (26.2.1).&lt;/p>
&lt;/blockquote>
&lt;p>其中提到的&lt;code>Table 86&lt;/code>中列出了&lt;code>DefaultConstructible&lt;/code>、&lt;code>CopyAssignable&lt;/code>和&lt;code>CopyConstructiable&lt;/code>。&lt;/p>
&lt;p>发挥一下脑洞，这些要求完美符合了之前对于重新分配内存的猜测对不对？&lt;/p>
&lt;p>对象要可以被默认构造，因为&lt;code>vector&lt;/code>的实现可能是&lt;code>new&lt;/code>了一个新的对象数组（更可能是字节数组，到时候再&lt;code>placement new&lt;/code>）；对象要可以被复制构造，因为对象可能被从旧数组移动到新数组；对象要可以被复制构造&amp;hellip;..&lt;/p>
&lt;p>当然更可能的原因是&lt;code>vector&lt;/code>本身是可复制的，上面的就当我吹逼吧。&lt;/p>
&lt;p>除此之外还有&lt;code>CopyInsertable&lt;/code>和&lt;code>MoveInsertable&lt;/code>的具名需求，就像其字面意义那样，不多做解释。&lt;/p>
&lt;h3 id="23-内存重新分配的方式">2.3 内存重新分配的方式&lt;/h3>
&lt;p>对 C 稍有经验的人应该知道 C 语言有一个 API 叫做&lt;code>realloc&lt;/code>，它做的事情是这样的：&lt;/p>
&lt;ol>
&lt;li>如果可能的话，扩张原先分配的内存的长度。&lt;/li>
&lt;li>否则重新分配一块内存，然后把旧的内存复制过去，释放旧内存，返回新指针。&lt;/li>
&lt;li>如果找不到足够长度的连续内存，则返回 NULL，不释放旧内存。&lt;/li>
&lt;/ol>
&lt;p>C++自然不会少。&lt;/p>
&lt;p>面试时没有想起来，本来认为是一种优化方案，但 STL 本身就算是优化方案了吧（&amp;hellip;）。正确的解答应该是&lt;/p>
&lt;blockquote>
&lt;p>用 realloc 的方式尝试扩展 buffer 长度，如果无法扩展长度，则拷贝旧 buffer 到新 buffer，再释放旧 buffer。&lt;/p>
&lt;/blockquote>
&lt;p>还行，失误就是失误，认错复习一遍。&lt;/p>
&lt;h2 id="3-比较三个容器vectormaplist">3. 比较三个容器：&lt;code>vector&lt;/code>,&lt;code>map&lt;/code>,&lt;code>list&lt;/code>&lt;/h2>
&lt;blockquote>
&lt;p>面试官：说说看&lt;code>vector&lt;/code>、&lt;code>list&lt;/code>、&lt;code>map&lt;/code>有什么不同，分别在什么样的上下文环境里去使用它们吧。&lt;/p>
&lt;p>我：vector 可以被随机访问，支持随机访问迭代器，迭代器算法有些不适用在&lt;code>list&lt;/code>和&lt;code>map&lt;/code>上 blabla&amp;hellip;&lt;code>list&lt;/code>通常是链表实现，在插入删除的性能上有优势 blabla&amp;hellip;&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;p>顺便一提还没说到&lt;code>map&lt;/code>，面试官就换话题了。&lt;/p>
&lt;p>这一题我大概又没有 get 到面试官的 point，单谈论容器的话可说的东西不少，我觉得面试官可能更想了解下我对这些容器的性能和内存方面的认知，可惜我答的有些太浅白了。&lt;/p>
&lt;h3 id="31-迭代器">3.1 迭代器&lt;/h3>
&lt;p>先从迭代器的角度比较三个容器。&lt;/p>
&lt;p>&lt;code>vector&lt;/code>是个典型的随机访问容器，显然支持&lt;code>forward iterator&lt;/code>、&lt;code>reversible iterator&lt;/code>和&lt;code>random access iterator&lt;/code>。典型的实现是&lt;a class="link" href="https://en.wikipedia.org/wiki/Dynamic_array" target="_blank" rel="noopener"
>&lt;code>dynamic array&lt;/code>&lt;/a>。&lt;/p>
&lt;p>&lt;code>list&lt;/code>是个线性结构容器，支持&lt;code>forward iterator&lt;/code>、&lt;code>reversible iterator&lt;/code>。典型的实现是链表。&lt;/p>
&lt;p>&lt;code>map&lt;/code>是个树形容器，支持&lt;code>forward iterator&lt;/code>和&lt;code>reversible iterator&lt;/code>。典型的实现是红黑树。&lt;/p>
&lt;h3 id="32-内存布局和访问效率">3.2 内存布局和访问效率&lt;/h3>
&lt;p>讨论常见实现。&lt;/p>
&lt;p>&lt;code>vector&lt;/code>是连续分配，访问成本低，插入和删除的成本高，会重分配内存。&lt;/p>
&lt;p>&lt;code>list&lt;/code>是不连续分配，访问成本高，任意位置插入删除成本相对低，插入删除不会导致重新分配整块内存。&lt;/p>
&lt;p>&lt;code>map&lt;/code>是不连续分配，插入删除访问成本不应和线性容器比较，毕竟它是关联容器。插入删除的成本都比较高，因为需要重新平衡树。访问时间在标准中的要求是对数时间复杂度，插入时间懒得继续翻标准文档了。&lt;/p>
&lt;h3 id="33-使用上下文">3.3 使用上下文&lt;/h3>
&lt;p>显而易见&lt;code>vector&lt;/code>适合高频读，而&lt;code>list&lt;/code>适合大量插入删除，&lt;code>map&lt;/code>和前面两个迭代器都搭不上调，在需要复杂索引的地方再合适不过了。&lt;/p>
&lt;h3 id="34-线程安全性">3.4 线程安全性&lt;/h3>
&lt;p>这些容器都不是线程安全的。&lt;/p>
&lt;p>依照标准，多线程访问不同的容器实例一切都安好，访问同一个实例的&lt;code>const&lt;/code>方法也 ok，但是非&lt;code>const&lt;/code>方法就会引起数据竞争。&lt;/p>
&lt;p>尤其注意迭代器的选择，这玩意儿有时候不比指针好多少。&lt;/p>
&lt;h2 id="4-如何管理内存资源">4. 如何管理内存资源&lt;/h2>
&lt;blockquote>
&lt;p>面试官：你在项目里一般是怎么管理内存的呢？&lt;/p>
&lt;p>我：一个是尽可能用智能指针，然后是需要频繁构造对象的场合下可以用 placement new blabla&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;p>内存管理是一个非常广阔的话题，我的回答太过于浅显了。常见的内存管理策略有很多，智能指针只能算是 RAII 这种常见的范式，placement new 算是内存池/对象池的一种写法大概，还有其他很多策略我并不了解也未能涉及。&lt;/p>
&lt;h3 id="41-再论-raii">4.1 再论 RAII&lt;/h3>
&lt;p>RAII 的范式可以确保异常安全，避免手贱忘记回收内存以及底层设计变更抛出的异常无法处理时导致意外的资源泄露。&lt;/p>
&lt;p>诸如此类等等。&lt;/p>
&lt;p>有一些约定可以关注一下。&lt;/p>
&lt;h4 id="411-获取资源失败抛异常">4.1.1 获取资源失败抛异常&lt;/h4>
&lt;p>首先 RAII 的全写是&lt;strong>获取资源即初始化&lt;/strong>，连资源都没能获取的话，构造理应失败，而不是静默给出一个无效的对象。&lt;/p>
&lt;h4 id="412-析构绝不抛异常">4.1.2 析构绝不抛异常&lt;/h4>
&lt;p>很好理解，如果析构又抛个异常出来的话，这个对象还析构不析构？父类还析构不析构？&lt;/p>
&lt;h4 id="423-常见设计">4.2.3 常见设计&lt;/h4>
&lt;p>在 STL 里除了智能指针以 RAII 设计以外，还有加锁解锁相关的内容也是：&lt;code>std::lock_guard&lt;/code>。&lt;/p>
&lt;p>诸如此类的&lt;code>guard&lt;/code>模式也在其他语言中有出现：比如说 C#的&lt;code>using (var file = File.Open(...)) {}&lt;/code>。&lt;/p>
&lt;h3 id="42-内存池和对象池">4.2 内存池和对象池&lt;/h3>
&lt;p>内存池和对象池算是常见的设计范式，基本考虑到大量对象的构造删除的情况都会考虑到使用这两个模式，因为真的很好用（&lt;/p>
&lt;p>内存池的模式主要是预先分配内存，然后在这片内存上构造对象，主要的适用场景是大量频繁构造小对象，构造成本低，生命周期短，内存分配成本居高不下的情况。当然，不仅是这里提到的场景，根据具体业务逻辑可能还会有不同的理由去选择内存池模式。&lt;/p>
&lt;p>对象池区别于内存池的地方在于，对象池的对象构造成本要更高，频繁构造和析构是无法接受的，这种时候就需要一个候选备用的对象池，对象池实现需要对象本身允许被复用在不同的地方，一般来说性能会比较好。内存池则没这个顾虑：反正你需要就构造一个呗。&lt;/p>
&lt;p>这两个池都可以用&lt;code>factory&lt;/code>模式来提供构造对象的服务，而工厂的消费者不需要了解对象是怎么构造出来的。结合 RAII 的话，内存池、对象池里的对象还可以用一层 RAII 设计的“智能指针”封装，使其完成使命后能自动返还资源，等待下一个工厂访客。&lt;/p>
&lt;h2 id="5-玩过哪些游戏对游戏制作流程了解多少">5. 玩过哪些游戏，对游戏制作流程了解多少？&lt;/h2>
&lt;blockquote>
&lt;p>面试官：喜欢玩游戏吗？都玩过哪些游戏？&lt;/p>
&lt;p>我：我的话&amp;hellip;主要玩的是音游，和贵公司业务可能并没有太多关联。&lt;/p>
&lt;p>面试官：除了音乐游戏，有玩过 RPG、ARPG 类型的游戏吗？&lt;/p>
&lt;p>我：像是辐射啊，老滚啊这些&amp;hellip;开放世界类型的游戏游戏性没那么好，比起来我更喜欢电影式的游戏，比如说最近比较火的《底特律：变人》。&lt;/p>
&lt;p>面试官：&amp;hellip;&amp;hellip;（你丫来捣乱的是吧）&lt;/p>
&lt;p>面试官：说说你对游戏行业的看法吧。&lt;/p>
&lt;p>我：游戏行业前景好啊 blablabla&amp;hellip;娱乐崛起 blabla&amp;hellip;经济增长 blabla&amp;hellip;.&lt;/p>
&lt;p>面试官：&amp;hellip;&amp;hellip;（？？？？）&lt;/p>
&lt;p>面试官：你上一家公司也是制作游戏的吧？就是说，你们游戏制作啊，都有哪方面的人在负责做什么东西，大概是怎么个分工合作的样子。（提醒+强调）
我：哦！哦哦，大概就是一个人负责策划整个游戏的玩法和系统，设计每个细节，然后程序负责去实现，自动测试 blabla&amp;hellip;内部试玩 blabla&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;p>还行，这波操作其实我也是挺佩服自己的。&lt;/p>
&lt;h3 id="51-陷阱玩过哪些游戏">5.1 陷阱：玩过哪些游戏&lt;/h3>
&lt;p>我注意到一件事：在多次面试游戏行业的职位时，都提到这这个问题：&lt;/p>
&lt;blockquote>
&lt;p>你玩过哪些游戏？&lt;/p>
&lt;/blockquote>
&lt;p>也许形式上有所区别：&lt;/p>
&lt;blockquote>
&lt;p>你玩过的游戏里，有哪些特别喜欢的？&lt;/p>
&lt;/blockquote>
&lt;p>换位思考，如果我是面试官，我为什么要问这个问题？我想知道什么？&lt;/p>
&lt;blockquote>
&lt;p>熟悉游戏吗？&lt;/p>
&lt;p>知道游戏有哪些元素吗？&lt;/p>
&lt;p>能理解（我们招你进来要做的游戏）要你做什么吗？&lt;/p>
&lt;/blockquote>
&lt;p>不必太过刻意地表达出对游戏行业的崇拜或者抬高之类的，这一关主要的目的还是引出下文，聊聊对游戏制作流程的理解。如果对面试的公司出的产品有所了解的话可能算是加分项。&lt;/p>
&lt;p>但是，从一个游戏玩家的角度出发，表现出不好的情绪容易留下坏映像——&lt;strong>特别是，绝对不要明显地表达出对国产网游、手游、页游的鄙视！！&lt;/strong>&lt;/p>
&lt;p>从一个玩家的角度出发，我也不喜欢&lt;strong>大部分&lt;/strong>国产的页游手游，但是当着游戏行业公司的面试官的面，表现出&lt;strong>我看不起你&lt;/strong>的态度，知道什么叫作死吗？&lt;/p>
&lt;p>更何况并不是&lt;strong>所有国产游戏&lt;/strong>都是屎，举例来说我现在超喜欢 MUSE DASH 这款国产音游的，手感比兰空 voze、节奏大师之类的好得多，界面也没有像节奏大师那样糊成屎，要不是我的 Unity3D 水平太差我真想给这家 pero pero game 工作室（公司？）投个简历看看。&lt;/p>
&lt;p>除此之外还有就是抱着&lt;strong>拯救国产游戏&lt;/strong>的想法或者态度，又或者&lt;strong>劳资教你们什么才是真正的游戏&lt;/strong>这样的想法或者态度，作死无极限啊。&lt;/p>
&lt;p>比较稳妥的回答方案应该是常见的几个网游，比如说 LOL，DNF，王者荣耀，诸如此类。实际上玩过没玩过&amp;hellip;..咳，不被戳穿就无所谓了。&lt;/p>
&lt;h3 id="52-游戏行业">5.2 游戏行业&lt;/h3>
&lt;p>加班是家常便饭，好像所有游戏行业的公司都会这么说。&lt;/p>
&lt;p>大概了解下几个术语，算是加班界的黑话吧。&lt;/p>
&lt;p>一个是 996。什么意思呢？上午 9 点上班，晚上 9 点下班，一周上 6 天，加班费不用考虑了，不存在的，最多给调休。&lt;/p>
&lt;p>再有一个是大小周。一周上 6 天，一周上 5 天，如此循环。同样，大周加班不算加班费，给调休。&lt;/p>
&lt;p>另外就是调休。如果加班一天，将来某天就可以不扣工资休息一天，直白吧。攒下半年的调休然后一口气给自己放 6 个月假这种事情还是做梦比较好，调休基本上就等于无偿加班了，忙起来的时候劝你别休，不然人手就不够了；那闲下来的时候还能让你一周休 6 天？你敢休公司也不敢让你随便休啊，其他员工怎么看。&lt;/p>
&lt;p>发薪日。网上有人总结，发薪日越接近月中的，或者超过月中的，大多都是怕员工流失的公司，而这些公司往往都不是什么好公司。听起来还是挺有道理的（&lt;/p>
&lt;p>当然，最后还是要靠自己的眼睛去确认这一点。&lt;/p>
&lt;h3 id="53-游戏的制作流程">5.3 游戏的制作流程&lt;/h3>
&lt;p>之前待得确实是一家小公司，甚至算得上工作室级别的超小初创公司，游戏制作方面的知识储备不算充足，写这篇博客的时候又去补习了一下。&lt;/p>
&lt;p>主要的工种分为策划、美术、程序。&lt;/p>
&lt;p>细分的话，策划可能有数值方面的，世界背景人物背景方面的，对话文本方面的，甚至可能有长篇幅的资料啊故事啊这方面的需求。&lt;/p>
&lt;p>美术有 UI 方面的，人物、场景的原画师，3d 模型制作，动画制作，骨骼制作，特效制作，等等方面的。程序经常需要和美术方面的沟通交流。&lt;/p>
&lt;p>程序的话主要分前后端和测试，再加上运维和 DBA 之类的角色。&lt;/p>
&lt;p>细分的话前端根据开发平台不同也有不同的技术栈，图像特效上可能会有更专业的大牛负责，team leader 带队设计架构，分配工作，诸如此类。后端也一样，根据不同的技术抉择，可能整体的人员配置也有所区别，但大家都是程序嘛。&lt;/p>
&lt;p>测试算是比较独立的，编写测试代码是一件很痛苦的事情（&lt;/p>
&lt;p>所以这份疼痛有专人负责承受了：）&lt;/p>
&lt;p>持续集成啊什么的也被承包了，测试或者运维会去负责的。&lt;/p>
&lt;p>DBA 一般公司也用不到，运维多少会两手 SQL，规模更大的公司可能会设置这个专门职位。&lt;/p>
&lt;p>流程上来说，策划给出游戏方案，美术可能会配合做个初稿效果图之类的（更可能是策划自己做个简单的效果图之类的方便说明），程序疯狂实现（崩溃-爆发-认命 循环），测试则配合给出反馈，让程序的脱发状况持续恶化，最后发布，项目黄了。&lt;/p>
&lt;p>哦不是，我是说项目火了，程序们一跃成为 CTO，迎娶白富美，走上人生巅峰。&lt;/p>
&lt;p>（并没有）&lt;/p>
&lt;h2 id="6-尾声">6. 尾声&lt;/h2>
&lt;p>其实这次面试的自我感觉还是不错的，没有犯下太蠢的错误，但是可以改进的地方依然很多，语言组织能力需要进一步提高。&lt;/p>
&lt;p>这篇博客的目的是自我反省，但是这次自我反省的效果并不算好，因为面试官的问题基本上都戳在我懂，但又没真正去深入挖掘的领域。日常使用自然没有问题，但理解却谈不上了。&lt;/p>
&lt;p>如果面试官在细节上稍作追究：比如说 placement new 和 user-defined new 之类的话题上深入，异常安全，或者问个 map 用红黑树实现，红黑树什么原理，那么这次我基本又要挂了。&lt;/p>
&lt;p>关于给出的待遇的问题&amp;hellip;&amp;hellip;我其实很好奇&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>因为我真的才工作一年，不懂啊&amp;hellip;&lt;/p>
&lt;p>一年工作年限，C++我也不知道算什么水平，不知道怎么去横向对比，要 8k 是要多了么&amp;hellip;&lt;/p>
&lt;p>初级职位的意思是待遇初级还是能力初级啊&amp;hellip;&lt;/p>
&lt;p>还有主程一般指的是 team leader 对吗，游戏行业程序是不是干到 team leader 就算到头了&amp;hellip;只能转管理岗了&amp;hellip;&lt;/p></description></item></channel></rss>