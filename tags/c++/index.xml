<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c++ on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/tags/c++/</link><description>Recent content in c++ on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 15 Feb 2022 17:11:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>CPU缓存、缺页和伪共享</title><link>https://nnnewb.github.io/blog/p/cpu-cache-page-fault-and-false-sharing/</link><pubDate>Tue, 15 Feb 2022 17:11:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/cpu-cache-page-fault-and-false-sharing/</guid><description>前言 看B树的时候发现对缓存还是不够了解，但 cache line 又很神奇。要是有些比较吃CPU的代码改一下结构和访问方式啥的就能白嫖个50%性能提升那岂不是美哉。结合下面的参考文章大概聊一下。
Gallery of Processor Cache Effects 缓存行 介绍 首先，缓存行不是“行”，这是对 cache line 的直译，cache line 和 cache block 是同义的，忽略这个“行”字即可。
cache line 指的是 CPU 高速缓存（L1~L3）中的一个缓存块，通常大小在 32/64/128 bytes ，现在常见的应该是 64 bytes 。cache line 之所以重要，是因为这是 CPU 访问主存的必经之路，频繁访问主存数据的场合，或者并发编程时，cache line 的影响还是不容忽视的。
简单的基准测试 光是说 cache line 多重要没有卵用，写个 demo 看看 cache line 的影响更直观。来一个最简单不过的单链表遍历。
#include &amp;lt;chrono&amp;gt;#include &amp;lt;cstddef&amp;gt;#include &amp;lt;functional&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;iterator&amp;gt;#include &amp;lt;ostream&amp;gt;#include &amp;lt;string&amp;gt; using namespace std; using namespace std::chrono; typedef struct _data { struct _data *next; int value; } mydata; void time_it(const std::string name, function&amp;lt;void(void)&amp;gt; fn) { auto start = system_clock::now(); fn(); auto stop = system_clock::now(); cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34;: &amp;#34; &amp;lt;&amp;lt; duration_cast&amp;lt;milliseconds&amp;gt;(stop - start).</description></item><item><title>密码学入门02 - 古典密码#2</title><link>https://nnnewb.github.io/blog/p/cryptography-introduction-02/</link><pubDate>Thu, 11 Nov 2021 16:53:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/cryptography-introduction-02/</guid><description>前言 从单表代替密码开始，继续学习古典密码。
0x01 playfair 密码 playfair 这个词乍一听我甚至有点迷惑，啥意思，公平竞赛吗。之后才知道原来是人名。
概述 playfair 密码是最著名的多字母代替密码，它把明文中的字母对转换成密文的字母对，每次加密输入两个字母，输出两个字母。
playfair 算法基于一个由密钥词构成的 5x5 字母矩阵，将密钥词去除重复字母后，和字母表剩余的字母按左至右、上至下的顺序填充进表里。
举例来说，用 pojie 作为密钥词。
- - - - - p o j i e a b c d f g/h k l m n q r s t u v w x y z 需要注意的是字母表有26个字母，但 playfair 的字母矩阵只有 25 个空格。出现字母表不是 5 的整数倍的情况时可以选择将多出来的字母视作同一个，或者去掉不常用的字母，使其正好填满矩阵。比如图中的g/h，好孩子不要学哦。常见的情况是i/j或者去掉z或q。</description></item><item><title>密码学入门01 - 古典密码#1</title><link>https://nnnewb.github.io/blog/p/cryptography-introduction-01/</link><pubDate>Thu, 11 Nov 2021 11:35:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/cryptography-introduction-01/</guid><description>前言 本文是学习《密码编码学与网络安全》一书的笔记，关于传统加密技术一章。
0x01 对称密码模型 对称加密，也称传统加密或单钥加密，是20世纪70年代公钥密码产生之前唯一的加密类型。迄今为止，它仍是使用最广泛的加密类型。
对称加密方案有5个基本成分：
明文：原始可以理解的消息或数据，是算法的输入。 加密算法：加密算法对明文进行各种代替和变换。 密钥：密钥也是加密算法的输入。密钥独立于明文和算法。算法根据所用的特定密钥而产生不同的输出。算法所用的确切代替和变换也依靠密钥。 密文：作为算法的输出，看起来完全随机而杂乱的消息，依赖于明文和密钥。对于给定的消息，不同密钥产生不同的密文，密文看上去是随机的数据流并且其意义是不可理解的。 解密算法：本质上是加密算法的逆运算。输入密文和密钥，输出原始明文。 image-20211110140236382
传统密码的安全使用要满足两个要求：
加密算法必须是足够强的。即使攻击者拥有一定数量的密文和产生这些密文的明文，他也不能破译密文或发现密钥。 发送者和接收者必须在某种安全的形式下获得密钥并保证密钥安全。如果有人发现密钥，并知道算法，就能解读使用该密钥加密的所有通信。 我们假设基于已知密文和加密/解密算法而破译消息是不实际的，我们不需要算法保密，仅需要密钥保密。如果密钥是由信息的发送方产生的，那么它要通过某种安全信道发送到接收方；另一种是由第三方生成密钥后再安全地分发给发送方和接收方。
// 明文X，共 m 个元素 byte[m] X = {X1,X2,X3,X4,...,Xm}; // 密钥K，共 j 个元素 byte[j] K = {K1,K2,K3,K4,...,Kj}; // 加密算法E，以明文和密钥为输入，输出密文 Y byte[n] Y = E(X, K); // 解密算法D，以密文和密钥为输入，输出明文 X byte[] X = D(Y, K); 1.1 密码编码学 密码编码系统有三个独立特征：
转换明文为密文的运算类型。所有的加密算法都基于两个原理：代替和置换。代替是将明文中的每个元素（如位、字母、位组或字母组）映射成另一个元素；置换是将明文中的元素重新排列。上述运算的基本要求是不允许有信息丢失（所有运算都是可逆的）。大多密码体制也称为乘积密码系统，都使用了多层代替和置换。 所用的密钥数。如果发送方和接收方使用相同的密钥，这种密码就称为对称密码、单密钥密码或传统密码。如果发收双方使用不同的密钥，这种密码就称为非对称密码、双钥或公钥密码。 处理明文的方法。分组密码每次处理输入的一组元素，相应地输出一组元素。流密码则是连续地处理输入元素，每次输出一个元素。 攻击密码系统的典型目标是恢复使用的密钥，而不仅仅恢复出单个密文对应的明文。攻击传统密码有两种通用的方法。
密码分析学：密码分析学攻击依赖于算法的性质、明文的一般特征或某些明密文对。这种攻击形式企图利用算法的特征来推导出特定的明文或使用的密钥。 穷举攻击：攻击者对一条密文尝试所有可能的密钥，直到把它转化为可读的有意义的明文。平均而言，获得成功至少要尝试所有可能的密钥的一半。 基于密码分析者知道的信息的多少，概括密码攻击的几种类型如下。
攻击类型 攻击者已知的信息 唯密文攻击 加密算法；密文； 已知明文攻击 加密算法；密文；与待解密密文同一密钥加密的一个或多个明密文对； 选择明文攻击 加密算法；密文；分析者选择的明文，以及对应的（使用和待解密密文同一密钥）加密的密文； 选择密文攻击 加密算法；密文；分析者选择的密文，以及对应的（使用和待解密密文同一密钥）的解密明文； 选择文本攻击 加密算法；密文；分析者选的明文，以及对应的密文；分析者选择的密文，以及对应的明文，使用和待解密密文同一密钥。 唯密文攻击最容易防范，但很多情况下分析者可以得到更多的信息。比如 postscript 格式加密的文件总是以相同的格式开头，电子金融消息往往有标准化的文件头或者标志，类似的例子还有很多，这些都是已知明文攻击的例子。有这些知识的分析者就可以从转换明文的方法入手来推导出密钥。</description></item><item><title>加壳原理08：混淆技术入门</title><link>https://nnnewb.github.io/blog/p/learning-packer-08/</link><pubDate>Wed, 03 Nov 2021 16:54:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-08/</guid><description>前言 本篇尝试学习通过动手写一个 LLVM Pass 来学习编译阶段进行代码混淆的技术。
0x01 环境设置 LLVM 是个相当大的项目，做好环境设置是首先要做的事情。这里选择 msys2 作为首要开发环境，不然光是 MSVC 把 LLVM 源码编译一遍就够呛了。
安装好MSYS2之后安装 clang 工具链（2021年11月3日，clang32工具链默认不在msys2的源里，需要手动改 pacman.conf 加入 clang32 源，这里以 x86_64 的 LLVM 工具链进行实践）。
pacman -Sy mingw-w64-clang-x86_64-toolchain 完成后添加环境变量，把 msys2 安装目录下的 clang64/bin 加入环境变量，方便 VSCode + CMake 找到工具链。另外注意装一个 Ninja，同样加入 Path。
VSCode 里装上微软的 C/C++ 和 clangd，禁用微软 C/C++ 的 Intellisense，实在太慢。
手动编译整个LLVM源码树实在是太费时间了，我选择用MSYS2的工具链。参考这篇文档去配置一个 LLVM 源码树外的 Pass 工程：CMake out of source pass - LLVM 。写一个简单的 CMakeLists.txt ，跟着 Writing an LLVM Pass - LLVM 这篇文档快速实现一个遍历函数的 Pass 。</description></item><item><title>加壳原理07 - 花指令入门</title><link>https://nnnewb.github.io/blog/p/learning-packer-07/</link><pubDate>Sun, 31 Oct 2021 17:14:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-07/</guid><description>前言 个人浅见，一般分析一个程序可以有动态和静态两条路，动态一般指的就是调试或者别的运行时跟踪程序行为的方式了，除了调试器外就是抓取事件、日志、API调用记录、看内存数据等，比如有 Frida，还有内存搜索如CE。静态则是用各种工具在不实际运行程序的前提下，从程序文件里提取有用的信息。
对于运行时的对抗手段很多，毕竟程序都跑起来了，你来我往打擂台嘛。而且在Windows这个闭源平台上，还可以靠不大可能被动手脚的内核来保护自己，Linux上就可能内核都是被魔改过的。
但是对静态分析就没有什么特别好的办法，又要人造的计算机能正确运行，又要人不能理解，就有点矛盾。
广为人知的对抗静态分析的手段有这些：
混淆，把程序逻辑转换成更晦涩但等价的形式。 加花，对抗反汇编引擎，利用反汇编工具的算法缺陷、漏洞来迫使分析者必须花费大量时间处理错误的反汇编结果，让诸如控制流视图之类的工具失效。 混淆和加花的主要区别 在我这 定义为 混淆是变换原程序逻辑，花指令不改变原程序逻辑 。
这些对抗手段主要的目的都是 消磨耐心 和 拖延时间 ，抬高人肉分析的成本。但混淆加花这种手段是无法做到只让机器读懂代码而人读不懂这种效果的。这个结论忘了是哪篇论文里提到的了。
本篇只讲如何对抗反汇编，也就是花指令技术。
0x01 花指令原理 1.1 机器码指令格式 码农日常工作接触的是高级语言（这个概念可能有争议，反正相对汇编、机器码这个层级来说都是高级语言就对了），汇编和机器码这种满是历史尘埃的领域是绝无机会接触的。但要理解花指令，首先要理解汇编代码的二进制表示，才会明白为什么反汇编工具的力量是有极限的。
zHClf
这是 Intel 的 64-ia-32-architectures-software-developer-instruction-set-reference-manual 里的一张图，说明了汇编指令如何以二进制形式保存。可以简单看成3部分，1字节的可选前缀，1-3字节的opcode部分，剩余描述操作数的部分。
几个要素：
指令长度不固定，最短 1 字节，最长可能有 14 （图中全部相加，实际会不会有我就不知道了）。 一条汇编代码里的指令可能对应很多不同的 opcode ，简单到 add 这样的指令也会有很多种不同形式。 熟悉机器码格式在自己构造花指令的时候大概会有用，但实话说 Intel 这手册看得我头痛。所以还是直接快进到花指令原理。
1.2 花指令原理 花指令的英文是 junk code ，也就是垃圾代码。实际上花指令的确是一些不影响程序逻辑的 垃圾 机器码，它存在的唯一意义就是干扰反汇编引擎和人肉分析。
花指令有两种类型：
不可执行的花指令 可执行的花指令 听起来像是废话但实际上构造这两种花指令的难度是完全不一样的。
对于不可执行的花指令，本质上我们做的事情是在跳转指令之后插入一个多字节指令的字节，欺骗反汇编器将这个字节之后的几个字节当成一个多字节指令解释，进而造成后续指令反汇编出错。
而可执行的花指令，本质是将指令的组成部分重新解释执行。像是一个2字节的跳转指令，第二个字节是操作数，但操作数可以是 0xff，也就是带符号的 -1，使 EIP 落在 0xff 这个字节上，将0xff作为指令继续执行。这个过程中0xff既可以被当成数字0xff解释，也被当成了指令来解释。</description></item><item><title>加壳原理06：反调试技术入门</title><link>https://nnnewb.github.io/blog/p/learning-packer-06/</link><pubDate>Wed, 27 Oct 2021 19:50:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-06/</guid><description>前言 反调试技术，往大了说是用尽一切手段防止运行时对程序的非法篡改和窥视，往小了说就是防调试器。反正反调试这件事和各种技术都能搭点边，什么HOOK啦DLL注入啦。真要给涉及到的各方面都说得头头是道，那我这个菜鸡就不叫菜鸡了。
反正涉及的各种技术细节吧，将来都会慢慢学到的。也不急于一时。本篇关注的重点还是在导，引入，了解个大概。看看有什么反调试思路，对付这些反调试技术又有什么 bypass 的手段。
说这么多，其实还是找了篇写得不错的外文文章，抄了然后调试了下案例。
0x01 反调试思路 首先概述一下本篇主要的反调试思路。
1.1 系统API或数据结构 操作系统提供了一些调试标志位，调试器启动的进程会有标识。调试器也可能会为了提供更好的调试体验，修改一些参数，让我们有迹可循。
PEB-&amp;gt;BeingDebugged和IsDebuggerPresent PEB-&amp;gt;NtGlobalFlag PEB-&amp;gt;HEAP-&amp;gt;Flags和PEB-&amp;gt;HEAP-&amp;gt;ForceFlags CheckRemoteDebuggerPresent NtQueryInformationProcess ProcessDebugPort ProcessDebugObjectHandle ProcessDebugFlags ProcessBasicInformation NtSetInformationThread和NtCreateThreadEx 利用 HideFromDebugger 标志位来对调试器隐藏自身。 1.2 SEH、VEH 总的来说，利用 SEH 和 VEH 机制，尝试抛出一些会被调试器处理的中断或异常，同时自己挂一个处理函数，如果异常被调试器捕获了，那自己挂的异常处理函数就不会被调用，借此判断是否有调试器正在调试程序。
TF标志位和INT 1中断 INT 3 中断和 SEH 处理函数，__try __except 或 MinGW 的 __try1 __except1，顺便一提我的SEH实验没成功。但是 VEH 基本没问题。 DBG_PRINTEXCEPTION_WIDE_C和DBG_PRINTEXCEPTION_W，Windows 10 OutputDebugString 利用了这个 Exception 来抛出调试字符串。 EXCEPTION_INVALID_HANDLE 1.3 调试寄存器 GetThreadContext 获取当前上下文，判断 Dr0-Dr3寄存器的值。
1.4 完整性校验 原理是调试器通过临时修改断点处指令为中断来取得程序控制权，可以用CRC校验，或者更简单点，直接逐字节求和，判断代码是否被篡改。</description></item><item><title>加壳原理05：利用图片隐藏</title><link>https://nnnewb.github.io/blog/p/learning-packer-05/</link><pubDate>Thu, 21 Oct 2021 21:17:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-05/</guid><description>前言 完成了简单的压缩壳之后放松下，在52论坛病毒分析区看到过几次把代码隐藏到图片里的做法，也看到过把程序转成图片后训练神经网络来判断有没有恶意的，于是就想，淦，这不是挺好玩的嘛。
0x01 思路 用图片保存程序最简单的做法就是直接把程序每个字节都转成像素，然后输出成灰度图。比较进阶的做法就像是二维码了，大色块，容错校验，图片被压到包浆也能扫出来。但那个有点点难（我菜）最终成果也大到不现实，而且实话说打包到程序里就不用考虑被二次压缩的情况了。所以简单的8bit灰度图就刑。
说到位图肯定有人想到了 BMP ，我记得上学那会儿还跟着网上哪儿找的教程，学着用 ffmpeg 把 Bad Apple 转成位图序列，再转成字符图合并成 HTML，用 js 播放。说起来都是泪。
现在已经成了正经的码农，再折腾 BMP 就没意思了，PNG 就挺好的。
图片可以放到 Section 里——但并没有意义，所以我选择放到资源里。写一个 .rc 文件用 windres 编译出目标文件，再拿 gcc 链接就行了。如此一来并没有 lief 出场的机会，编译好的加载器就是加完壳的程序。
加载器则采用开启 ASLR 的模式，这样程序的节表会比较干净，没有明显特征（虽然也没什么卵用）。
0x02 加载器 2.1 资源介绍 参考微软的文档 Using Resources、Menu and Other Resources。
A resource is binary data that you can add to the executable file of a Windows-based application. A resource can be either standard or defined. The data in a standard resource describes an icon, cursor, menu, dialog box, bitmap, enhanced metafile, font, accelerator table, message-table entry, string-table entry, or version information.</description></item><item><title>加壳原理04 - zlib压缩壳案例</title><link>https://nnnewb.github.io/blog/p/learning-packer-04-zlib-compression-packer-demo/</link><pubDate>Wed, 20 Oct 2021 16:07:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-04-zlib-compression-packer-demo/</guid><description>前言 本文在前一篇基础上，写一个使用 zlib 的压缩壳案例。
0x01 zlib 解压 1.1 概述 关于 zlib 的用法找了这些参考资料：
zlib.net/zpipe.c zlib Usage Example Compress and Decompress a string with zlib 尝试了 zlib、lzo、Windows Compression API，对压缩和解压 API 的基本模式的基本认识大概是这样：
首先，你得有被压缩数据的大小（要么分块压缩，要么有整个压缩后的大小） 然后得有解压后的预期大小，这个能通过 尝试解压 的操作来实现。比如 Windows Compression API 和 lzo 都可以在解压 buffer 传 NULL，尝试取得解压后的大小，再分配好内存解压。 zlib 这样的流式压缩、解压处理文件比较友好，但全程在内存里进行的话，流式解压就会导致大量内存分配 =。= 除非一开始就分配足够的空间，不然一个一个内存块申请和合并会很蛋疼。 1.2 内存布局 压缩后的 .packed 节在头部留出 8 个字节，分别保存压缩后大小和压缩前大小，以便一次分配好内存完成解压。
偏移 大小 内容 0 DWORD 小端序，压缩后大小 4 DWORD 小端序，压缩前大小 8 可变 压缩后的数据 1.</description></item><item><title>加壳原理03 - 支持没有重定位的程序</title><link>https://nnnewb.github.io/blog/p/learning-packer-03-support-no-relocations/</link><pubDate>Wed, 20 Oct 2021 10:25:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-03-support-no-relocations/</guid><description>前言 距离上一篇加壳原理已经过去挺久了，这段时间稍微折腾了一下 nasm，尝试手工制作了 PE32 文件，积累了一些基本的知识吧。
所以现在继续学习加壳——如何对不支持 ASLR 的 PE32 程序进行加壳？
0x01 关于ASLR ASLR是一项内存保护技术，用于防范内存损坏漏洞，比如缓冲区溢出。需要注意的是 ASLR 并不是 解决 了相关威胁，而是让利用相关的漏洞变得更加困难和具有挑战性。
ASLR 的全名是 Address Space Layout Randomization ，地址空间布局随机化技术。一个典型的 PE32 程序在没有 ASLR 支持的情况下， 地址空间布局是确定的：程序镜像总会加载到固定的地址。这个地址会在文件头里指定。攻击者可以利用这一特点来构造恶意数据，让存在内存损坏漏洞的程序按攻击者意图跳过或执行特定逻辑，造成安全威胁。
对应 ASLR 的地址空间布局随机化，程序需要再次编译来支持重定位 Relocation ，别无他法（大概）。
0x02 思路 对于加壳一个没有重定位，不支持 ASLR 的 PE32 程序，假设这个程序的基址是 0x04000000，原先的 VirtualAlloc 方式分配内存是行不通的。加壳后程序若开启 ASLR，则 0x04000000 可能已经存在其他模块，并不能保证这个基址可用。所以加壳后的程序必须也使用 0x04000000 这个基址，而且标记为不支持 ASLR，避免基址已经被其他模块使用造成加载器无法工作。
将加壳后程序的基址设置为固定的 0x04000000 又会产生新的问题：加载器的代码段不能放在 0x04000000 ，否则加载器运行时就会出现被被加载的代码覆盖的情况，导致程序跑飞。所以编译后的加载器所有 Section 都必须有一定的偏移，这个偏移值就是被加载程序的 Section 大小之和（对齐后）。而因此多出来的空间单独分成一个 Section ，正好用来放要加载的程序。
另外，还必须确认文件头大小是否一致，因为我们需要将被加载程序的文件头覆盖加载器的文件头。而最开始预留的空间必须分配为一个 Section，让 Windows 的加载器能顺利加载程序而不报“不是有效的Win32程序”错误。
内存布局示意图如下：
内存布局
所以加载器的加载步骤如下：</description></item><item><title>编译LIEF的各种姿势</title><link>https://nnnewb.github.io/blog/p/how-to-compile-lief-on-windows/</link><pubDate>Fri, 08 Oct 2021 16:25:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/how-to-compile-lief-on-windows/</guid><description>前言 惯例得有个前言。
LIEF是一个二进制文件分析和操作库，官方推荐的是 Python 版本，确实更好用，就是类型的问题有点多，而且没附送 .pyi 导致不大好写。而C++版本就没这问题，C++版本有自己的问题=，=
一个是官方提供下载的SDK是静态链接的，用到SDK的程序必须指定 /MT 不然编译器就会抱怨运行库不匹配。虽然看issue里已经有人解决了（-DLIEF_USE_CRT_{DEBUG,RELEASE}=MD/MT），但CI还是老样子，反正直接下载的SDK用起来就蛋疼，vcpkg 全都是 /MD 链接的，没法配合用。
更别提 MinGW 了，就没官方的SDK。
以上就是问题，解决问题的最简单办法就是自己编译了。
0x01 Visual C++ 工具链 msbuild 代码下载下来之后，用 CMake 去编译。下面的命令都是 Powershell 下的，注意折行用的是反引号 backquote，就是波浪号那个键，和 bash 用 反斜杠不一样。直接复制到命令行是跑不起来的。
cmake .. -G &amp;#34;Visual Studio 2019&amp;#34; # Generator，你的工具链，可以用 cmake --help 来看看有哪些可用的 -A Win32 # 选择 Visual C++ 工具链的情况下可以用 -A Win32 选择编译32位代码，或者 Win64 -DCMAKE_BUILD_TYPE=Debug # 常用的 Debug/Release/RelWithDebInfo -DLIEF_PYTHON_API=off # 不编译 Python 模块，这样就不用装 Python 了 -DLIEF_USE_CRT_DEBUG=MD # 使用 /MD 链接 msvcrt.dll 而不是 libcmt 这儿有个坑，用 Visual Studio 这个 Generator 的时候，虽然指定了 CMAKE_BUILD_TYPE，但实际没什么卵用，还得在编译的时候给参数 --config Debug 才会真的按 Debug 编译。</description></item><item><title>一个安卓应用的逆向分析</title><link>https://nnnewb.github.io/blog/p/%E4%B8%80%E4%B8%AA%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</link><pubDate>Tue, 29 Dec 2020 14:04:02 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E4%B8%80%E4%B8%AA%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</guid><description>说起来也不算什么新鲜的东西，现成的工具拼拼凑凑就搞定了，单纯算是点亮了新的技能。
待破解应用的名字不透露了，避免引火烧身。
需要准备的工具包括
mumu 模拟器(或者别的什么有 root 权限、能装 xposed 的模拟器) FDex2 脱壳 jadx 反编译 dex 源码 apktools 拆解 apk mitmproxy 中间人拦截网络请求 0x01 目标和方向选择 首要的目标是破解这个软件的 api 加密。
使用 mitmproxy 抓到 https 流量，发现请求体全部是 base64 ，解码发现乱码。基本断定是加密了。
mitmproxy 怎么抓 https 流量不多说了，基本流程就是装证书，然后配置代理。能看到有流量进 mitmproxy 就算成功了。
直接参考 mitmproxy 的文档快一点。
01
搜了一圈没有什么现成的对这个 App 的破解的文章，于是决定自己动手。
0x02 解包和脱壳 先确认下电脑上装了 JDK 或者 JRE ，没有的话就装好。
推荐一个 vscode 的插件，apklab。会帮你装好 jadx 和 apktools / signer 这些工具。
接下来直接用 apklab 打开需要破解的 apk 文件。</description></item><item><title>在C++中嵌入Python解释器</title><link>https://nnnewb.github.io/blog/p/%E5%9C%A8c-%E4%B8%AD%E5%B5%8C%E5%85%A5python%E8%A7%A3%E9%87%8A%E5%99%A8/</link><pubDate>Fri, 07 Feb 2020 21:59:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E5%9C%A8c-%E4%B8%AD%E5%B5%8C%E5%85%A5python%E8%A7%A3%E9%87%8A%E5%99%A8/</guid><description>先不说废话，项目地址：https://github.com/nnnewb/CQPy 。欢迎给个 Star 什么的。
背景 想给最近在玩的酷 Q 写个插件，发现没有合适的直接使用 Python 的解决方案。
Richard Chien 提供了一个比较通用的插件，CQHttp。CQHttp本体是用 C++ 编写的插件，将酷 Q 的回调包装成 HTTP 请求转发至指定的地址，支持http和websocket两种协议。
不过由于个人想折腾折腾的想法，打算试试把 Python 解释器直接嵌入到 C++ 里得了。
整个思路如下。
graph LR; CQP[酷Q] --事件回调--&amp;gt; dll[插件DLL]; dll --事件回调--&amp;gt; python[Python脚本]; python --调用API--&amp;gt; dll; dll --调用API--&amp;gt; CQP; 依赖 为了简化操作 Python 接口，我没有使用 Python 自带的 C API，而是pybind11，使用vcpkg管理依赖。
安装命令：
vcpkg install pybind11:x86-windows 0x1 编译 DLL 我使用 CMake 作为编译系统，因此可以很简单地写一个编译出 DLL 的 CMakeLists.txt
cmake_minimum_required(VERSION 3.15)project(top.weak-ptr.cqpy LANGUAGES CXX VERSION 0.1.0)include_directories(src)aux_source_directory(src SOURCES)set(CMAKE_CXX_STANDARD 17)# 引入 pybind11 find_package(pybind11 CONFIG REQUIRED)# 添加 target set(OUT_NAME &amp;#34;app&amp;#34;)add_library(${OUT_NAME} SHARED ${SOURCES})set_target_properties(${OUT_NAME} PROPERTIES LINKER_LANGUAGE CXX)target_link_libraries(${OUT_NAME} PRIVATE pybind11::embed)源代码使用 MSVC 和 MinGW 编译，另外再处理下源码编码的问题和宏。</description></item><item><title>GameHollywood 面试笔记</title><link>https://nnnewb.github.io/blog/p/gamehollywood-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</link><pubDate>Tue, 26 Jun 2018 17:22:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/gamehollywood-%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</guid><description>Intro 面试的职位是 C++后端开发工程师，主要聊的还是 C++。在过程中自我感觉面得还行，至少没上次那么蠢。
聊的内容主要集中在 STL 和线程安全、资源管理的层面。
惯例的，填完面试信息表并简历一起上交，然后等面试官来客套完，就开始聊技术了。
注意，面试官的提问并非原话，有修饰和脑补。
0. 预热：你用哪个版本的 C++？ 客套话什么的就略了。
面试官：&amp;hellip;行，那我们就聊聊 C++吧。你常用哪个版本的 C++？
我：我比较常用的是 C++11。
C++版本这个问题面试里应该不多见，不过作为引入的话题还行，标准之神会瞑目的。
对于C++版本这个词，很大概率上大家说的应该就是 C++标准委员会WG21制定的 C++标准了，最新版本的标准文档是 C++17 定稿N4659，制定中的 C++20 标准文档可以访问WG21/docs/papers/2018查阅。
需要注意的是，如果答成了我用 VC6之类的骚话，很大概率会留下不好的映像——或者对方也是忠实的 VC6 神教教徒的话，达成共识也说不定。
闲话少叙。
1. 起手式：std::shared_ptr 面试官：说说std::shared_ptr是怎么实现的？一般怎么去使用它？
答：shared_ptr是通过引用计数实现的，它可以作为容器元素，在程序里传递 blabal&amp;hellip;..而且shared_ptr不是线程安全的，它不能跨线程传递，要额外做一层包装 blabla&amp;hellip;&amp;hellip;
正巧最近有想写一篇智能指针相关的博客，面试官的第一问就提到了。
说到智能指针，就必须提一下 RAII 了。
1.1 异常安全和 RAII std::shared_ptr和其他智能指针类型都在&amp;lt;memory&amp;gt;头文件里定义，主要的作用是实现自动化的资源管理，基于RAII的理念设计和实现。
RAII指的是获取资源即初始化，英文全写是Resource Acquisition Is Initialization，属于一种面向对象编程语言中常见的惯用法。
它的思路是这样子的：初始化即获取资源，离开作用域就自动销毁。
RAII 解决的问题是，当异常发生时，如何确保资源释放。这是个异常安全的问题。
常见的非 RAII 风格代码里，如果要确保资源被正确释放，就要用try {} catch() {} finally {}块捕获异常，然后执行资源释放的代码，再将异常重新抛出。</description></item><item><title>可重入和异步安全</title><link>https://nnnewb.github.io/blog/p/%E5%8F%AF%E9%87%8D%E5%85%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E5%AE%89%E5%85%A8/</link><pubDate>Sun, 24 Jun 2018 22:48:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E5%8F%AF%E9%87%8D%E5%85%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E5%AE%89%E5%85%A8/</guid><description>这篇博客主要记录的是关于可重入性的相关定义，以及关于并发安全的思考。
可重入性 在不同语言中，由于语言标准以及运行期环境规定的不同，可重入性的具体定义可能有所不同。这里聊的是 C++语言中的可重入性。
所谓可重入性（reetrant），指的是同时具备并发安全和中断安全的特征，这是目前为止我对可重入性的认识，也是这篇博客在写下时给可重入性下的定义。
这个认知可能并不准确，因为在wiki上的定义是这样的。
若一个程序或子程序可以「在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错」，则称其为可重入（reentrant 或 re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合設計時預期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。
但是在很多中文博客里，聊到可重入性的时候往往也会把并发安全混为一谈。实际上来说的话&amp;hellip;&amp;hellip;一个可重入的函数，常常也是并发安全的。
那么先从并发安全讲起吧。
并发安全性和可重入性 所谓并发安全已经是老生常谈了。
以一段非常简单的代码为例，我们打算初始化一个对象，这个对象被两个线程共享。
void initialize(Something** someshit) { if(!*someshit) { *someshit = createSomeShit(); } } 显而易见，如果线程在执行到特定环节时发生了切换
void initialize(Something** someshit) { if(!*someshit) { // &amp;lt;-------- 线程切换 // 线程2() { // initialize(something); // } // 线程切换 ---------&amp;gt; *someshit = createSomeShit(); } } 那么 createSomeShit这段代码就会被执行两次。
显然这和我们预期的行为不符。
这里要聊的不是并发，而是&amp;hellip;&amp;hellip;可重入性。所以我们再看看这个函数能否被重入。
按照 wiki 提供的定义，函数可重入指的是
在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错。
符合吗？不。为什么？因为同样在那个线程切换的位置上中断，然后再另一段代码里再次执行这个函数，也会触发同样的问题，导致createSomeShit被执行两次。
void initialize(Something** someshit) { if(!</description></item><item><title>鲸鱼游戏面试笔记</title><link>https://nnnewb.github.io/blog/p/%E9%B2%B8%E9%B1%BC%E6%B8%B8%E6%88%8F%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</link><pubDate>Wed, 20 Jun 2018 19:15:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E9%B2%B8%E9%B1%BC%E6%B8%B8%E6%88%8F%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/</guid><description>Intro 简单介绍下面试的前置情况。
面试的公司是鲸鱼游戏，职位是后端开发工程师，开发语言 C++。
这篇博文主要是为了记录面试中发现的自身不足。
这次面试里，因为面试约得比较匆忙，所以基本没做任何准备。讲道理的说我是有点盲目自信了，毕竟 C/C++是我的第一语言来着，本来以为考察语言的部分不会有什么问题，但没想到因为紧张而错漏百出。
那么接下来就直接进入正题，以下是对面试中遇到的问题重新思考后的回答和想法。
下面面试官的提问并非原话，有经过脑补润色。
起手式：面向对象 面试官：讲讲面向对象，继承，还有多态。我们都知道程序设计有两种常见的范式，面向过程和面向对象，讲讲面向对象给我们带来了什么好处？
实话说第一问就已经有点出乎意料，但想想其实还是在意料之中。初级职位更注重于基础概念和技能，中高级职位可能会在数据结构和并发一类的问题上更深入。
答：抽象，归类 blabla&amp;hellip;易于维护 blabla&amp;hellip;
全错。
现在回忆起来，面试官想问的其实只有一点，就是那句封装。
封装是面向对象的核心概念之一。
封装使代码成为一个黑箱，让我们不必关注它的实现，而是关注它的行为和接口。
这产生了面向接口编程的概念，我们不再关注封装后的对象内部的逻辑，我们给封装后的对象以输入，然后从封装后的对象里取出数据。
封装并不只是一系列接口的集合，更包含了数据和状态，它就是一个微型化的服务，调用者告诉它去做什么事，而不关心它怎么做。
第二招：继承 面试官：讲讲继承。
我：代码复用，blabla&amp;hellip;&amp;hellip;
代码复用，这是核心。
代码复用是继承最主要的作用，大家都知道。面试官并没有在这方面继续深入，所以能答出代码复用其实已经差不多了。
除非再抠上语言相关的语法细节：多继承和单继承。
多继承 C++ 采用了多继承模型，即一个子类可以有多个父类。
Father ------| |====&amp;gt; child Mother ------| 多继承可以允许一些特殊的编程范式。比如说mixin模式。但是多继承也存在其固有的复杂性，主要表现在运行时多态上。
举几个多继承上常见的问题。
父类成员冲突 典型场景如下
class ParentA { public: void func(){} }; class ParentB { public: void func(){} }; class Child: public ParentA,ParentB {}; int main() { Child c; c.</description></item></channel></rss>