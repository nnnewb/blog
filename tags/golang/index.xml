<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/tags/golang/</link><description>Recent content in golang on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 26 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>信号量 vs 互斥锁</title><link>https://nnnewb.github.io/blog/p/%E4%BF%A1%E5%8F%B7%E9%87%8F-vs-%E4%BA%92%E6%96%A5%E9%94%81/</link><pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/%E4%BF%A1%E5%8F%B7%E9%87%8F-vs-%E4%BA%92%E6%96%A5%E9%94%81/</guid><description>看 go-patterns/semaphore.md at master · tmrts/go-patterns (github.com) 时产生了疑问，信号量为啥长得和互斥锁没啥区别呢。于是就谷歌了一圈，重温下一些关于并发的知识，对比信号量 semaphore 和互斥锁 mutex 。
互斥锁 mutex 以 pthread 自带的互斥锁为例，提供了三种不同类型的互斥锁：
PTHREAD_MUTEX_NORMAL ，普通的互斥锁，不支持死锁检测（does not detect deadlock），不支持递归加锁（relock without first unlocking it 会导致死锁），不检测解锁线程，解锁一个未加锁的互斥锁是未定义行为（undefined behavior）。 PTHREAD_MUTEX_ERRORCHECK，带错误检查的互斥锁，不支持递归加锁（会返回错误），解锁其他线程的互斥锁会返回错误，解锁未加锁的互斥锁会返回错误。 PTHREAD_MUTEX_RECURSIVE，递归加锁（relock with out unlocking it）会成功，解锁时需要调用解锁的次数和加锁时调用加锁的次数相同。解锁其他线程的互斥锁会返回错误。解锁未加锁的互斥锁会返回错误。 PTHREAD_MUTEX_DEFAULT，默认互斥锁类型，对这一类型的互斥锁递归加锁时行为是未定义的，解锁未加锁的互斥锁行为是未定义的，解锁其他线程的互斥锁行为是未定义的。这一类型的互斥锁通常映射为另外几种互斥锁之一。 可以比较清楚地看出，互斥锁有三个基本特征：
是否可重复加锁 是否可解锁未加锁的互斥锁 是否可解锁被其他人加锁的互斥锁 最严格的 PTHREAD_MUTEX_ERRORCHECK 类型互斥锁，对此定义是 NO、NO、NO 。
互斥锁的基本使用方式和使用场景有点像厕所的坑位：
抢坑位，锁门 你懂的 解锁，出门 其中有隐含的信息包括：
坑位是提前选择好的，你只能抢一个坑位，不能抢多个坑位。 坑位在使用期间是独占的，你不能和别人分享一个坑位。 只有你自己能解锁坑位，谁也不想办事儿的时候有人闯进来吧？ 而递归加锁这一特殊场景，我寻思吧，有点难拿坑位比喻。反正也不重要，就别管了。
信号量 semaphore 信号量本质上是一个整型值，不细分什么类型了。还是用 pthread 举例吧，依据 POSIX 标准。
对信号量的操作可以先简单分5种。
sem_init(sem,pshared,value)，初始化一个信号量，可以指定要不要在 fork() 创建的进程间共享，还可以指定信号量初始值。 sem_wait(sem)，等待信号量，信号量等于0时阻塞，其他线程通过sem_post唤醒。 sem_post(sem)，发送信号量，唤醒阻塞在sem_wait的线程。 sem_getvalue(sem,valp)，获取信号量当前值。 sem_destroy(sem)，销毁信号量。 信号量的主要特征就是它的值：</description></item><item><title>面试题之 goroutine 运行顺序</title><link>https://nnnewb.github.io/blog/p/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B-goroutine-%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/</link><pubDate>Wed, 04 Aug 2021 10:37:24 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B-goroutine-%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F/</guid><description>不是我做的沙雕面试题，在 segmentfault 上看到的。
原题 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;sync&amp;#34; ) func main() { runtime.GOMAXPROCS(1) wg := sync.WaitGroup{} wg.Add(10) for i := 0; i &amp;lt; 5; i++ { go func() { fmt.Println(&amp;#34;A:&amp;#34;, i) wg.Done() }() } for i := 0; i &amp;lt; 5; i++ { go func(num int) { fmt.Println(&amp;#34;B:&amp;#34;, num) wg.Done() }(i) } wg.Wait() } 问：代码输出结果是什么？
胡乱分析 第一眼进去看到 runtime.GOMAXPROCS(1) ，初步怀疑是又在考什么 GMP 面试题了。
但凡说到 Go 面试好像就一定要考一下 goroutine 调度和 GMP 模型，招进来又只让你写 curd 。搞得面试跟考试背书一样。</description></item><item><title>从零实现一个容器</title><link>https://nnnewb.github.io/blog/p/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8/</link><pubDate>Mon, 31 May 2021 16:16:52 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8/</guid><description>前言 自从看了cocker项目的 ppt 之后就有点念念不忘的意思了，实现一个 docker 或 docker 的类似物看起来并不是做不到的事情。
于是就动手试一试。
核心技术 namespace 命名空间包装全局系统资源，让在命名空间中的进程看起来就像是有自己独立隔离的全局资源一样。命名空间中的全局资源对命名空间中的其他进程都是可见的，但对命名空间外的进程不可见。命名空间用途之一就是实现容器。
Linux provides the following namespaces: Namespace Constant Isolates Cgroup CLONE_NEWCGROUP Cgroup root directory IPC CLONE_NEWIPC System V IPC, POSIX message queues Network CLONE_NEWNET Network devices, stacks, ports, etc. Mount CLONE_NEWNS Mount points PID CLONE_NEWPID Process IDs User CLONE_NEWUSER User and group IDs UTS CLONE_NEWUTS Hostname and NIS domain name 几个命名空间的 API
clone setns unshare 不得不说 man 7 namespaces 对 namespace 的解释已经非常到位了。</description></item><item><title>go 的 defer 语句</title><link>https://nnnewb.github.io/blog/p/go-%E7%9A%84-defer-%E8%AF%AD%E5%8F%A5/</link><pubDate>Tue, 05 Jan 2021 10:01:48 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/go-%E7%9A%84-defer-%E8%AF%AD%E5%8F%A5/</guid><description>昨天对项目做了个小重构，主要是对以前手写的 stmt.Close 没处理返回值的问题、还有各种该记录日志的地方没记日志等等，做了下处理。
老实说这事儿做着做着还有种奇妙的快感，类似于看高压水枪清污视频的感觉。哈哈，也亏领导不管事，代码也不 Review ，测试=摆设。
这不一上班就发现好多问题，幸好只推送到内网。
笑中带泪.gif
0x01 问题描述 问题倒是挺简单的，看下面的代码。
stmt := db.Prepare(query) defer SilentLogError(stmt.Close(), &amp;#34;stmt close failed&amp;#34;) row := stmt.QueryRow(params...) defer row.Close() if err = row.Scan(vars...); err != nil { return nil, err } return vars, nil 那么，请问上面的代码有什么问题呢？
标题都说了 defer 了，那问题肯定是出在 defer 这一行上。
0x02 defer 的求值 简单的结论就是: defer f() 的参数在 defer 这一行求值
具体到上面的例子，defer f(i()) 这样的形式，可以先分成三个部分。
defer 本身的执行时机 i() 的求值时机 f() 的求值时机 把这三部分排一下序:
i() defer defer 把参数求值后包装成一个新函数延迟执行</description></item><item><title>go语言实战之解密ons脚本</title><link>https://nnnewb.github.io/blog/p/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E4%B9%8B%E8%A7%A3%E5%AF%86ons%E8%84%9A%E6%9C%AC/</link><pubDate>Sun, 16 Dec 2018 23:44:00 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E4%B9%8B%E8%A7%A3%E5%AF%86ons%E8%84%9A%E6%9C%AC/</guid><description>Intro ons 是一个开放源代码的视觉小说引擎，以简单实用出名。本博用 golang 来解密 ons 引擎的.dat和.nt2脚本，主要实践目标是异步解密输出。
算法 .dat的加密非常简单，一次异或。密码是0x84。
可以用 go 非常简单粗暴地写出以下代码。
for i := 0; i &amp;lt; len(buf); i++ { buf[i] ^= 0x84 } .nt2的加密同样简单，一次异或，密码是0x85 &amp;amp; 0x97。
可以用 go 非常粗暴地写出以下代码。
for i := 0; i &amp;lt; len(buf); i++ { buf[i] = (buf[i] ^ (0x85 &amp;amp; 0x97)) - 1 } 异步读文件 go 方式比较多，ioutil或者bufio或者os都有文件模块。这里采用bufio套os.Open的方式读文件。
func readFile(p string, outChannel chan []byte) { // 只读方式打开文件 file, err := os.OpenFile(p, os.O_RDONLY, 0644) if err !</description></item></channel></rss>