<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>js on weakptr's 笔记</title><link>https://nnnewb.github.io/tags/js/</link><description>Recent content in js on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 18 Apr 2022 10:11:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/tags/js/index.xml" rel="self" type="application/rss+xml"/><item><title>安全入门系列-xss</title><link>https://nnnewb.github.io/p/xss-day-1/</link><pubDate>Mon, 18 Apr 2022 10:11:00 +0800</pubDate><guid>https://nnnewb.github.io/p/xss-day-1/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>要是开发拿不到更高薪，继续撞天花板，就打算转安全了。考虑5年开发，以及不止5年的各种学习，想转到安全应该不是太难的事。&lt;/p>
&lt;p>且不说转不转行，先了解下安全这行总没错。不转行懂点安全也算优势。&lt;/p>
&lt;blockquote>
&lt;p>编辑于 2022年4月19日&lt;/p>
&lt;/blockquote>
&lt;p>考虑成体系学习，把标题改成了安全入门系列。差不多弄清楚 web 安全主流的攻防方向之后再整理个脑图什么的梳理下怎么深入。&lt;/p>
&lt;h2 id="xss">XSS&lt;/h2>
&lt;h3 id="原理">原理&lt;/h3>
&lt;p>XSS全称 Cross Site Scripting，X 就是 Cross（强行冷笑话）。本质是利用不正常的方式，在网页上插入一段可以执行的 JavaScript 代码，实现窃取 Cookie、冒充用户发送请求之类的操作。&lt;/p>
&lt;p>众所周知浏览器按 F12 在开发者工具里想怎么玩弄网页都行，XSS 听起来像是脱裤放屁。但开发者工具是有极限的，骗人打开开发者工具往里面贴自己看不懂的代码，和发个链接一打开就中招显然是两个难度的事情。&lt;/p>
&lt;h3 id="分类">分类&lt;/h3>
&lt;h4 id="反射型">反射型&lt;/h4>
&lt;p>反射型 XSS 利用服务器或前端把请求中的字段渲染成 HTML 的行为来向网页注入 js。比如这样一个页面：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-php" data-lang="php">&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nx">p&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nx">你好，&lt;/span>&lt;span class="o">&amp;lt;?&lt;/span>&lt;span class="nx">php&lt;/span> &lt;span class="k">echo&lt;/span> &lt;span class="nv">$_GET&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="cp">?&amp;gt;&lt;/span>&lt;span class="err">&amp;lt;/p&amp;gt;
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>页面元素的一部分未经过滤就直接渲染成了 HTML 的一部分，就会产生一个 XSS 漏洞，传递这样一个 &lt;code>name&lt;/code> ： &lt;code>&amp;lt;img src=1 onerror=alert(1)/&amp;gt;&lt;/code> 就能让网页按我们的想法弹窗了。&lt;/p>
&lt;p>之所以叫反射型，是因为注入的 JS 到了服务器又回到了前端，就像是镜子里反射出你自己的影子。&lt;/p>
&lt;h4 id="持久型">持久型&lt;/h4>
&lt;p>和反射型差不多，不同的是注入的 JS 被持久化到了服务端，比如上面的用户名注入点是从数据库提取的，那么把用户名改成 &lt;code>&amp;lt;img src=1 onerror=alert(1)/&amp;gt;&lt;/code>，每次访问这个页面都会触发脚本了，威胁比反射型 XSS 更大。&lt;/p>
&lt;h4 id="dom型">DOM型&lt;/h4>
&lt;p>DOM 型和上面其他 XSS 的主要区别在于不经过服务器，像是现在大前端常见的 SPA ，路由都在前端，后端只有 API 不负责渲染网页。如果前端应用里出现 &lt;code>elem.innerHTML=userinput&lt;/code>，&lt;code>userinput&lt;/code>没好好过滤的情况，就是个 DOM 型的 XSS 漏洞。&lt;/p>
&lt;h3 id="测试">测试&lt;/h3>
&lt;h4 id="代码审计">代码审计&lt;/h4>
&lt;p>目前对代码审计的理解就是 review 源码来尝试发现漏洞，大概只对开源代码或前端代码有用。没代码的话审计就有点逆向的意思了。XSS 漏洞可以从审计中发现，比如 &lt;a class="link" href="https://www.leavesongs.com/PENETRATION/a-tour-of-tui-editor-xss.html" target="_blank" rel="noopener"
>一次对 Tui Editor XSS 的挖掘与分析&lt;/a>。&lt;/p>
&lt;h4 id="手动测试">手动测试&lt;/h4>
&lt;p>手工测试就是在可能的 XSS 注入点提交诸如 &lt;code>&amp;lt;img/onerror=alert(1)&amp;gt;&lt;/code>一类的内容，观察提交的内容是怎么转义的，提交内容如何渲染，再尝试修改 payload 来绕过防护，直至成功或失败。&lt;/p>
&lt;h4 id="自动测试">自动测试&lt;/h4>
&lt;p>尚不清楚自动 XSS 测试的原理，工具有 &lt;a class="link" href="https://github.com/chaitin/xray" target="_blank" rel="noopener"
>XRay&lt;/a> 。个人猜测至少两条路子：&lt;/p>
&lt;ol>
&lt;li>对能访问源码的情况可以自动源码审计，找出危险的赋值或调用。&lt;/li>
&lt;li>不能访问源码的情况下：
&lt;ol>
&lt;li>尝试判断底层框架，使用已知漏洞的 exploit 测试&lt;/li>
&lt;li>根据一定的规则，在可能的表单提交点尝试一系列 payload&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>实际上我觉得更像是半自动的，比如不涉及源码的情况下至少应该需要配置下要尝试的注入点（以及如何检测注入是否成功的页面）和指定 payload 类型，不然注入点的表单都填不满。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>我倒是想再加个实战环节，但现在找个足够简单的 XSS 还挺难的。vulhub 有个 drupal 的 XSS 虽然能跑，但单纯跑一下 PoC 着实没什么乐趣可言。重复一次别人做过的分析倒是可以，但有点超出写这篇博客时的计划了，于是暂时不管，走马观花为主，先对整个安全体系建立概念再由点带面入门。&lt;/p></description></item></channel></rss>