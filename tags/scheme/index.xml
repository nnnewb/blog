<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>scheme on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/tags/scheme/</link><description>Recent content in scheme on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 13 Dec 2021 16:20:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/tags/scheme/index.xml" rel="self" type="application/rss+xml"/><item><title>基于栈的虚拟机</title><link>https://nnnewb.github.io/blog/p/stack-based-virtual-machine-for-minilang/</link><pubDate>Mon, 13 Dec 2021 16:20:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/stack-based-virtual-machine-for-minilang/</guid><description>前言 之前写了个s表达式求值器，很简陋，直接在抽象语法树上执行。只是这样的话其实还没啥意思，所以再试试改进成在基于栈的虚拟机上执行。
0x01 虚拟机模型 首先得承认对这些语言层级的虚拟机不熟，基本是随便设计的。
对象模型 虚拟机指令操作的目标是 对象 ，包括内建的对象和用户定义的对象，虚拟机指令操作的基本单位也是对象。
目前关注的是内建的对象，简单抽象出了几个基本类型。
type Object interface { TypeName() string } type UInt uint64 func (u UInt) TypeName() string { return &amp;#34;UInt&amp;#34; } type Float float64 func (f Float) TypeName() string { return &amp;#34;Float&amp;#34; } type Boolean bool func (b Boolean) TypeName() string { return &amp;#34;boolean&amp;#34; } type String string func (s String) TypeName() string { return &amp;#34;string&amp;#34; } type Symbol string func (s Symbol) TypeName() string { return &amp;#34;symbol&amp;#34; } type Nil struct{} func (n Nil) TypeName() string { return &amp;#34;nil&amp;#34; } 省略了一部分，领会精神即可。上面定义的 Symbol 类型其实就是 #ident 这种语法元素，目的是保持语义上的简洁。</description></item><item><title>一个s表达式求值器</title><link>https://nnnewb.github.io/blog/p/a-s-exp-evaluator/</link><pubDate>Thu, 09 Dec 2021 17:11:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/a-s-exp-evaluator/</guid><description>前言 翻没看过的藏书的时候找出一本《SICP》的 PDF（PS：已经买了正版书），想起曾经拿 Rust 写玩具解释器，结果现在连 Rust 本身都已经快忘光了。
所以就当怀旧，写个很简单的玩具，s表达式求值器。
技术栈 语言选择了 Go，用 gocc 生成 Parser/Lexer 。虽然说手写+调试 Lexer/Parser 也是挺快乐的，但毕竟只是怀旧重温下当年愣头青的自己，不想花太多时间。
词法定义 简单解释下 gocc 定义词法元素的 DSL 是怎么回事。gocc 的这个 DSL 是类似于 EBNF 的语法（自称）， _letter: 'a'-'z' 就是一条产生式，:前面是产生式的名称，后面是模式。
产生式名称也有特殊含义。
! 开头的产生式会被 Lexer 忽略。 _ 开头的产生式叫做 regDefId，可以理解成给后面的模式定义的别名。 a-z小写字母开头的是 token，也就是一般说的词法元素定义了。 值得注意的是 token 不能被用作其他词法元素产生式的模式部分，但 regDefId 可以，所以要注意要复用的规则应该定义成下划线开头。
比如说下面的例子。
// example 1 letter: &amp;#39;a&amp;#39;-&amp;#39;z&amp;#39;; identifier: letter; // Error! // example 2 _letter: &amp;#39;a&amp;#39;-&amp;#39;z&amp;#39;; identifier: _letter; // OK 下面是求值器的词法元素定义。
!whitespace: &amp;#39; &amp;#39; | &amp;#39;\t&amp;#39; | &amp;#39;\r&amp;#39; | &amp;#39;\n&amp;#39;; !</description></item></channel></rss>