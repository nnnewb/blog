<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>scheme on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/tags/scheme/</link><description>Recent content in scheme on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 09 Dec 2021 17:11:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/tags/scheme/index.xml" rel="self" type="application/rss+xml"/><item><title>一个s表达式求值器</title><link>https://nnnewb.github.io/blog/p/a-s-exp-evaluator/</link><pubDate>Thu, 09 Dec 2021 17:11:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/a-s-exp-evaluator/</guid><description>前言 翻没看过的藏书的时候找出一本《SICP》的 PDF（PS：已经买了正版书），想起曾经拿 Rust 写玩具解释器，结果现在连 Rust 本身都已经快忘光了。
所以就当怀旧，写个很简单的玩具，s表达式求值器。
技术栈 语言选择了 Go，用 gocc 生成 Parser/Lexer 。虽然说手写+调试 Lexer/Parser 也是挺快乐的，但毕竟只是怀旧重温下当年愣头青的自己，不想花太多时间。
词法定义 简单解释下 gocc 定义词法元素的 DSL 是怎么回事。gocc 的这个 DSL 是类似于 EBNF 的语法（自称）， _letter: 'a'-'z' 就是一条产生式，:前面是产生式的名称，后面是模式。
产生式名称也有特殊含义。
! 开头的产生式会被 Lexer 忽略。 _ 开头的产生式叫做 regDefId，可以理解成给后面的模式定义的别名。 a-z小写字母开头的是 token，也就是一般说的词法元素定义了。 值得注意的是 token 不能被用作其他词法元素产生式的模式部分，但 regDefId 可以，所以要注意要复用的规则应该定义成下划线开头。
比如说下面的例子。
// example 1 letter: &amp;#39;a&amp;#39;-&amp;#39;z&amp;#39;; identifier: letter; // Error! // example 2 _letter: &amp;#39;a&amp;#39;-&amp;#39;z&amp;#39;; identifier: _letter; // OK 下面是求值器的词法元素定义。
!whitespace: &amp;#39; &amp;#39; | &amp;#39;\t&amp;#39; | &amp;#39;\r&amp;#39; | &amp;#39;\n&amp;#39;; !</description></item></channel></rss>