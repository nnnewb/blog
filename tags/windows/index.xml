<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>windows on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/tags/windows/</link><description>Recent content in windows on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 20 Oct 2021 10:25:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/tags/windows/index.xml" rel="self" type="application/rss+xml"/><item><title>加壳原理03 - 支持没有重定位的程序</title><link>https://nnnewb.github.io/blog/p/learning-packer-03-support-no-relocations/</link><pubDate>Wed, 20 Oct 2021 10:25:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-03-support-no-relocations/</guid><description>前言 距离上一篇加壳原理已经过去挺久了，这段时间稍微折腾了一下 nasm，尝试手工制作了 PE32 文件，积累了一些基本的知识吧。
所以现在继续学习加壳——如何对不支持 ASLR 的 PE32 程序进行加壳？
0x01 关于ASLR ASLR是一项内存保护技术，用于防范内存损坏漏洞，比如缓冲区溢出。需要注意的是 ASLR 并不是 解决 了相关威胁，而是让利用相关的漏洞变得更加困难和具有挑战性。
ASLR 的全名是 Address Space Layout Randomization ，地址空间布局随机化技术。一个典型的 PE32 程序在没有 ASLR 支持的情况下， 地址空间布局是确定的：程序镜像总会加载到固定的地址。这个地址会在文件头里指定。攻击者可以利用这一特点来构造恶意数据，让存在内存损坏漏洞的程序按攻击者意图跳过或执行特定逻辑，造成安全威胁。
对应 ASLR 的地址空间布局随机化，程序需要再次编译来支持重定位 Relocation ，别无他法（大概）。
0x02 思路 对于加壳一个没有重定位，不支持 ASLR 的 PE32 程序，假设这个程序的基址是 0x04000000，原先的 VirtualAlloc 方式分配内存是行不通的。加壳后程序若开启 ASLR，则 0x04000000 可能已经存在其他模块，并不能保证这个基址可用。所以加壳后的程序必须也使用 0x04000000 这个基址，而且标记为不支持 ASLR，避免基址已经被其他模块使用造成加载器无法工作。
将加壳后程序的基址设置为固定的 0x04000000 又会产生新的问题：加载器的代码段不能放在 0x04000000 ，否则加载器运行时就会出现被被加载的代码覆盖的情况，导致程序跑飞。所以编译后的加载器所有 Section 都必须有一定的偏移，这个偏移值就是被加载程序的 Section 大小之和（对齐后）。而因此多出来的空间单独分成一个 Section ，正好用来放要加载的程序。
另外，还必须确认文件头大小是否一致，因为我们需要将被加载程序的文件头覆盖加载器的文件头。而最开始预留的空间必须分配为一个 Section，让 Windows 的加载器能顺利加载程序而不报“不是有效的Win32程序”错误。
内存布局示意图如下：
所以加载器的加载步骤如下：
寻找被加载的 Section 。 复制文件头覆盖自己的文件头。 以自己的基址为被加载程序的基址，完成加载。 加壳机的加壳步骤如下：</description></item><item><title>关于在内存里找kernel32这件事</title><link>https://nnnewb.github.io/blog/p/find-kernel32-in-memory/</link><pubDate>Thu, 14 Oct 2021 16:31:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/find-kernel32-in-memory/</guid><description>前言 总得有个前言。
用 nasm 手工打造了一个 PE 文件后，这个 PE 文件还没什么卵用。如果要动 IAT，又嫌麻烦。网上冲浪找到一篇关于 shellcode 的文章，讲如何在内存里找到 kernel32.dll 并调用 WinExec 函数，于是就想实践一下看看，实际抄代码碰到不少坑。对汇编又熟悉了一点。
0x01 寻找 kernel32 微软有一篇很简短的文章。
The Thread Environment Block (TEB structure) holds context information for a thread.
In the following versions of Windows, the offset of the 32-bit TEB address within the 64-bit TEB is 0. This can be used to directly access the 32-bit TEB of a WOW64 thread. This might change in later versions of Windows</description></item><item><title>nasm汇编手写个PE可执行文件</title><link>https://nnnewb.github.io/blog/p/hand-write-pe-file-with-nasm-assembly/</link><pubDate>Wed, 13 Oct 2021 11:05:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/hand-write-pe-file-with-nasm-assembly/</guid><description>前言 主要是虽然有个汇编器 nasm 但是不知道怎么用，啥汇编都是调试器里纸上谈兵。最近碰到个问题，MinGW 可以用参数 -Wl,section-start= 来修改 section 地址，但 msvc 没有对应物，就蛋疼。手动改 PE 来添加 section 好像可行，但不知道该怎么做，lief 也不熟悉。
正好瞎谷歌的时候发现 nasm 可以直接编译出 PE 文件，这就听起来很有意思了。汇编嘛，听着就很底层，很自由，改个 Section 地址不是手到擒来。于是就学学看。
参考文章附于文末。
0x01 nasm 基本用法 1.1 label 汇编当然有经典的 label 和 instruction 了，instruction 的参数就叫 operand 。
nasm 的 label 语法很简单，任何不是宏和 instruction 或者伪指令的东西，出现在行首，都会被认作 label。
lbl1: ; 这是label sub esp, 4h jmp lbl lbl2 ; 这也是 label sub esp, 4h lbl3 db 1 ; 这还是 label .label4 ; 这是本地 label，可以用 .</description></item><item><title>加壳原理02 - 简单加壳机</title><link>https://nnnewb.github.io/blog/p/learning-packer-02/</link><pubDate>Tue, 28 Sep 2021 16:57:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-02/</guid><description>前言 对 Windows 程序的加载和运行过程有了基本了解后，手动加载并运行一个PE文件并不成问题。加壳仅仅是在这上面更进一步：把加载程序和被加载的程序合并成一个文件。
这么说可能有点太简单化，大部分的工作其实就在这儿：如何处理被加载的程序？压缩？加密？混淆？加载器（或者叫壳程序）如何反调试？
这里先写一个简单的加壳机，仅仅是把被加载的PE文件作为一个 Section，添加到壳程序里，让壳程序直接从这个 Section 加载并运行。
0x01 壳程序 1.1 思路 和加载一个PE文件不同，既然被加载的程序就在 Section 里，那需要做的只有定位到 Section，然后把 Section 内容当读取进内存的 PE 文件内容处理就好了。
壳程序应该尽量保持轻量，不在原始程序上添加太多东西（加完壳大小翻一倍还多了一堆DLL依赖那谁受得了啊），所以很多标准C库的函数也不能用了，像是memcpy、strcmp 都要自己简单实现一个。
1.2 壳实现 绝大部分内容和之前文章中的 load_PE 一致，入口点修改为 _start，需要注意。
#include &amp;lt;Windows.h&amp;gt;#include &amp;lt;winnt.h&amp;gt; void *load_PE(char *PE_data); void fix_iat(char *p_image_base, IMAGE_NT_HEADERS *p_NT_headers); void fix_base_reloc(char *p_image_base, IMAGE_NT_HEADERS *p_NT_headers); int mystrcmp(const char *str1, const char *str2); void mymemcpy(char *dest, const char *src, size_t length); int _start(void) { char *unpacker_VA = (char *)GetModuleHandleA(NULL); IMAGE_DOS_HEADER *p_DOS_header = (IMAGE_DOS_HEADER *)unpacker_VA; IMAGE_NT_HEADERS *p_NT_headers = (IMAGE_NT_HEADERS *)(((char *)unpacker_VA) + p_DOS_header-&amp;gt;e_lfanew); IMAGE_SECTION_HEADER *sections = (IMAGE_SECTION_HEADER *)(p_NT_headers + 1); char *packed = NULL; char packed_section_name[] = &amp;#34;.</description></item><item><title>加壳原理01 - Windows 程序的加载和运行</title><link>https://nnnewb.github.io/blog/p/learning-packer-01-windows-program-load-and-execution/</link><pubDate>Mon, 27 Sep 2021 14:51:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-01-windows-program-load-and-execution/</guid><description>前言 本文由多篇相关文章翻译整合得来，参考文章和书目文末给出。
0x01 PE文件结构 1.1 从 PE-COFF 格式说起 &amp;hellip; 现在PC平台流行的 可执行文件格式（Executable） 主要是 Windows 下的 PE （Portable Executable） 和 Linux 的 ELF （Executable Linkable Format），它们都是 COFF（Common Object File Format）格式的变种。目标文件就是源代码编译后但未进行链接的那些中间文件（Windows 的 .obj 和 Linux 下的 .o），它和可执行文件的内容和结构很相似，所以一般跟可执行文件一起采用一种格式存储。从广义上看，目标文件与可执行文件的格式其实几乎是一样的，所以我们可以广义地将目标文件与可执行文件看成是同一种类型的文件，在 Windows 下，我们可以统称它们为 PE-COFF 文件格式。在 Linux 下，我们可以将它们统称为 ELF 文件。
&amp;hellip; 不光是 可执行文件 （Windows 的 .exe 和 Linux 下的 ELF 可执行文件）按照可执行文件格式存储。动态链接库（DLL，Dynamic Linking Library） （Windows 的 DLL 和 Linux 下的 .so ）以及静态链接库 （Static Linking Library） （Windows 的 .lib 和 Linux 下的 .</description></item></channel></rss>