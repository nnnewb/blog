<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>面试八股 on weakptr's 笔记</title><link>https://nnnewb.github.io/tags/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/</link><description>Recent content in 面试八股 on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 31 May 2022 16:14:47 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/tags/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/index.xml" rel="self" type="application/rss+xml"/><item><title>Go面试八股之GMP模型</title><link>https://nnnewb.github.io/p/go-interview-question-gmp-model/</link><pubDate>Tue, 31 May 2022 16:14:47 +0800</pubDate><guid>https://nnnewb.github.io/p/go-interview-question-gmp-model/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>应付面试做的准备吧。当然单纯背书也没意思，所以还是结合源码尝试去理解。&lt;/p>
&lt;h2 id="gmp-模型">GMP 模型&lt;/h2>
&lt;h3 id="一图概述">一图概述&lt;/h3>
&lt;p>&lt;img src="https://nnnewb.github.io/p/go-interview-question-gmp-model/image-20220530110613376.png"
width="1024"
height="768"
srcset="https://nnnewb.github.io/p/go-interview-question-gmp-model/image-20220530110613376_hu14e2a0debf223a45a15aee79046d51a7_260344_480x0_resize_box_3.png 480w, https://nnnewb.github.io/p/go-interview-question-gmp-model/image-20220530110613376_hu14e2a0debf223a45a15aee79046d51a7_260344_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="GMP模型"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="320px"
>&lt;/p>
&lt;h3 id="gmp之间的关系">G、M、P之间的关系&lt;/h3>
&lt;p>&lt;code>G&lt;/code>=&lt;code>goroutine&lt;/code>，毫无疑问。&lt;code>G&lt;/code>本身维护了一个跟踪它自己执行状态的结构。&lt;/p>
&lt;p>&lt;code>P&lt;/code>=&lt;code>Logical Processors&lt;/code>，可以被视作一种抽象的资源或上下文，需要被OS线程&lt;code>M&lt;/code>获取后，&lt;code>M&lt;/code>才能执行&lt;code>G&lt;/code>。&lt;/p>
&lt;p>&lt;code>M&lt;/code>=&lt;code>OS Thread&lt;/code>，取得&lt;code>P&lt;/code>后，弹出&lt;code>P&lt;/code>队列中的&lt;code>G&lt;/code>并执行。&lt;/p>
&lt;p>这是一个很简化的说法，实际&lt;code>G&lt;/code>、&lt;code>M&lt;/code>、&lt;code>P&lt;/code>之间的交互有很多复杂的细节。&lt;/p>
&lt;h3 id="go程序的启动">Go程序的启动&lt;/h3>
&lt;h4 id="八股">八股&lt;/h4>
&lt;p>&lt;code>M0&lt;/code>是编号0的主线程，在全局变量&lt;code>runtime.m0&lt;/code>中，不需要在堆上分配。&lt;code>M0&lt;/code>负责初始化和启动第一个&lt;code>G&lt;/code>，之后&lt;code>M0&lt;/code>就和其他&lt;code>M&lt;/code>一样了。&lt;/p>
&lt;p>&lt;code>G0&lt;/code>是每次启动&lt;code>M&lt;/code>第一个创建的&lt;code>goroutine&lt;/code>。&lt;code>G0&lt;/code>仅负责调度，不指向任何可执行的函数，每个&lt;code>M&lt;/code>都有自己的&lt;code>G0&lt;/code>。可以这样看：&lt;code>G0&lt;/code>=调度器循环。&lt;/p>
&lt;p>启动&lt;code>G0&lt;/code>后开始正常调度，运行&lt;code>main.main&lt;/code>。&lt;/p>
&lt;h4 id="实践">实践&lt;/h4>
&lt;p>网上有很多 go 程序分析的文章，一个基本的点是 go 程序入口点在 &lt;code>rt0_&amp;lt;os&amp;gt;_&amp;lt;arch&amp;gt;.s&lt;/code> 里，我们对照 go 编译器吐出来的汇编和 x64dbg 读。先准备一个最简单的程序。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-asm" data-lang="asm">&lt;span class="nf">package&lt;/span> &lt;span class="no">main&lt;/span>
&lt;span class="nf">func&lt;/span> &lt;span class="no">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="err">{&lt;/span>
&lt;span class="nf">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">&amp;#34;&lt;/span>&lt;span class="no">Hello&lt;/span> &lt;span class="no">world&lt;/span>&lt;span class="p">!&lt;/span>&lt;span class="err">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="err">}&lt;/span>
&lt;span class="err">//&lt;/span> &lt;span class="nl">$env:&lt;/span>&lt;span class="nf">GOARCH&lt;/span>&lt;span class="err">=&lt;/span>&lt;span class="mi">386&lt;/span>
&lt;span class="err">//&lt;/span> &lt;span class="nf">go&lt;/span> &lt;span class="no">build&lt;/span> &lt;span class="no">main.go&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>386架构的入口汇编如下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// rt0_windows_386.s
TEXT _rt0_386_windows(SB),NOSPLIT,$0
JMP _rt0_386(SB)
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对应的汇编&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/p/go-interview-question-gmp-model/image-20220531101726696.png"
width="709"
height="24"
srcset="https://nnnewb.github.io/p/go-interview-question-gmp-model/image-20220531101726696_hu8c80acd9c9230f7042f52e86cf292cdd_4459_480x0_resize_box_3.png 480w, https://nnnewb.github.io/p/go-interview-question-gmp-model/image-20220531101726696_hu8c80acd9c9230f7042f52e86cf292cdd_4459_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20220531101726696"
class="gallery-image"
data-flex-grow="2954"
data-flex-basis="7090px"
>&lt;/p>
&lt;p>跳转到 &lt;code>_rt0_386&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// asm_386.s
// _rt0_386 is common startup code for most 386 systems when using
// internal linking. This is the entry point for the program from the
// kernel for an ordinary -buildmode=exe program. The stack holds the
// number of arguments and the C-style argv.
TEXT _rt0_386(SB),NOSPLIT,$8
MOVL 8(SP), AX // argc
LEAL 12(SP), BX // argv
MOVL AX, 0(SP)
MOVL BX, 4(SP)
JMP runtime·rt0_go(SB)
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在调试器跟到汇编如下。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/p/go-interview-question-gmp-model/image-20220531101420890.png"
width="600"
height="78"
srcset="https://nnnewb.github.io/p/go-interview-question-gmp-model/image-20220531101420890_hu2ec04fbbeae0cd7b2e3097146efedb10_10625_480x0_resize_box_3.png 480w, https://nnnewb.github.io/p/go-interview-question-gmp-model/image-20220531101420890_hu2ec04fbbeae0cd7b2e3097146efedb10_10625_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20220531101420890"
class="gallery-image"
data-flex-grow="769"
data-flex-basis="1846px"
>&lt;/p>
&lt;p>接着我们看 &lt;code>runtime.rt0_go&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">TEXT runtime·rt0_go(SB),NOSPLIT|NOFRAME|TOPFRAME,$0
// 一大堆初始化和检查代码，略
ok:
// set up m and g &amp;#34;registers&amp;#34;
get_tls(BX)
LEAL runtime·g0(SB), DX
MOVL DX, g(BX)
LEAL runtime·m0(SB), AX
// save m-&amp;gt;g0 = g0
MOVL DX, m_g0(AX)
// save g0-&amp;gt;m = m0
MOVL AX, g_m(DX)
CALL runtime·emptyfunc(SB) // fault if stack check is wrong
// convention is D is always cleared
CLD
CALL runtime·check(SB)
// saved argc, argv
MOVL 120(SP), AX
MOVL AX, 0(SP)
MOVL 124(SP), AX
MOVL AX, 4(SP)
CALL runtime·args(SB)
CALL runtime·osinit(SB)
CALL runtime·schedinit(SB)
// create a new goroutine to start program
PUSHL $runtime·mainPC(SB) // entry
CALL runtime·newproc(SB)
POPL AX
// start this M
CALL runtime·mstart(SB)
CALL runtime·abort(SB)
RET
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>几个关键节点大概谈一下。&lt;/p>
&lt;p>第一个是关于&lt;code>m&lt;/code>和&lt;code>g&lt;/code>，看过&lt;code>proc.go&lt;/code>会发现很多地方调了一个迷之函数&lt;code>getg&lt;/code>，注释里写道由编译器插入实现，从寄存器或者Thread Local Storage 取当前 &lt;code>G&lt;/code> 指针。看代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">// set up m and g &amp;#34;registers&amp;#34;
get_tls(BX)
LEAL runtime·g0(SB), DX
MOVL DX, g(BX)
LEAL runtime·m0(SB), AX
// save m-&amp;gt;g0 = g0
MOVL DX, m_g0(AX)
// save g0-&amp;gt;m = m0
MOVL AX, g_m(DX)
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里把当前的&lt;code>g&lt;/code>设置为了&lt;code>g0&lt;/code>，并且关联到&lt;code>m0&lt;/code>。&lt;/p>
&lt;p>第二是 &lt;code>schedinit&lt;/code>，里面调用了 &lt;code>procresize&lt;/code> ，从 &lt;code>allp&lt;/code> 获取到 &lt;code>p&lt;/code> 绑定到了 &lt;code>m0&lt;/code> 上。&lt;/p>
&lt;p>再然后是在初始化之后看到一个 &lt;code>newproc&lt;/code> 的调用，传入参数 &lt;code>mainPC&lt;/code>，也就是 &lt;code>runtime·main&lt;/code> 函数的地址。&lt;code>newproc&lt;/code> 把 &lt;code>runtime.main&lt;/code> 函数包装成 &lt;code>G&lt;/code> 放进可运行的队列中，具体的请读源码&lt;code>newproc&lt;/code>和&lt;code>newproc1&lt;/code>。&lt;/p>
&lt;p>这里插一嘴，&lt;code>runtime.main&lt;/code> 函数里启动了我们的 &lt;code>main.main&lt;/code> 函数，也就是我们平时代码的入口点就在这了。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/p/go-interview-question-gmp-model/image-20220531104338694.png"
width="1163"
height="121"
srcset="https://nnnewb.github.io/p/go-interview-question-gmp-model/image-20220531104338694_hudb41f3f91be68fc168eff6480777d5eb_15582_480x0_resize_box_3.png 480w, https://nnnewb.github.io/p/go-interview-question-gmp-model/image-20220531104338694_hudb41f3f91be68fc168eff6480777d5eb_15582_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20220531104338694"
class="gallery-image"
data-flex-grow="961"
data-flex-basis="2306px"
>&lt;/p>
&lt;p>但到底为止还没有出现调度代码，我们继续看接下来调用的&lt;code>mstart&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback"> // start this M
CALL runtime·mstart(SB)
TEXT runtime·mstart(SB),NOSPLIT|TOPFRAME,$0
CALL runtime·mstart0(SB)
RET // not reached
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>mstart&lt;/code>是&lt;code>mstart0&lt;/code>的别名，&lt;code>mstart0&lt;/code>是一个 go 函数，里面除了初始化 g 的栈之外就是调用了 &lt;code>mstart1&lt;/code>，&lt;code>mstart1&lt;/code>依然是一个&lt;code>go&lt;/code>函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// The go:noinline is to guarantee the getcallerpc/getcallersp below are safe,
&lt;/span>&lt;span class="c1">// so that we can set up g0.sched to return to the call of mstart1 above.
&lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">//go:noinline
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">func&lt;/span> &lt;span class="nf">mstart1&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">_g_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">getg&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">_g_&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nx">_g_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">g0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">throw&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;bad runtime·mstart&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// Set up m.g0.sched as a label returning to just
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// after the mstart1 call in mstart0 above, for use by goexit0 and mcall.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// We&amp;#39;re never coming back to mstart1 after we call schedule,
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// so other calls can reuse the current frame.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// And goexit0 does a gogo that needs to return from mstart1
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// and let mstart0 exit the thread.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">_g_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">g&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">guintptr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Pointer&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">_g_&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="nx">_g_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">pc&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">getcallerpc&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nx">_g_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">sp&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">getcallersp&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nf">asminit&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nf">minit&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="c1">// Install signal handlers; after minit so that minit can
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// prepare the thread to be able to handle the signals.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">_g_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">m0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">mstartm0&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">fn&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">_g_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">mstartfn&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">fn&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">fn&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">_g_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">m0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">acquirep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">_g_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nextp&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ptr&lt;/span>&lt;span class="p">())&lt;/span>
&lt;span class="nx">_g_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nextp&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nf">schedule&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而&lt;code>mstart1&lt;/code>中我们看到最后一句就是最重要的&lt;code>schedule()&lt;/code>，这个函数会从可运行队列里取一个&lt;code>g&lt;/code>并开始执行。在这个场景下，我们只有另一个&lt;code>g&lt;/code>，&lt;code>runtime.main&lt;/code>。经过&lt;code>schedule&lt;/code>后，主线程就从&lt;code>g0&lt;/code>，也就是刚才的调度代码，切换到了&lt;code>runtime.main&lt;/code>，我们的用户代码中。&lt;/p>
&lt;h3 id="调度策略">调度策略&lt;/h3>
&lt;h4 id="八股-1">八股&lt;/h4>
&lt;ul>
&lt;li>&lt;code>G&lt;/code>运行超过一定时间则换其他任务运行&lt;/li>
&lt;li>&lt;code>G&lt;/code>同步系统调用阻塞则&lt;code>M&lt;/code>和&lt;code>G&lt;/code>继续挂起等待，&lt;code>P&lt;/code>绑定新的&lt;code>M&lt;/code>继续运行&lt;/li>
&lt;li>&lt;code>G&lt;/code>网络调用则挂到&lt;code>netpoller&lt;/code>队列里等待，&lt;code>M&lt;/code>继续调度其他&lt;code>G&lt;/code>运行。&lt;/li>
&lt;li>&lt;code>P&lt;/code>没有任务的时候会尝试从全局队列和其他&lt;code>P&lt;/code>的本地队列偷取&lt;code>G&lt;/code>来运行。&lt;/li>
&lt;/ul>
&lt;h4 id="sysmon抢占handoff">sysmon、抢占、handoff&lt;/h4>
&lt;p>在&lt;code>runtime.main&lt;/code>里，go 在启动&lt;code>main.main&lt;/code>之前，除了&lt;code>wasm&lt;/code>之外都会先启动一个叫&lt;code>sysmon&lt;/code>的&lt;code>M&lt;/code>，这个&lt;code>M&lt;/code>只负责运行调度。&lt;/p>
&lt;p>在&lt;code>sysmon&lt;/code>函数里可以看到一个&lt;code>retake&lt;/code>调用和注释&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// retake P&amp;#39;s blocked in syscalls
&lt;/span>&lt;span class="c1">// and preempt long running G&amp;#39;s
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nf">retake&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">now&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">idle&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">idle&lt;/span>&lt;span class="o">++&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>retake&lt;/code>函数里检查调用时间，处理两种场景：&lt;/p>
&lt;ol>
&lt;li>在同步系统调用状态，而且运行了很长时间&lt;/li>
&lt;li>&lt;code>G&lt;/code>已经运行了很长时间&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="k">if&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">_Prunning&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">_Psyscall&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// Preempt G if it&amp;#39;s running for too long.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">t&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">int64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">_p_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">schedtick&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nb">int64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pd&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">schedtick&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nx">t&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">pd&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">schedtick&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">uint32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">t&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">pd&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">schedwhen&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">now&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">pd&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">schedwhen&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="nx">forcePreemptNS&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="nx">now&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">preemptone&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">_p_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// In case of syscall, preemptone() doesn&amp;#39;t
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// work, because there is no M wired to P.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">sysretake&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>观察到，当&lt;code>pd.schedwhen+forcePreemptNS &amp;lt;= now&lt;/code>，也就是这个&lt;code>G&lt;/code>已经运行了超过&lt;code>forcePreemptNS&lt;/code>（常量，10毫秒）这么久时，使用&lt;code>preemptone&lt;/code>来通知&lt;code>M&lt;/code>换一个&lt;code>G&lt;/code>运行。&lt;/p>
&lt;p>但是在同步系统调用的状态下，&lt;code>preemptone&lt;/code>不起效，这里做了个简单的标记，在之后的代码中我们会看到如何处理。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="k">if&lt;/span> &lt;span class="nx">s&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">_Psyscall&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// Retake P from syscall if it&amp;#39;s there for more than 1 sysmon tick (at least 20us).
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">t&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">int64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">_p_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">syscalltick&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">sysretake&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nb">int64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">pd&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">syscalltick&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nx">t&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">pd&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">syscalltick&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">uint32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">t&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">pd&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">syscallwhen&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">now&lt;/span>
&lt;span class="k">continue&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// On the one hand we don&amp;#39;t want to retake Ps if there is no other work to do,
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// but on the other hand we want to retake them eventually
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// because they can prevent the sysmon thread from deep sleep.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nf">runqempty&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">_p_&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">atomic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nmspinning&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="nx">atomic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">npidle&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">pd&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">syscallwhen&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1000&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1000&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nx">now&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">continue&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// Drop allpLock so we can take sched.lock.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nf">unlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">allpLock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// Need to decrement number of idle locked M&amp;#39;s
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// (pretending that one more is running) before the CAS.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// Otherwise the M from which we retake can exit the syscall,
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// increment nmidle and report deadlock.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nf">incidlelocked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">atomic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Cas&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">_p_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">status&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_Pidle&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">n&lt;/span>&lt;span class="o">++&lt;/span>
&lt;span class="nx">_p_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">syscalltick&lt;/span>&lt;span class="o">++&lt;/span>
&lt;span class="nf">handoffp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">_p_&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nf">incidlelocked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">allpLock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>首先是，没有标记&lt;code>sysretake&lt;/code>，也就是没有超时，那就随它去。如果&lt;code>p&lt;/code>队列为空，而且没超过一定时长（&lt;code>pd.syscallwhen+10*1000*1000&lt;/code>），那也暂时不管。中间的&lt;code>spinning&lt;/code>状态和&lt;code>idle&lt;/code>不提。&lt;/p>
&lt;p>确定是同步系统调用中，而且无法被抢占，这里就要提到Go的调度策略之 &lt;code>handoff&lt;/code>，注意倒数第五行的&lt;code>handoffp(_p_)&lt;/code>。&lt;/p>
&lt;p>&lt;code>handoffp&lt;/code> 在 &lt;code>P&lt;/code> 队列里还有任务的时候，会调度一个空闲的 &lt;code>M&lt;/code>（或者创建一个）绑定 &lt;code>P&lt;/code>，继续执行。&lt;/p>
&lt;h4 id="sysmon和netpoll">sysmon和netpoll&lt;/h4>
&lt;p>在 &lt;code>sysmon&lt;/code> 中还有一段关于网络&lt;code>netpoll&lt;/code>的代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="k">if&lt;/span> &lt;span class="nf">netpollinited&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">lastpoll&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">lastpoll&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1000&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1000&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">now&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">atomic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Cas64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lastpoll&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">uint64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">lastpoll&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">uint64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">now&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="nx">list&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">netpoll&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// non-blocking - returns list of goroutines
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">empty&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// Need to decrement number of idle locked M&amp;#39;s
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// (pretending that one more is running) before injectglist.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// Otherwise it can lead to the following situation:
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// injectglist grabs all P&amp;#39;s but before it starts M&amp;#39;s to run the P&amp;#39;s,
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// another M returns from syscall, finishes running its G,
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// observes that there is no work to do and no other running M&amp;#39;s
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// and reports deadlock.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nf">incidlelocked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">injectglist&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">list&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">incidlelocked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>sysmon&lt;/code>检查到有可用的连接后（&lt;code>netpoll&lt;/code>返回的&lt;code>list&lt;/code>），将可用的&lt;code>G&lt;/code>加入可运行的队列（这里是&lt;code>sysmon&lt;/code>这个特殊&lt;code>M&lt;/code>，没有&lt;code>P&lt;/code>，所以是加入全局队列）。&lt;/p>
&lt;h4 id="work-stealing">work stealing&lt;/h4>
&lt;p>回到Go程序启动时我们看到的&lt;code>schedule&lt;/code>函数，里面调用了&lt;code>findRunnable&lt;/code>这个工具函数来获取可用的任务。注释里写的很清楚。&lt;/p>
&lt;blockquote>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// Finds a runnable goroutine to execute.
&lt;/span>&lt;span class="c1">// Tries to steal from other P&amp;#39;s, get g from local or global queue, poll network.
&lt;/span>&lt;span class="c1">// tryWakeP indicates that the returned goroutine is not normal (GC worker, trace
&lt;/span>&lt;span class="c1">// reader) so the caller should try to wake a P.
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/blockquote>
&lt;p>我们看下内部怎么工作的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// Check the global runnable queue once in a while to ensure fairness.
&lt;/span>&lt;span class="c1">// Otherwise two goroutines can completely occupy the local runqueue
&lt;/span>&lt;span class="c1">// by constantly respawning each other.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nx">_p_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">schedtick&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="mi">61&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">runqsize&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">gp&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">globrunqget&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">_p_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">unlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">gp&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>首先，如果队列非空而且已经跑本地队列一段时间了（&lt;code>schedtick%61==0&lt;/code>），会尝试从全局队列取一半的&lt;code>G&lt;/code>到本地队列运行（&lt;code>globrunqget&lt;/code>），保证公平调度，防止全局队列的&lt;code>G&lt;/code>饿死。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// local runq
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">inheritTime&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">runqget&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">_p_&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">gp&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">inheritTime&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// global runq
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">runqsize&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">gp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">globrunqget&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">_p_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">unlock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">gp&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接着先后尝试从本地队列和全局队列取&lt;code>G&lt;/code>，如果本地队列没有任务，全局队列也没有了，再从其他地方找。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// Poll network.
&lt;/span>&lt;span class="c1">// This netpoll is only an optimization before we resort to stealing.
&lt;/span>&lt;span class="c1">// We can safely skip it if there are no waiters or a thread is blocked
&lt;/span>&lt;span class="c1">// in netpoll already. If there is any kind of logical race with that
&lt;/span>&lt;span class="c1">// blocked thread (e.g. it has already returned from netpoll, but does
&lt;/span>&lt;span class="c1">// not set lastpoll yet), this thread will do blocking netpoll below
&lt;/span>&lt;span class="c1">// anyway.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="nf">netpollinited&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">atomic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">netpollWaiters&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">atomic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Load64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">lastpoll&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">list&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">netpoll&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">empty&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// non-blocking
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">gp&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="nf">injectglist&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">list&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nf">casgstatus&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_Gwaiting&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_Grunnable&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">trace&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">enabled&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nf">traceGoUnpark&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>尝试过一次&lt;code>netpoll&lt;/code>找出就绪的&lt;code>G&lt;/code>。还是没有，尝试从其他&lt;code>P&lt;/code> &lt;em>偷&lt;/em> &lt;code>G&lt;/code>来执行。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="c1">// Spinning Ms: steal work from other Ps.
&lt;/span>&lt;span class="c1">//
&lt;/span>&lt;span class="c1">// Limit the number of spinning Ms to half the number of busy Ps.
&lt;/span>&lt;span class="c1">// This is necessary to prevent excessive CPU consumption when
&lt;/span>&lt;span class="c1">// GOMAXPROCS&amp;gt;&amp;gt;1 but the program parallelism is low.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nx">procs&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">uint32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gomaxprocs&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">_g_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">spinning&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">atomic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">nmspinning&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">procs&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="nx">atomic&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">sched&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">npidle&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">inheritTime&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">tnow&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">w&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">newWork&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">stealWork&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">now&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">now&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">tnow&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">gp&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// Successfully stole.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nx">gp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">inheritTime&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>stealWork&lt;/code>会尝试从其他&lt;code>P&lt;/code>偷一半&lt;code>G&lt;/code>到自己的&lt;code>P&lt;/code>的本地队列里。&lt;/p>
&lt;h3 id="goroutine的启动">goroutine的启动&lt;/h3>
&lt;p>简而言之，&lt;code>go f()&lt;/code>其实就是&lt;code>runtime.newproc(f)&lt;/code>，&lt;code>newproc&lt;/code>的实现逻辑就是把函数包装成&lt;code>G&lt;/code>结构，加入当前&lt;code>P&lt;/code>的本地队列，仅此而已。之后就是正常调度。&lt;/p>
&lt;h3 id="普通m的启动">普通M的启动&lt;/h3>
&lt;p>&lt;code>runtime.newm&lt;/code>函数。&lt;code>m&lt;/code>会分配到堆上（&lt;code>allocm&lt;/code>），加入&lt;code>allm&lt;/code>全局&lt;code>M&lt;/code>池，在&lt;code>newm&lt;/code>里调用了&lt;code>newm1&lt;/code>，&lt;code>newm1&lt;/code>里使用&lt;code>newosproc&lt;/code>启动了一个操作系统线程来运行创建的&lt;code>M&lt;/code>。看注释还有一种做法是 &lt;code>template thread&lt;/code>，用于处理 &lt;code>locked M&lt;/code>或者被 C 代码启动的情况。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>又是有些突兀的结束。&lt;/p>
&lt;p>关于&lt;code>runtime&lt;/code>其实还是有不少好玩的东西的，但问题就是不太好拿调试器去跟，现在也没看到什么特别好的go源码解读的文章或者书本吧。&lt;/p>
&lt;p>Go 官方自己在 release note 里说过，不要依赖调度器的行为。GMP 学一学，看看 runtime 里怎么实现的，都挺好的。我是说，出于兴趣，那都挺好的。学到就是赚到，就算写代码的时候用不上也可以当谈资。&lt;/p>
&lt;p>但应付面试的话=。=我感觉对照着八股文知识点去翻一下 runtime 对应的代码其实也就差不多了，甚至翻都不用翻，背呗。就是没乐趣了。&lt;/p>
&lt;p>这篇博客主要是加强八股，所以GMP的知识点浅尝辄止吧。时间有限，八股说每个 &lt;code>M&lt;/code> 创建都有个 &lt;code>g0&lt;/code> ，但还没在代码里找到哪儿给新 &lt;code>M&lt;/code> 设置的 &lt;code>g0&lt;/code>；&lt;code>scavenger&lt;/code> 也没看，记得第一次翻 go 源码就是为了找出 scavenger 到底怎么向 os 返还内存，现在也没结论。剩下的问题太多了。&lt;/p>
&lt;p>就这样吧，结束，辛苦自己了。&lt;/p></description></item></channel></rss>