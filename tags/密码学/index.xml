<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>密码学 on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/</link><description>Recent content in 密码学 on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 16 Nov 2021 11:31:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/index.xml" rel="self" type="application/rss+xml"/><item><title>密码学入门03 - 古典密码#3</title><link>https://nnnewb.github.io/blog/p/cryptography-introduction-03/</link><pubDate>Tue, 16 Nov 2021 11:31:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/cryptography-introduction-03/</guid><description>&lt;img src="https://nnnewb.github.io/blog/p/cryptography-introduction-03/cover.jpg" alt="Featured image of post 密码学入门03 - 古典密码#3" />&lt;h2 id="前言">前言&lt;/h2>
&lt;p>学习一下 Hill 密码。&lt;/p>
&lt;h2 id="0x01-数学基础">0x01 数学基础&lt;/h2>
&lt;p>参考了 &lt;a class="link" href="https://www.shuxuele.com/algebra/matrix-introduction.html" target="_blank" rel="noopener"
>数学乐&lt;/a> 。没有详细介绍矩阵的意义，但基本运算规则之类的讲得很清楚好懂。&lt;/p>
&lt;h3 id="11-矩阵">1.1 矩阵&lt;/h3>
&lt;p>一个矩阵就是n行m列的数字表格，含义暂不考虑，只学习下矩阵的表示方法、运算规则，不然有点难读懂 Hill 密码的规则。&lt;/p>
&lt;p>一个有 &lt;em>m&lt;/em> 行，&lt;em>n&lt;/em> 列的矩阵 &lt;em>A&lt;/em> 的书写形式如下。
$$
A=\begin{bmatrix}
a_{11} &amp;amp; a_{12} &amp;amp; \dots &amp;amp; a_{1n} \\ a_{21} &amp;amp; a_{22} &amp;amp; \dots &amp;amp; a_{2n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{m1} &amp;amp; a_{m2} &amp;amp; \dots &amp;amp; a_{mn}
\end{bmatrix}
$$&lt;/p>
&lt;h3 id="12-矩阵加法减法">1.2 矩阵加法/减法&lt;/h3>
&lt;p>矩阵加减法规则如下。设有矩阵 &lt;em>A&lt;/em>、&lt;em>B&lt;/em> 如下。
$$
A=\begin{bmatrix}
a_{11} &amp;amp; a_{12} &amp;amp; \dots &amp;amp; a_{1n} \\ a_{21} &amp;amp; a_{22} &amp;amp; \dots &amp;amp; a_{2n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{m1} &amp;amp; a_{m2} &amp;amp; \dots &amp;amp; a_{mn}
\end{bmatrix},B=\begin{bmatrix}
b_{11} &amp;amp; b_{12} &amp;amp; \dots &amp;amp; b_{1n} \\ b_{21} &amp;amp; b_{22} &amp;amp; \dots &amp;amp; b_{2n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ b_{m1} &amp;amp; b_{m2} &amp;amp; \dots &amp;amp; b_{mn}
\end{bmatrix}
$$
则计算 A±B 的规则如下。
$$
A±B=\begin{bmatrix}
a_{11}±b_{11} &amp;amp; a_{12}±b_{12} &amp;amp; \dots &amp;amp; a_{1n}±b_{1n} \\ a_{21}±b_{21} &amp;amp; a_{22}±b_{22} &amp;amp; \dots &amp;amp; a_{2n}±b_{2n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{m1}±b_{m1} &amp;amp; a_{m2}±b_{m2} &amp;amp; \dots &amp;amp; a_{mn}±b_{mn}
\end{bmatrix}
$$
性质：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>只有行列数相同的矩阵，加减法才有意义&lt;/strong>&lt;/li>
&lt;li>&lt;strong>矩阵的加减法，就是矩阵中相同位置元素加减&lt;/strong>&lt;/li>
&lt;li>矩阵加减法满足 &lt;strong>交换律&lt;/strong>（&lt;code>A+B=B+A&lt;/code>） 和 &lt;strong>结合律&lt;/strong> （&lt;code>A+(B+C)=(A+B)+c&lt;/code>）&lt;/li>
&lt;/ul>
&lt;h3 id="12-矩阵数乘">1.2 矩阵数乘&lt;/h3>
&lt;p>数λ乘矩阵 &lt;em>A&lt;/em>，即使将数λ乘矩阵A中的每一个元素，记为 &lt;em>λA&lt;/em> 或 &lt;em>Aλ&lt;/em>。&lt;/p>
&lt;p>特别的，称 &lt;em>-A&lt;/em> 为 &lt;em>A&lt;/em> 的负矩阵。&lt;/p>
&lt;p>性质：&lt;/p>
&lt;ul>
&lt;li>满足 &lt;strong>结合律&lt;/strong> （&lt;code>(λμ)A=λ(μA); (λ+μ)A=λA+μA&lt;/code>） 和 &lt;strong>分配律&lt;/strong> （&lt;code>λ(A+B)=λA+λB&lt;/code>）&lt;/li>
&lt;/ul>
&lt;h3 id="13-矩阵乘法">1.3 矩阵乘法&lt;/h3>
&lt;p>先看矩阵的另一种表示形式：&lt;em>A=(a&lt;sub>ij&lt;/sub>)&lt;sub>mxs&lt;/sub>&lt;/em> ，这种表示形式中，&lt;em>m&lt;/em> 表示行数，&lt;em>s&lt;/em> 表示列数，&lt;em>a&lt;sub>ij&lt;/sub>&lt;/em> 姑且当占位，表示矩阵元素。&lt;/p>
&lt;p>设 &lt;em>A=(a&lt;sub>ij&lt;/sub>)&lt;sub>mxs&lt;/sub>&lt;/em> &lt;em>B=(b&lt;sub>ij&lt;/sub>)&lt;sub>sxn&lt;/sub>&lt;/em> ，则 &lt;em>A=AB&lt;/em> 是这样一个矩阵：&lt;/p>
&lt;ol>
&lt;li>行数和左矩阵 &lt;em>A&lt;/em> 相同，列数和右矩阵 &lt;em>B&lt;/em> 相同，即 &lt;em>C=(c&lt;sub>ij&lt;/sub>)&lt;sub>mxn&lt;/sub>&lt;/em> 。&lt;/li>
&lt;li>&lt;em>C&lt;/em> 的第 &lt;em>i&lt;/em> 行第 &lt;em>j&lt;/em> 列的元素 &lt;em>c&lt;sub>ij&lt;/sub>&lt;/em> 由 &lt;em>A&lt;/em> 的第 &lt;em>i&lt;/em> 行元素和 &lt;em>B&lt;/em> 的第 &lt;em>j&lt;/em> 列元素对应相乘，再取乘积之和。&lt;/li>
&lt;/ol>
&lt;p>举例来说，将这两个矩阵相乘。&lt;/p>
&lt;p>$$
A=\begin{bmatrix}
1 &amp;amp; 2 \\ 1 &amp;amp; -1
\end{bmatrix},B=
\begin{bmatrix}
1 &amp;amp; 2 &amp;amp; -3 \\ -1 &amp;amp; 1 &amp;amp; 2
\end{bmatrix}
$$
结果是一个 2x3 的矩阵，每个元素计算如下：
$$
AB=\begin{bmatrix}
(1×1+2×-1) &amp;amp; (1×2+2×1) &amp;amp; (1×-3+2×2) \\ (1×1+-1×-1) &amp;amp; (1×2+-1×1) &amp;amp; (1×-3+-1×2)
\end{bmatrix}=
\begin{bmatrix}
-1 &amp;amp; 4 &amp;amp; 1 \\ 2 &amp;amp; 1 &amp;amp; -5
\end{bmatrix}
$$
先用 &lt;em>A&lt;/em> 的第1行，分别乘 &lt;em>B&lt;/em> 的第1、2、3列，作为结果矩阵 &lt;em>C&lt;/em> 的第1行。然后用 &lt;em>A&lt;/em> 的第2行，分别乘 &lt;em>B&lt;/em> 的第1、2、3列，作为结果矩阵 &lt;em>C&lt;/em> 的第二行。&lt;/p>
&lt;p>注意：相乘的矩阵应该满足条件，左侧矩阵列数等于右侧矩阵行数，计算才能进行。&lt;/p>
&lt;p>性质（假设运算都是可行的）：&lt;/p>
&lt;ol>
&lt;li>符合结合律 &lt;em>(AB)C=A(BC)&lt;/em>&lt;/li>
&lt;li>符合分配律 &lt;em>A(B±C)=AB±AC&lt;/em> （左分配律）; &lt;em>(B±C)A=BA±CA&lt;/em> （右分配律）&lt;/li>
&lt;li>&lt;em>(λA)B=λ(AB)=A(λB)&lt;/em>&lt;/li>
&lt;/ol>
&lt;h3 id="14-矩阵转置">1.4 矩阵转置&lt;/h3>
&lt;p>将 &lt;em>A&lt;/em> 矩阵的行换成同序号的列所得到的新矩阵称为 &lt;em>A&lt;/em> 的转置矩阵，记作 &lt;em>A'&lt;/em> 或者 &lt;em>A&lt;sup>T&lt;/sup>&lt;/em> 。
$$
A=
\begin{bmatrix}
1 &amp;amp; 0 &amp;amp; 3 &amp;amp; -1 \\ 2 &amp;amp; 1 &amp;amp; 0 &amp;amp; 2
\end{bmatrix},A'=A^T=
\begin{bmatrix}
1 &amp;amp; 2 \\ 0 &amp;amp; 1 \\ 3 &amp;amp; 0 \\ -1 &amp;amp; 2
\end{bmatrix}
$$
性质：&lt;/p>
&lt;ol>
&lt;li>&lt;em>(A')'=A&lt;/em>&lt;/li>
&lt;li>&lt;em>(A+B)'=A'+B'&lt;/em>&lt;/li>
&lt;li>&lt;em>(AB)'=B&amp;rsquo;A'&lt;/em>&lt;/li>
&lt;li>&lt;em>(λA)'=λA'&lt;/em>，λ是常数&lt;/li>
&lt;/ol>
&lt;h3 id="15-对称矩阵">1.5 对称矩阵&lt;/h3>
&lt;p>如果矩阵 &lt;em>A&lt;/em> 满足 &lt;em>A'=A&lt;/em> ，即 &lt;em>a&lt;sub>ij&lt;/sub>=a&lt;sub>ji&lt;/sub>&lt;/em> ，则称 &lt;em>A&lt;/em> 为 &lt;strong>对称矩阵&lt;/strong>。&lt;/p>
&lt;p>对称矩阵的特点是它的元素以主对角线为对称轴对应相等。&lt;/p>
&lt;p>举例如下。
$$
A=\begin{bmatrix}
1 &amp;amp; 2 &amp;amp; 3 \\ 2 &amp;amp; 1 &amp;amp; 2 \\ 3 &amp;amp; 2 &amp;amp; 1
\end{bmatrix}
$$&lt;/p>
&lt;p>尝试将这个矩阵转置，令 &lt;em>a&lt;sub>ij&lt;/sub>=a&lt;sub>ji&lt;/sub>&lt;/em> ，得到下面的矩阵，发现的确和原矩阵相同。
$$
A'=\begin{bmatrix}
a_{11} &amp;amp; a_{21} &amp;amp; a_{31} \\ a_{12} &amp;amp; a_{22} &amp;amp; a_{32} \\ a_{13} &amp;amp; a_{23} &amp;amp; a_{33}
\end{bmatrix}=
\begin{bmatrix}
1 &amp;amp; 2 &amp;amp; 3 \\ 2 &amp;amp; 1 &amp;amp; 2 \\ 3 &amp;amp; 2 &amp;amp; 1
\end{bmatrix}
$$&lt;/p>
&lt;p>而原矩阵关于主对角线对称。&lt;/p>
&lt;h3 id="16-单位矩阵">1.6 单位矩阵&lt;/h3>
&lt;p>单位矩阵是除了主对角线上是1，其他数字都是0的矩阵。&lt;strong>任何矩阵和单位矩阵相乘都等于自身&lt;/strong>。&lt;/p>
&lt;p>比如下面这个 3x3 矩阵。
$$
I=\begin{bmatrix}
1 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 1 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 1
\end{bmatrix}
$$&lt;/p>
&lt;h3 id="17-逆矩阵">1.7 逆矩阵&lt;/h3>
&lt;p>如果有矩阵 &lt;em>B&lt;/em> ，令 &lt;em>BA=AB=I&lt;/em>，其中 &lt;em>I&lt;/em> 为单位矩阵，则称 &lt;em>B&lt;/em> 为 &lt;em>A&lt;/em> 的逆矩阵，记为 &lt;em>A&lt;sup>-1&lt;/sup>&lt;/em> 。对任意矩阵 &lt;em>A&lt;/em> ，逆矩阵并不一定存在。&lt;/p>
&lt;p>逆矩阵的作用是一定程度上代替了矩阵除法运算（矩阵不能做除法），例如已知矩阵A、B，求矩阵X，有下面的式子。&lt;/p>
&lt;p>&lt;em>XA=B&lt;/em>&lt;/p>
&lt;p>如果有除法，那可以直接移项 &lt;em>X=B/A&lt;/em> ，但矩阵只能相乘，所以我们可以在两边都乘上 A 的逆矩阵 &lt;em>A&lt;sup>-1&lt;/sup>&lt;/em> 。&lt;/p>
&lt;p>&lt;em>XAA&lt;sup>-1&lt;/sup>=BA&lt;sup>-1&lt;/sup>&lt;/em>&lt;/p>
&lt;p>因为 &lt;em>AA&lt;sup>-1&lt;/sup>&lt;/em> 得单位矩阵 &lt;em>I&lt;/em> ，所以左侧就变成了 &lt;em>XI&lt;/em>。又因为任何矩阵和单位矩阵相乘都等于自身，所以 &lt;em>XI&lt;/em> 可以简化为 &lt;em>X&lt;/em> 。于是就得到了：&lt;/p>
&lt;p>&lt;em>X=BA&lt;sup>-1&lt;/sup>&lt;/em>&lt;/p>
&lt;p>但是要&lt;strong>注意次序&lt;/strong>！ &lt;em>AX=B&lt;/em> 不能用上述方法做，因为&lt;strong>矩阵乘法不一定满足结合律&lt;/strong> （&lt;em>AB=BA&lt;/em>），对于 &lt;em>AX=B&lt;/em> 的情况，可以将 &lt;em>A&lt;sup>-1&lt;/sup>&lt;/em> 放在式子之前，也就是 &lt;em>A&lt;sup>-1&lt;/sup>AX=A&lt;sup>-1&lt;/sup>B&lt;/em> 。&lt;/p>
&lt;h3 id="18-行列式拉普拉斯展开">1.8 行列式（拉普拉斯展开）&lt;/h3>
&lt;p>矩阵 A 的行列式记为 &lt;em>|A|&lt;/em> ，和绝对值符号一样。只有&lt;strong>方形矩阵&lt;/strong>才能计算行列式。方形矩阵就是行和列数目相等的矩阵。&lt;/p>
&lt;p>首先看 2x2 矩阵。
$$
A=\begin{bmatrix}
a &amp;amp; b \\ c &amp;amp; d
\end{bmatrix},|A|=ad-bc
$$
2x2矩阵的行列式就是简单的交叉相乘再相减。下图中蓝色是正，红色是负。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-03/image-20211112142023403.png"
width="122"
height="82"
srcset="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-03/image-20211112142023403_huc11a23cfb761a28dddf43c5ac68c59d6_2679_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/cryptography-introduction-03/image-20211112142023403_huc11a23cfb761a28dddf43c5ac68c59d6_2679_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20211112142023403"
class="gallery-image"
data-flex-grow="148"
data-flex-basis="357px"
>&lt;/p>
&lt;p>再看 3x3 矩阵的行列式写法，用矩阵第一行的元素，逐个去乘不在和这个元素同一行同一列元素的行列式，最后把这些值用加减号连起来。
$$
\begin{vmatrix}
a &amp;amp; b &amp;amp; c \\ d &amp;amp; e &amp;amp; f \\ g &amp;amp; h &amp;amp; i
\end{vmatrix}=
a
\begin{vmatrix}
e &amp;amp; f \\ h &amp;amp; i
\end{vmatrix}
-b
\begin{vmatrix}
d &amp;amp; f \\ g &amp;amp; i
\end{vmatrix}
+c
\begin{vmatrix}
d &amp;amp; e \\ g &amp;amp; h
\end{vmatrix}
=a(ei-fh)-b(di-fg)+c(dh-eg)
$$
更直观的图形化表示：&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-03/image-20211112142439733.png"
width="436"
height="115"
srcset="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-03/image-20211112142439733_hu6459d23d051a17bdb0e4e65aba5ebe8f_9156_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/cryptography-introduction-03/image-20211112142439733_hu6459d23d051a17bdb0e4e65aba5ebe8f_9156_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20211112142439733"
class="gallery-image"
data-flex-grow="379"
data-flex-basis="909px"
>&lt;/p>
&lt;p>注意这个过程中的加减符号规律，&lt;em>a&lt;sub>11&lt;/sub>×(&amp;hellip;)&lt;/em> 是正，&lt;em>a&lt;sub>12&lt;/sub>×(&amp;hellip;)&lt;/em> 是负，&lt;em>a&lt;sub>13&lt;/sub>×(&amp;hellip;)&lt;/em> 又是正。&lt;/p>
&lt;p>知晓这些规律后再看更大的矩阵，也可以依葫芦画瓢写出行列式。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-03/image-20211112143050819.png"
width="590"
height="126"
srcset="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-03/image-20211112143050819_hu6a758e89ff701756d3ce691fff269895_11232_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/cryptography-introduction-03/image-20211112143050819_hu6a758e89ff701756d3ce691fff269895_11232_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20211112143050819"
class="gallery-image"
data-flex-grow="468"
data-flex-basis="1123px"
>&lt;/p>
&lt;p>留意其中正负号出现的规律，&lt;em>+a&lt;sub>11&lt;/sub>&lt;/em> &lt;em>-a&lt;sub>12&lt;/sub>&lt;/em> &lt;em>+a&lt;sub>13&lt;/sub>&lt;/em> &lt;em>-a&lt;sub>14&lt;/sub>&lt;/em> 。&lt;/p>
&lt;p>这种计算方法叫做 &lt;strong>拉普拉斯展开&lt;/strong> 。&lt;/p>
&lt;h3 id="19-求逆矩阵的方法">1.9 求逆矩阵的方法&lt;/h3>
&lt;ul>
&lt;li>2x2 矩阵的逆矩阵&lt;/li>
&lt;li>初等行运算&lt;/li>
&lt;li>余子式、代数余子式和伴随来求逆矩阵&lt;/li>
&lt;/ul>
&lt;p>2x2 矩阵的逆矩阵是：
$$
A^{-1}=\begin{bmatrix}
a &amp;amp; b \\ c &amp;amp; d
\end{bmatrix}^{-1}=
\frac{1}{|A|}
\begin{bmatrix}
d &amp;amp; -b \\ -c &amp;amp; a
\end{bmatrix}
$$&lt;/p>
&lt;ol>
&lt;li>调换 &lt;em>a&lt;sub>11&lt;/sub>&lt;/em> 和 &lt;em>a&lt;sub>22&lt;/sub>&lt;/em>&lt;/li>
&lt;li>&lt;em>a&lt;sub>12&lt;/sub>&lt;/em> 和 &lt;em>a&lt;sub>21&lt;/sub>&lt;/em> 加上负号&lt;/li>
&lt;li>除以原矩阵的行列式&lt;/li>
&lt;/ol>
&lt;p>3x3 或更大的矩阵的逆矩阵求法可以用 &lt;a class="link" href="https://www.shuxuele.com/algebra/matrix-inverse-row-operations-gauss-jordan.html" target="_blank" rel="noopener"
>初等行运算&lt;/a> 或 &lt;a class="link" href="https://www.shuxuele.com/algebra/matrix-inverse-minors-cofactors-adjugate.html" target="_blank" rel="noopener"
>用余子式、代数余子式和伴随 来求逆矩阵&lt;/a> 。&lt;/p>
&lt;h2 id="0x02-hill-密码">0x02 Hill 密码&lt;/h2>
&lt;h3 id="21-加密过程">2.1 加密过程&lt;/h3>
&lt;p>首先给定一个密码矩阵 &lt;em>A&lt;/em>。
$$
A=\begin{bmatrix}
1 &amp;amp; 2 \\ 3 &amp;amp; 4
\end{bmatrix}
$$&lt;/p>
&lt;p>再给出明文：&lt;em>The quick brown fox jumps over the lazy dog&lt;/em>&lt;/p>
&lt;p>将明文转换成数字（ASCII），两个一组。比如 &lt;code>Th&lt;/code> 就是 &lt;code>84 104&lt;/code> ，写成矩阵形式就是这样。&lt;/p>
&lt;p>$$
P=\begin{bmatrix}
84 \\ 104
\end{bmatrix}
$$&lt;/p>
&lt;p>将密码矩阵 &lt;em>A&lt;/em> 左乘明文矩阵 &lt;em>P&lt;/em> ，&lt;em>C=AP&lt;/em>，我们就得到了密文。&lt;/p>
&lt;p>$$
C=AP=\begin{bmatrix}
1 &amp;amp; 2 \\ 3 &amp;amp; 4
\end{bmatrix}
\begin{bmatrix}
84 \\ 104
\end{bmatrix}=
\begin{bmatrix}
292 \\ 668
\end{bmatrix}
$$&lt;/p>
&lt;h3 id="22-解密过程">2.2 解密过程&lt;/h3>
&lt;p>解密过程就是利用密码矩阵的逆矩阵 &lt;em>A&lt;sup>-1&lt;/sup>&lt;/em> ，从密文求明文的过程，公式 &lt;em>A&lt;sup>-1&lt;/sup>C=A&lt;sup>-1&lt;/sup>AP&lt;/em> 。&lt;/p>
&lt;p>2x2 矩阵的逆矩阵求解方法看前面 1.9，求得逆矩阵如下。&lt;/p>
&lt;p>$$
A^{-1}=\begin{bmatrix}
-2 &amp;amp; 1 \\ 1.5 &amp;amp; -0.5
\end{bmatrix}
$$&lt;/p>
&lt;p>然后使用逆矩阵左乘密文：&lt;/p>
&lt;p>$$
P=A^{-1}C=\begin{bmatrix}
-2 &amp;amp; 1 \\ 1.5 &amp;amp; -0.5
\end{bmatrix}
\begin{bmatrix}
292 \\ 668
\end{bmatrix}=
\begin{bmatrix}
84 \\ 104
\end{bmatrix}
$$&lt;/p>
&lt;p>即可得到明文。&lt;/p>
&lt;h3 id="23-安全性">2.3 安全性&lt;/h3>
&lt;p>Hill密码的安全性体现在隐藏了单个字母的频率信息，加密矩阵越大效果越好。&lt;/p>
&lt;p>Hill密码无法抵抗已知明文攻击，已知明文和密文时完全可以计算出加密矩阵。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>重点：&lt;/p>
&lt;ol>
&lt;li>矩阵乘法、单位矩阵、行列式和逆矩阵&lt;/li>
&lt;/ol>
&lt;p>Hill密码是将明文转为矩阵后和加密矩阵相乘，加密矩阵即为加密密钥，加密矩阵越大效果越好。解密使用加密矩阵的逆矩阵作为密钥。&lt;/p>
&lt;p>Hill 密码能隐藏字母频率信息，对抗仅密文分析，但无法对抗已知明文分析。&lt;/p></description></item><item><title>密码学入门02 - 古典密码#2</title><link>https://nnnewb.github.io/blog/p/cryptography-introduction-02/</link><pubDate>Thu, 11 Nov 2021 16:53:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/cryptography-introduction-02/</guid><description>&lt;img src="https://nnnewb.github.io/blog/p/cryptography-introduction-02/cover.jpg" alt="Featured image of post 密码学入门02 - 古典密码#2" />&lt;h2 id="前言">前言&lt;/h2>
&lt;p>从单表代替密码开始，继续学习古典密码。&lt;/p>
&lt;h2 id="0x01-playfair-密码">0x01 playfair 密码&lt;/h2>
&lt;p>&lt;em>playfair&lt;/em> 这个词乍一听我甚至有点迷惑，啥意思，公平竞赛吗。之后才知道原来是人名。&lt;/p>
&lt;h3 id="概述">概述&lt;/h3>
&lt;p>playfair 密码是最著名的多字母代替密码，它把明文中的字母对转换成密文的字母对，每次加密输入两个字母，输出两个字母。&lt;/p>
&lt;p>playfair 算法基于一个由密钥词构成的 5x5 字母矩阵，将密钥词去除重复字母后，和字母表剩余的字母按左至右、上至下的顺序填充进表里。&lt;/p>
&lt;p>举例来说，用 &lt;code>pojie&lt;/code> 作为密钥词。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>-&lt;/th>
&lt;th>-&lt;/th>
&lt;th>-&lt;/th>
&lt;th>-&lt;/th>
&lt;th>-&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>p&lt;/td>
&lt;td>o&lt;/td>
&lt;td>j&lt;/td>
&lt;td>i&lt;/td>
&lt;td>e&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>a&lt;/td>
&lt;td>b&lt;/td>
&lt;td>c&lt;/td>
&lt;td>d&lt;/td>
&lt;td>f&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>g/h&lt;/td>
&lt;td>k&lt;/td>
&lt;td>l&lt;/td>
&lt;td>m&lt;/td>
&lt;td>n&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>q&lt;/td>
&lt;td>r&lt;/td>
&lt;td>s&lt;/td>
&lt;td>t&lt;/td>
&lt;td>u&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>v&lt;/td>
&lt;td>w&lt;/td>
&lt;td>x&lt;/td>
&lt;td>y&lt;/td>
&lt;td>z&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>需要注意的是字母表有26个字母，但 playfair 的字母矩阵只有 25 个空格。出现字母表不是 5 的整数倍的情况时可以选择将多出来的字母视作同一个，或者去掉不常用的字母，使其正好填满矩阵。比如图中的&lt;code>g&lt;/code>/&lt;code>h&lt;/code>，好孩子不要学哦。常见的情况是&lt;code>i&lt;/code>/&lt;code>j&lt;/code>或者去掉&lt;code>z&lt;/code>或&lt;code>q&lt;/code>。&lt;/p>
&lt;h3 id="加密过程">加密过程&lt;/h3>
&lt;p>加密过程如下。&lt;/p>
&lt;p>第一步：将明文分成两个字母一组，两个字母重复的话就在中间填&lt;code>x&lt;/code>重新分组；如果最后剩下一个字母的话，也添加&lt;code>x&lt;/code>分成一组。举例来说，对单词&lt;code>balloon&lt;/code>，直接分组的话就是&lt;code>ba&lt;/code>、&lt;code>ll&lt;/code>、&lt;code>on&lt;/code>，填&lt;code>x&lt;/code>重新分组就是&lt;code>ba&lt;/code>、&lt;code>lx&lt;/code>、&lt;code>lo&lt;/code>、&lt;code>on&lt;/code>。&lt;/p>
&lt;p>分组后，对每个组进行加密，依然是 &lt;code>balloon&lt;/code> 为例。首先第一组 &lt;code>ba&lt;/code>。&lt;/p>
&lt;p>第二步：找出两个字母在上面表格里的行列坐标。&lt;/p>
&lt;ul>
&lt;li>&lt;code>b&lt;/code> 是第 2 行第 2 列。&lt;/li>
&lt;li>&lt;code>a&lt;/code> 是第 1 行第 2 列。&lt;/li>
&lt;/ul>
&lt;p>第三步：按规则选择代替的字母&lt;/p>
&lt;ul>
&lt;li>如果两个字母不同行也不同列，则选择本字母所在行、分组中另一个字母所在列的字母代替。&lt;/li>
&lt;li>如果两个字母在同一行，则选择明文右边的字母代替。明文在最右边则由最左边的字母代替。&lt;/li>
&lt;li>如果两个字母在同一列，则选择明文下边的字母代替。明文在最底下则由最上边的字母代替。&lt;/li>
&lt;/ul>
&lt;p>比如 &lt;code>balloon&lt;/code> 加密后，就是 &lt;code>bcsjkjek&lt;/code> 。&lt;/p>
&lt;h3 id="特点">特点&lt;/h3>
&lt;p>playfair 有 26x26 个字母对，因此识别出单个字母对相对简单的单表代替算法要困难得多。字母对的相对频率比字母的相对频率变化幅度小，利用频率分析字母对更困难。&lt;/p>
&lt;p>playfair 仍然是相对容易攻破的，因为它的密文仍然完好保留了明文语言的大部分结构特征，几百个字母的密文就足够分析出规律了。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-02/image-20211111144837847.png"
width="1325"
height="787"
srcset="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-02/image-20211111144837847_hu40999a0266ccbfe450f46cc822fe186a_187757_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/cryptography-introduction-02/image-20211111144837847_hu40999a0266ccbfe450f46cc822fe186a_187757_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20211111144837847"
class="gallery-image"
data-flex-grow="168"
data-flex-basis="404px"
>&lt;/p>
&lt;p>图中显示了 playfair 密码和其他一些密码加密的有效性，标有明文的曲线画出了超过从7w个字母的文章中得到的频率分布。曲线代表这样的含义：对文章中出现的每个字母计数，计数结果除以使用频率最高的字母出现次数。假设使用频率最高的字母 &lt;code>e&lt;/code> 出现的频率为 1 ，那么 &lt;code>t&lt;/code> 出现的频率就是 &lt;code>0.76&lt;/code> 等等。&lt;/p>
&lt;p>图中的横轴表示字母，纵轴表示字母出现的频率。 曲线体现了加密后字母频率分布被掩盖的程度。如果频率分布的信息完全被加密过程给隐藏了，那么密文的频率曲线应该是一条水平的线，唯密文密码分析由此下手将一无所获。&lt;/p>
&lt;p>图中所示的频率曲线表明 playfair 密码虽然有比明文稍平坦的频率分布曲线，但仍然透露了大量信息给密码分析者。&lt;/p>
&lt;h3 id="代码实现">代码实现&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt"> 10
&lt;/span>&lt;span class="lnt"> 11
&lt;/span>&lt;span class="lnt"> 12
&lt;/span>&lt;span class="lnt"> 13
&lt;/span>&lt;span class="lnt"> 14
&lt;/span>&lt;span class="lnt"> 15
&lt;/span>&lt;span class="lnt"> 16
&lt;/span>&lt;span class="lnt"> 17
&lt;/span>&lt;span class="lnt"> 18
&lt;/span>&lt;span class="lnt"> 19
&lt;/span>&lt;span class="lnt"> 20
&lt;/span>&lt;span class="lnt"> 21
&lt;/span>&lt;span class="lnt"> 22
&lt;/span>&lt;span class="lnt"> 23
&lt;/span>&lt;span class="lnt"> 24
&lt;/span>&lt;span class="lnt"> 25
&lt;/span>&lt;span class="lnt"> 26
&lt;/span>&lt;span class="lnt"> 27
&lt;/span>&lt;span class="lnt"> 28
&lt;/span>&lt;span class="lnt"> 29
&lt;/span>&lt;span class="lnt"> 30
&lt;/span>&lt;span class="lnt"> 31
&lt;/span>&lt;span class="lnt"> 32
&lt;/span>&lt;span class="lnt"> 33
&lt;/span>&lt;span class="lnt"> 34
&lt;/span>&lt;span class="lnt"> 35
&lt;/span>&lt;span class="lnt"> 36
&lt;/span>&lt;span class="lnt"> 37
&lt;/span>&lt;span class="lnt"> 38
&lt;/span>&lt;span class="lnt"> 39
&lt;/span>&lt;span class="lnt"> 40
&lt;/span>&lt;span class="lnt"> 41
&lt;/span>&lt;span class="lnt"> 42
&lt;/span>&lt;span class="lnt"> 43
&lt;/span>&lt;span class="lnt"> 44
&lt;/span>&lt;span class="lnt"> 45
&lt;/span>&lt;span class="lnt"> 46
&lt;/span>&lt;span class="lnt"> 47
&lt;/span>&lt;span class="lnt"> 48
&lt;/span>&lt;span class="lnt"> 49
&lt;/span>&lt;span class="lnt"> 50
&lt;/span>&lt;span class="lnt"> 51
&lt;/span>&lt;span class="lnt"> 52
&lt;/span>&lt;span class="lnt"> 53
&lt;/span>&lt;span class="lnt"> 54
&lt;/span>&lt;span class="lnt"> 55
&lt;/span>&lt;span class="lnt"> 56
&lt;/span>&lt;span class="lnt"> 57
&lt;/span>&lt;span class="lnt"> 58
&lt;/span>&lt;span class="lnt"> 59
&lt;/span>&lt;span class="lnt"> 60
&lt;/span>&lt;span class="lnt"> 61
&lt;/span>&lt;span class="lnt"> 62
&lt;/span>&lt;span class="lnt"> 63
&lt;/span>&lt;span class="lnt"> 64
&lt;/span>&lt;span class="lnt"> 65
&lt;/span>&lt;span class="lnt"> 66
&lt;/span>&lt;span class="lnt"> 67
&lt;/span>&lt;span class="lnt"> 68
&lt;/span>&lt;span class="lnt"> 69
&lt;/span>&lt;span class="lnt"> 70
&lt;/span>&lt;span class="lnt"> 71
&lt;/span>&lt;span class="lnt"> 72
&lt;/span>&lt;span class="lnt"> 73
&lt;/span>&lt;span class="lnt"> 74
&lt;/span>&lt;span class="lnt"> 75
&lt;/span>&lt;span class="lnt"> 76
&lt;/span>&lt;span class="lnt"> 77
&lt;/span>&lt;span class="lnt"> 78
&lt;/span>&lt;span class="lnt"> 79
&lt;/span>&lt;span class="lnt"> 80
&lt;/span>&lt;span class="lnt"> 81
&lt;/span>&lt;span class="lnt"> 82
&lt;/span>&lt;span class="lnt"> 83
&lt;/span>&lt;span class="lnt"> 84
&lt;/span>&lt;span class="lnt"> 85
&lt;/span>&lt;span class="lnt"> 86
&lt;/span>&lt;span class="lnt"> 87
&lt;/span>&lt;span class="lnt"> 88
&lt;/span>&lt;span class="lnt"> 89
&lt;/span>&lt;span class="lnt"> 90
&lt;/span>&lt;span class="lnt"> 91
&lt;/span>&lt;span class="lnt"> 92
&lt;/span>&lt;span class="lnt"> 93
&lt;/span>&lt;span class="lnt"> 94
&lt;/span>&lt;span class="lnt"> 95
&lt;/span>&lt;span class="lnt"> 96
&lt;/span>&lt;span class="lnt"> 97
&lt;/span>&lt;span class="lnt"> 98
&lt;/span>&lt;span class="lnt"> 99
&lt;/span>&lt;span class="lnt">100
&lt;/span>&lt;span class="lnt">101
&lt;/span>&lt;span class="lnt">102
&lt;/span>&lt;span class="lnt">103
&lt;/span>&lt;span class="lnt">104
&lt;/span>&lt;span class="lnt">105
&lt;/span>&lt;span class="lnt">106
&lt;/span>&lt;span class="lnt">107
&lt;/span>&lt;span class="lnt">108
&lt;/span>&lt;span class="lnt">109
&lt;/span>&lt;span class="lnt">110
&lt;/span>&lt;span class="lnt">111
&lt;/span>&lt;span class="lnt">112
&lt;/span>&lt;span class="lnt">113
&lt;/span>&lt;span class="lnt">114
&lt;/span>&lt;span class="lnt">115
&lt;/span>&lt;span class="lnt">116
&lt;/span>&lt;span class="lnt">117
&lt;/span>&lt;span class="lnt">118
&lt;/span>&lt;span class="lnt">119
&lt;/span>&lt;span class="lnt">120
&lt;/span>&lt;span class="lnt">121
&lt;/span>&lt;span class="lnt">122
&lt;/span>&lt;span class="lnt">123
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;array&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;cctype&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;cstddef&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;cstdlib&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iterator&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;ostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;set&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;string&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;unordered_set&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;utility&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="k">constexpr&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">lowercase&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;abcdefghijklmnopqrstuvwxyz&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 保持顺序的情况下，对输入文本去重，并且从文本里把字符j替换成i
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">my_unique&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">ret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">text&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">replace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ret&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">ret&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="sc">&amp;#39;j&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;i&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">unordered_set&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">auto&lt;/span> &lt;span class="n">last&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">stable_partition&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ret&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">ret&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">](&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">bool&lt;/span> &lt;span class="n">ret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// not exists
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">ret&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">});&lt;/span>
&lt;span class="n">ret&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">erase&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">last&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ret&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">());&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">ret&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 从密钥字符串构造出 playfair 密钥矩阵
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">playfair_matrix&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 初始化密钥，构造的密钥中没有 j，加密时 j 视作 i 处理
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">fullkey&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">my_unique&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">lowercase&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">fullkey&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cerr&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;invalid key length&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 构造矩阵
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">matrix&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="nl">c&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">fullkey&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">matrix&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">count&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="o">++&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">matrix&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 用迭代器读取一组两个字符（从当前位置开始，*iter 和 *(iter+1) 为一组）。
&lt;/span>&lt;span class="c1">// 如果后续两个字符重复，则取一个字符加上 x 返回；
&lt;/span>&lt;span class="c1">// 如果后续仅剩一个字符也加上 x 返回。
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">next2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">const_iterator&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">const_iterator&lt;/span> &lt;span class="n">end&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">ret&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">it&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">end&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">it&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">ret&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tolower&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">ret&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sc">&amp;#39;x&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">ret&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tolower&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">ret&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">tolower&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">ret&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 获得字符在密钥矩阵中的坐标，返回 (行,列)
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">pair&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">get_row_col&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">matrix&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">size_t&lt;/span> &lt;span class="n">r&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">r&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">matrix&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">const&lt;/span> &lt;span class="k">auto&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">row&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">matrix&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="k">auto&lt;/span> &lt;span class="n">col&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">row&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">find&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">col&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">row&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">npos&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">make_pair&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">col&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">make_pair&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// playfair 加密函数
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">playfair_cipher&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">input&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">ciphertext&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">auto&lt;/span> &lt;span class="n">matrix&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">playfair_matrix&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">auto&lt;/span> &lt;span class="n">it&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">input&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">cbegin&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">it&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">input&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">cend&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">auto&lt;/span> &lt;span class="n">char_pair&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">next2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">input&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">cend&lt;/span>&lt;span class="p">());&lt;/span>
&lt;span class="k">auto&lt;/span> &lt;span class="n">c1_pos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_row_col&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">matrix&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">char_pair&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;j&amp;#39;&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="sc">&amp;#39;i&amp;#39;&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">char_pair&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="k">auto&lt;/span> &lt;span class="n">c2_pos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">get_row_col&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">matrix&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">char_pair&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;j&amp;#39;&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="sc">&amp;#39;i&amp;#39;&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">char_pair&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">c1_pos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">c2_pos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 同一行，取同行下一个字符
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">auto&lt;/span> &lt;span class="n">row&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">c1_pos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">auto&lt;/span> &lt;span class="n">c1_col&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">c1_pos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">second&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">c1_pos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">second&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">auto&lt;/span> &lt;span class="n">c2_col&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">c2_pos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">second&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">c2_pos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">second&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">ciphertext&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">matrix&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">row&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">c1_col&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="n">ciphertext&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">matrix&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">row&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">c2_col&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="nf">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">c1_pos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">second&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">c2_pos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">second&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 同一列，取同列下一个字符
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">auto&lt;/span> &lt;span class="n">col&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">c1_pos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">second&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">auto&lt;/span> &lt;span class="n">c1_row&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">c1_pos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">c1_pos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">auto&lt;/span> &lt;span class="n">c2_row&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">c2_pos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">c2_pos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">ciphertext&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">matrix&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">c1_row&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">col&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="n">ciphertext&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">matrix&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">c2_row&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">col&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 不同行也不同列，取本行，另一字符所在列的字符
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">auto&lt;/span> &lt;span class="n">row&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">c1_pos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">auto&lt;/span> &lt;span class="n">c1_col&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">c2_pos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">second&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">auto&lt;/span> &lt;span class="n">c2_col&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">c1_pos&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">second&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">ciphertext&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">matrix&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">row&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">c1_col&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="n">ciphertext&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">matrix&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">row&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">c2_col&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">ciphertext&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="k">auto&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nl">row&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">playfair_matrix&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;haoye&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">row&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;ciphertext:&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">playfair_cipher&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;helloworld&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;haoye&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以上是 playfair 加密的 c++ 实现。比较怪的是 playfair 网上可以找到很多变体，比如 &lt;a class="link" href="http://www.practicalcryptography.com/ciphers/classical-era/playfair/#javascript-example-of-the-playfair-cipher" target="_blank" rel="noopener"
>practice cryptography&lt;/a> 描述和实现的 playfair 算法是在分组阶段，把重复出现的第二个字符替换成 &lt;code>x&lt;/code> 。&lt;/p>
&lt;p>解密没有在这里实现，解密函数规则如下：&lt;/p>
&lt;ul>
&lt;li>如果一组两个字母在同一行，则用前一列字母替换，第一列用最后一列字母替换。&lt;/li>
&lt;li>如果一组两个字母在同一列，则用前一行字母替换，第一行用最后一行字母替换。&lt;/li>
&lt;li>如果一组两个字符不在同一列同一行，则取同一行，一组中另一字母所在列的字母替换。&lt;/li>
&lt;/ul>
&lt;p>就是把加密规则反过来执行，唯一的区别是在分组阶段不用考虑相同字母，出现相同字母说明密文有问题，可以跳过这一组字母。最后解密结果会出现多余的&lt;code>x&lt;/code>，如果明文包含&lt;code>j&lt;/code>的话解密结果会变成&lt;code>i&lt;/code>。&lt;/p>
&lt;h2 id="结论">结论&lt;/h2>
&lt;p>简要描述 playfair 算法加密过程：&lt;/p>
&lt;ul>
&lt;li>从密钥构造 5x5 矩阵&lt;/li>
&lt;li>对明文按两个字母一组分组，分组过程中处理连续重复字符（重复字母间插入&lt;code>x&lt;/code>）和孤立字母（末尾剩余的最后一个字母也加上&lt;code>x&lt;/code>）&lt;/li>
&lt;li>按规则，对一组两个字母进行替换，直到所有明文都被替换完成
&lt;ul>
&lt;li>如果两个字母在矩阵同一行，取字母在本行的下一个字母替换，行末字母取行首。&lt;/li>
&lt;li>如果两个字母在矩阵同一列，取字母在本列的下一个字母替换，列末字母取列首。&lt;/li>
&lt;li>如果不同行不同列，取字母本行，本组另一字母所在列的字母替换。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>playfair 密码的相比简单单表替换，分析难度大得多。但依然完整保留了语言的结构特征，因此分析依然比较容易。&lt;/p></description></item><item><title>密码学入门01 - 古典密码#1</title><link>https://nnnewb.github.io/blog/p/cryptography-introduction-01/</link><pubDate>Thu, 11 Nov 2021 11:35:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/cryptography-introduction-01/</guid><description>&lt;img src="https://nnnewb.github.io/blog/p/cryptography-introduction-01/cover.jpg" alt="Featured image of post 密码学入门01 - 古典密码#1" />&lt;h2 id="前言">前言&lt;/h2>
&lt;p>本文是学习《密码编码学与网络安全》一书的笔记，关于传统加密技术一章。&lt;/p>
&lt;h2 id="0x01-对称密码模型">0x01 对称密码模型&lt;/h2>
&lt;p>对称加密，也称传统加密或单钥加密，是20世纪70年代公钥密码产生之前唯一的加密类型。迄今为止，它仍是使用最广泛的加密类型。&lt;/p>
&lt;p>对称加密方案有5个基本成分：&lt;/p>
&lt;ul>
&lt;li>明文：原始可以理解的消息或数据，是算法的输入。&lt;/li>
&lt;li>加密算法：加密算法对明文进行各种代替和变换。&lt;/li>
&lt;li>密钥：密钥也是加密算法的输入。密钥独立于明文和算法。算法根据所用的特定密钥而产生不同的输出。算法所用的确切代替和变换也依靠密钥。&lt;/li>
&lt;li>密文：作为算法的输出，看起来完全随机而杂乱的消息，依赖于明文和密钥。对于给定的消息，不同密钥产生不同的密文，密文看上去是随机的数据流并且其意义是不可理解的。&lt;/li>
&lt;li>解密算法：本质上是加密算法的逆运算。输入密文和密钥，输出原始明文。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110140236382.png"
width="1155"
height="377"
srcset="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110140236382_hu8783c317e7f9de22b27c24c57fb0b0d7_134857_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110140236382_hu8783c317e7f9de22b27c24c57fb0b0d7_134857_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20211110140236382"
class="gallery-image"
data-flex-grow="306"
data-flex-basis="735px"
>&lt;/p>
&lt;p>传统密码的安全使用要满足两个要求：&lt;/p>
&lt;ul>
&lt;li>加密算法必须是足够强的。即使攻击者拥有一定数量的密文和产生这些密文的明文，他也不能破译密文或发现密钥。&lt;/li>
&lt;li>发送者和接收者必须在某种安全的形式下获得密钥并保证密钥安全。如果有人发现密钥，并知道算法，就能解读使用该密钥加密的所有通信。&lt;/li>
&lt;/ul>
&lt;p>我们假设基于已知密文和加密/解密算法而破译消息是不实际的，我们不需要算法保密，仅需要密钥保密。如果密钥是由信息的发送方产生的，那么它要通过某种安全信道发送到接收方；另一种是由第三方生成密钥后再安全地分发给发送方和接收方。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="c1">// 明文X，共 m 个元素
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">byte&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">m&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">X&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">X1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">X2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">X3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">X4&lt;/span>&lt;span class="p">,...,&lt;/span>&lt;span class="n">Xm&lt;/span>&lt;span class="p">};&lt;/span>
&lt;span class="c1">// 密钥K，共 j 个元素
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">byte&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">K&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">K1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">K2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">K3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">K4&lt;/span>&lt;span class="p">,...,&lt;/span>&lt;span class="n">Kj&lt;/span>&lt;span class="p">};&lt;/span>
&lt;span class="c1">// 加密算法E，以明文和密钥为输入，输出密文 Y
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">byte&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">Y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">E&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">X&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">K&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="c1">// 解密算法D，以密文和密钥为输入，输出明文 X
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">byte&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">X&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">D&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">K&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="11-密码编码学">1.1 密码编码学&lt;/h3>
&lt;p>密码编码系统有三个独立特征：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>转换明文为密文的运算类型&lt;/strong>。&lt;strong>所有的加密算法都基于两个原理：代替和置换&lt;/strong>。代替是将明文中的每个元素（如位、字母、位组或字母组）映射成另一个元素；置换是将明文中的元素重新排列。上述运算的基本要求是不允许有信息丢失（所有运算都是可逆的）。大多密码体制也称为乘积密码系统，都使用了多层代替和置换。&lt;/li>
&lt;li>&lt;strong>所用的密钥数&lt;/strong>。如果发送方和接收方使用相同的密钥，这种密码就称为对称密码、单密钥密码或传统密码。如果发收双方使用不同的密钥，这种密码就称为非对称密码、双钥或公钥密码。&lt;/li>
&lt;li>&lt;strong>处理明文的方法&lt;/strong>。分组密码每次处理输入的一组元素，相应地输出一组元素。流密码则是连续地处理输入元素，每次输出一个元素。&lt;/li>
&lt;/ul>
&lt;p>攻击密码系统的典型目标是恢复使用的密钥，而不仅仅恢复出单个密文对应的明文。攻击传统密码有两种通用的方法。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>密码分析学&lt;/strong>：密码分析学攻击依赖于算法的性质、明文的一般特征或某些明密文对。这种攻击形式企图利用算法的特征来推导出特定的明文或使用的密钥。&lt;/li>
&lt;li>&lt;strong>穷举攻击&lt;/strong>：攻击者对一条密文尝试所有可能的密钥，直到把它转化为可读的有意义的明文。平均而言，获得成功至少要尝试所有可能的密钥的一半。&lt;/li>
&lt;/ul>
&lt;p>基于密码分析者知道的信息的多少，概括密码攻击的几种类型如下。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>攻击类型&lt;/th>
&lt;th>攻击者已知的信息&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>唯密文攻击&lt;/td>
&lt;td>加密算法；密文；&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>已知明文攻击&lt;/td>
&lt;td>加密算法；密文；与待解密密文同一密钥加密的一个或多个明密文对；&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>选择明文攻击&lt;/td>
&lt;td>加密算法；密文；分析者选择的明文，以及对应的（使用和待解密密文同一密钥）加密的密文；&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>选择密文攻击&lt;/td>
&lt;td>加密算法；密文；分析者选择的密文，以及对应的（使用和待解密密文同一密钥）的解密明文；&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>选择文本攻击&lt;/td>
&lt;td>加密算法；密文；分析者选的明文，以及对应的密文；分析者选择的密文，以及对应的明文，使用和待解密密文同一密钥。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>唯密文攻击最容易防范，但很多情况下分析者可以得到更多的信息。比如 postscript 格式加密的文件总是以相同的格式开头，电子金融消息往往有标准化的文件头或者标志，类似的例子还有很多，这些都是已知明文攻击的例子。有这些知识的分析者就可以从转换明文的方法入手来推导出密钥。&lt;/p>
&lt;p>与已知明文攻击紧密相关的是可能词攻击。如果攻击者处理的是一些特定的信息，他就可能知道其中的部分内容。比如说，某公司开发的程序源代码就可能包含该公司的版权信息，并放在某个标准位置。&lt;/p>
&lt;p>如果分析者能通过某种方式让发送方在发送的信息中插入一段由他选择的信息，那么选择明文攻击就有可能实现。一般来说，如果分析者有办法选择明文加密，那么他将特意选取那些最有可能会付出密钥的数据。&lt;/p>
&lt;p>只有相对较弱的算法才抵挡不住唯密文攻击，一般地说，加密算法起码要能经受住已知明文攻击才行。&lt;/p>
&lt;p>如果一个密码体制满足条件：无论有多少可使用的密文，都不足以唯一地确定密文所对应的明文，则称该加密体制是无条件安全的。也就是攻击者无论花多少时间，都无法将密文解密，因为他所需的信息不在密文中。除了一次一密之外所有的加密算法都不是无条件安全的。&lt;/p>
&lt;p>加密算法使用者应该尽量挑选满足下面标准的算法：&lt;/p>
&lt;ul>
&lt;li>破译密码的代价超过密文信息的价值。&lt;/li>
&lt;li>破译密码的时间超出密文信息的有效生命期。&lt;/li>
&lt;/ul>
&lt;p>如果满足上述标准中任意一条则它在计算上是安全的，但估计攻击者破译密文所需的工作量是非常困难的。&lt;/p>
&lt;p>从穷举法入手，考虑所需的时间。穷举要获得成功平均来说必须尝试所有可能密钥的一半，下图给出了不同密钥空间穷举尝试所需的时间。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110150214623.png"
width="1431"
height="356"
srcset="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110150214623_hua784c719a6627b81510d7a296f0c9cd9_192031_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110150214623_hua784c719a6627b81510d7a296f0c9cd9_192031_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20211110150214623"
class="gallery-image"
data-flex-grow="401"
data-flex-basis="964px"
>&lt;/p>
&lt;h2 id="0x02-代替技术">0x02 代替技术&lt;/h2>
&lt;h3 id="21-caesar-凯撒密码">2.1 Caesar 凯撒密码&lt;/h3>
&lt;p>已知最早的代替密码是由 julius caesar 发明的 caesar 密码。caesar 密码非常简单，就是对字母表中的每个字母，用它之后的第三个字母来代替，字母表是首尾相连循环的。&lt;/p>
&lt;p>凯撒密码可以这样表达：&lt;code>C = E(k, p) = (p + k) mod 26&lt;/code>。&lt;/p>
&lt;p>凯撒密码的解密算法可以这样表达：&lt;code>p = D(k, C) = (C - k) mod 26&lt;/code>。&lt;/p>
&lt;p>其中 k 的取值范围是 1-25，取值为 0 的情况下就是明文；取值26和取值0相同；取值超过 26 则相当于是取了 &lt;code>k mod 26&lt;/code> ，因为字母表是循环的；取负数相当于取 &lt;code>26 + k&lt;/code>，因为字母表是循环的。&lt;/p>
&lt;p>一个简单的实现如下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="k">enum&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">CryptMode&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">encrypt&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">decrypt&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">caesar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">plaintext&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">CryptMode&lt;/span> &lt;span class="n">mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">output&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="nl">c&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">plaintext&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">mode&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">CryptMode&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">decrypt&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">output&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">c&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="sc">&amp;#39;A&amp;#39;&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">26&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="sc">&amp;#39;a&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">output&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="n">c&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="sc">&amp;#39;a&amp;#39;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">26&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="sc">&amp;#39;A&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">output&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对于输入 &lt;code>hello&lt;/code> ，&lt;code>k=3&lt;/code>，输出为 &lt;code>KHOOR&lt;/code> 。&lt;/p>
&lt;p>如果已知某给定的密文是 caesar 密码，穷举攻击是很容易实现的：只要简单地测试25种可能的密钥。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">brute_force_caesar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">ciphertext&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">25&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">result&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">caesar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">ciphertext&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">CryptMode&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">decrypt&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>将前面的密文输入，得到输出如下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plaintext" data-lang="plaintext">brute force caesar: jgnnq
brute force caesar: ifmmp
brute force caesar: hello
brute force caesar: gdkkn
... 下略
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到明文已经出现。&lt;/p>
&lt;p>凯撒密码的三个重要特征使我们可以穷举攻击：&lt;/p>
&lt;ol>
&lt;li>已知加解密的算法&lt;/li>
&lt;li>需测试的密钥只有25个&lt;/li>
&lt;li>明文所用的语言是已知的，而且意义易于识别&lt;/li>
&lt;/ol>
&lt;p>大多情况下，我们假设密码算法是已知的。一般密钥空间很大的算法可以使穷举攻击不太可能，例如3DES算法的密钥长度是 168 位，密钥空间是 2^168，有大于 3.7*10^50 种可能的密钥。&lt;/p>
&lt;p>如果明文所用的语言不为我们所知，那么明文输出就不可识别。输入也可能按照某种方式经过缩写或压缩，也就更不可能识别了。例如一个经过zip压缩的文本文件，用一种简单的代替密码来加密，那么即使用穷举法来进行密码分析，恢复出来的明文也是不可识别的。（注：实际上可以通过文件头、magic number 之类的已知特征来猜测出内容是被压缩过的）。&lt;/p>
&lt;h3 id="22-单表代替密码">2.2 单表代替密码&lt;/h3>
&lt;p>凯撒密码是一种代替密码，每个明文元素唯一对应代替表中的一个密文元素。因为代替表是字母表的循环移动，故密码范围只有 1-25。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110155545123.png"
width="571"
height="92"
srcset="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110155545123_hu3e213ee09efbd6d51e121868c96de46b_37508_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110155545123_hu3e213ee09efbd6d51e121868c96de46b_37508_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20211110155545123"
class="gallery-image"
data-flex-grow="620"
data-flex-basis="1489px"
>&lt;/p>
&lt;p>定义术语&lt;strong>置换&lt;/strong>：设有限元素的集合 &lt;em>S&lt;/em> 的置换是 &lt;em>S&lt;/em> 的所有元素的有序排列，而且每个元素只出现一次。例如，如果有 &lt;code>S = {a,b,c}&lt;/code> ，则 &lt;em>S&lt;/em> 有 6 个置换：&lt;code>abc,acb,bac,bca,cab,cba&lt;/code> 。一般具有 n 个元素的集合有 &lt;code>n!&lt;/code> 个置换。&lt;/p>
&lt;p>如果代替表是26个字母的任意置换，那么就有 &lt;code>26!&lt;/code> 种可能的密钥，大于 &lt;code>4*10^26&lt;/code> 种可能，这比 DES 的密钥空间还要大 10 个数量级，看起来能抵挡穷举攻击了。&lt;/p>
&lt;p>这种方法被称为单表代替密码，每条消息用一个字母表（给出从明文字母到密文字母的映射）加密。&lt;/p>
&lt;h3 id="23-词频攻击">2.3 词频攻击&lt;/h3>
&lt;p>对于单表代替密码，如果攻击者知道明文的属性，比如知道明文是未经压缩的英文文本，就可以通过语言的一些统计学规律进行攻击。&lt;/p>
&lt;p>例如下图中的密文。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110160433970.png"
width="841"
height="141"
srcset="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110160433970_hu0bae56299b47face312e3af416d81f8d_75914_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110160433970_hu0bae56299b47face312e3af416d81f8d_75914_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20211110160433970"
class="gallery-image"
data-flex-grow="596"
data-flex-basis="1431px"
>&lt;/p>
&lt;p>已知明文是英文文本，首先把字母使用的相对频率统计出来，与英文字母的使用频率分布进行比较。&lt;/p>
&lt;p>密文字母使用频率：&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110160604203.png"
width="1345"
height="237"
srcset="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110160604203_hud2bc73f9e0917779ec0f259ca64b743c_85725_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110160604203_hud2bc73f9e0917779ec0f259ca64b743c_85725_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20211110160604203"
class="gallery-image"
data-flex-grow="567"
data-flex-basis="1362px"
>&lt;/p>
&lt;p>英文字母使用频率：&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110160620669.png"
width="884"
height="656"
srcset="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110160620669_hu4f20a761c6fb706ee66e5ab52766ee21_322944_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110160620669_hu4f20a761c6fb706ee66e5ab52766ee21_322944_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20211110160620669"
class="gallery-image"
data-flex-grow="134"
data-flex-basis="323px"
>&lt;/p>
&lt;p>此时我们可以尝试在密文上做一些代替，填入明文，看看是否形成一个可读消息。更系统一点的方法是寻找其他规律，例如明文中有某些词可能是已知的，或者寻找密文字母中的重复序列，推导它们的等价明文。统计双字母组合的频率会是个很有效的工具。&lt;/p>
&lt;p>尝试分析的结果是：&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110160738100.png"
width="831"
height="242"
srcset="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110160738100_hub66bc3a0a336c5d68333c334cbbee3ec_99281_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110160738100_hub66bc3a0a336c5d68333c334cbbee3ec_99281_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20211110160738100"
class="gallery-image"
data-flex-grow="343"
data-flex-basis="824px"
>&lt;/p>
&lt;p>继续进行分析和测试可以很快得出完整的明文。&lt;/p>
&lt;p>&lt;img src="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110161027735.png"
width="960"
height="111"
srcset="https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110161027735_hu97cc0623de9f6e01bc3a236c731df603_66342_480x0_resize_box_3.png 480w, https://nnnewb.github.io/blog/blog/p/cryptography-introduction-01/image-20211110161027735_hu97cc0623de9f6e01bc3a236c731df603_66342_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="image-20211110161027735"
class="gallery-image"
data-flex-grow="864"
data-flex-basis="2075px"
>&lt;/p>
&lt;p>实践：&lt;/p>
&lt;p>实现一个简单的替代密码，用随机生成的密码表。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">substitution_cipher&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">plaintext&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">chart&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">output&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="nl">c&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">plaintext&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">output&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">chart&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">at&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tolower&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">)));&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">out_of_range&lt;/span> &lt;span class="n">err&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;invalid input&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">output&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 替代密码表
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">chart&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;a&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;o&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;b&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;a&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;c&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;f&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;d&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;u&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;e&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;g&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;f&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;y&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;g&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;n&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;h&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;k&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;i&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;e&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;j&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;z&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;k&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;t&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;l&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;b&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;m&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;d&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;n&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;p&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;o&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;l&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;p&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;m&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;q&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;j&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;r&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;q&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;s&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;c&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;t&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;i&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;u&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;w&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;v&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;x&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;w&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;s&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;x&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;v&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;y&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;r&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;z&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;h&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;,&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;,&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;.&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;.&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="sc">&amp;#39;\&amp;#39;&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;\&amp;#39;&amp;#39;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="p">};&lt;/span>
&lt;span class="k">auto&lt;/span> &lt;span class="n">ciphertext&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">substitution_cipher&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;It can solve simple substitution ciphers often found in newspapers, including puzzles like cryptoquips&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">chart&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">ciphertext&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>加密结果：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plaintext" data-lang="plaintext">ei fop clbxg cedmbg cwacieiwielp femkgqc lyigp ylwpu ep pgscmomgqc, epfbwuepn mwhhbgc betg fqrmiljwemc
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以在 &lt;a class="link" href="https://www.quipqiup.com/" target="_blank" rel="noopener"
>quipquip&lt;/a> 尝试解密。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>Q：对称密码的本质成分&lt;/p>
&lt;p>明文、密文、密钥、加密算法、解密算法。&lt;/p>
&lt;p>Q：密码算法中的两个基本函数&lt;/p>
&lt;p>替代和置换。&lt;/p>
&lt;p>Q：用密码通信的两个人需要多少密钥&lt;/p>
&lt;p>1个（对称加密）或 2 个（公钥加密）。&lt;/p>
&lt;p>关于这点对书本有点困惑，实际经验告诉我需要至少4个密钥（发送方公钥、发送方私钥、接收方公钥、接收方私钥），书本里可能把一对公私钥算一个密钥。&lt;/p>
&lt;p>Q：分组密码和流密码的区别&lt;/p>
&lt;p>分组密码一次处理一组元素，一次输出一组元素。流密码连续处理输入元素，每次输出一个元素。&lt;/p>
&lt;p>Q：攻击密码的两种一般方法是什么&lt;/p>
&lt;p>密码分析和穷举。密码分析学攻击依赖于算法的性质、明文的一般特征或某些明密文对。这种攻击形式企图利用算法的特征来推导出特定的明文或使用的密钥。穷举法则是枚举所有可能的密钥，直到获得有意义的明文。&lt;/p>
&lt;p>Q：列出和定义基于攻击者所知信息的密码分析攻击类型&lt;/p>
&lt;ul>
&lt;li>唯密文攻击。已知算法和密文。&lt;/li>
&lt;li>已知明文攻击。已知算法、密文、明文。&lt;/li>
&lt;li>选择密文攻击。已知算法、密文、攻击者选择的明文和对应的密文。（攻击者可以控制待加密内容）&lt;/li>
&lt;li>选择明文攻击。已知算法、密文、攻击者选择的密文和对应的明文。（攻击者可以控制待解密内容）&lt;/li>
&lt;li>选择文本攻击。已知算法、密文、攻击者选择的密文和对应的明文、攻击者选择的明文和对应的密文。（攻击者可以自由加密/解密，但不知道密钥）&lt;/li>
&lt;/ul>
&lt;p>Q：无条件安全密码和计算上安全的密码区别是什么&lt;/p>
&lt;p>无条件安全密码无法从密文分析出密钥，不可破译。&lt;/p>
&lt;p>计算上安全的密码满足两个条件之一：&lt;/p>
&lt;ol>
&lt;li>破译密文的代价大于密文信息的价值。&lt;/li>
&lt;li>破译密码的时间超过密文信息的有效期。&lt;/li>
&lt;/ol>
&lt;p>Q：简要定义 Caesar 密码&lt;/p>
&lt;p>&lt;code>C = E(k, p) = (p + k) mod 26&lt;/code>&lt;/p>
&lt;p>&lt;code>p = D(k, C) = (C - k) mod 26&lt;/code>&lt;/p>
&lt;p>Q：简要定义单表代替密码&lt;/p>
&lt;p>允许字母任意替代，明文字母表和密文字母表是&lt;a class="link" href="https://baike.baidu.com/item/%E5%8F%8C%E5%B0%84/942799" target="_blank" rel="noopener"
>双射&lt;/a>的。&lt;/p></description></item></channel></rss>