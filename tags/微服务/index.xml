<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>微服务 on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link><description>Recent content in 微服务 on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 02 Mar 2022 12:30:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/index.xml" rel="self" type="application/rss+xml"/><item><title>gokit 架构之我见</title><link>https://nnnewb.github.io/blog/p/my-opinion-of-gokit-architecture/</link><pubDate>Wed, 02 Mar 2022 12:30:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/my-opinion-of-gokit-architecture/</guid><description>前言 这是看了 Go kit: the road ahead 之后，对 go kit 这套抽象的一些想法。主要是关于 endpoint 是否有必要、generic 会如何影响 go kit 的架构、go kit 的代码生成这些问题。
endpoint 抽象层是否必要存在 我的看法是需要。原因下面分析。
一个没有额外功能的 Endpoint 其实是起到了把请求类型适配到 Go 函数签名的作用。stringsvc 实现如下。
import ( &amp;#34;context&amp;#34; &amp;#34;github.com/go-kit/kit/endpoint&amp;#34; ) func makeUppercaseEndpoint(svc StringService) endpoint.Endpoint { return func(_ context.Context, request interface{}) (interface{}, error) { req := request.(uppercaseRequest) v, err := svc.Uppercase(req.S) if err != nil { return uppercaseResponse{v, err.Error()}, nil } return uppercaseResponse{v, &amp;#34;&amp;#34;}, nil } } func makeCountEndpoint(svc StringService) endpoint.</description></item><item><title>go-kit 笔记</title><link>https://nnnewb.github.io/blog/p/go-kit-note/</link><pubDate>Tue, 01 Mar 2022 12:30:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/go-kit-note/</guid><description>前言 初步看了下 gokit 的案例 stringsvc和apigateway，记录一下对 gokit 的映像。
gokit定位 Go kit is a programming toolkit for building microservices (or elegant monoliths) in Go. We solve common problems in distributed systems and application architecture so you can focus on delivering business value.
Go has emerged as the language of the server, but it remains underrepresented in so-called &amp;ldquo;modern enterprise&amp;rdquo; companies like Facebook, Twitter, Netflix, and SoundCloud. Many of these organizations have turned to JVM-based stacks for their business logic, owing in large part to libraries and ecosystems that directly support their microservice architectures.</description></item></channel></rss>