<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编译技术 on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/</link><description>Recent content in 编译技术 on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 13 Dec 2021 16:20:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml"/><item><title>基于栈的虚拟机</title><link>https://nnnewb.github.io/blog/p/stack-based-virtual-machine-for-minilang/</link><pubDate>Mon, 13 Dec 2021 16:20:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/stack-based-virtual-machine-for-minilang/</guid><description>前言 之前写了个s表达式求值器，很简陋，直接在抽象语法树上执行。只是这样的话其实还没啥意思，所以再试试改进成在基于栈的虚拟机上执行。
0x01 虚拟机模型 首先得承认对这些语言层级的虚拟机不熟，基本是随便设计的。
对象模型 虚拟机指令操作的目标是 对象 ，包括内建的对象和用户定义的对象，虚拟机指令操作的基本单位也是对象。
目前关注的是内建的对象，简单抽象出了几个基本类型。
type Object interface { TypeName() string } type UInt uint64 func (u UInt) TypeName() string { return &amp;#34;UInt&amp;#34; } type Float float64 func (f Float) TypeName() string { return &amp;#34;Float&amp;#34; } type Boolean bool func (b Boolean) TypeName() string { return &amp;#34;boolean&amp;#34; } type String string func (s String) TypeName() string { return &amp;#34;string&amp;#34; } type Symbol string func (s Symbol) TypeName() string { return &amp;#34;symbol&amp;#34; } type Nil struct{} func (n Nil) TypeName() string { return &amp;#34;nil&amp;#34; } 省略了一部分，领会精神即可。上面定义的 Symbol 类型其实就是 #ident 这种语法元素，目的是保持语义上的简洁。</description></item><item><title>一个s表达式求值器</title><link>https://nnnewb.github.io/blog/p/a-s-exp-evaluator/</link><pubDate>Thu, 09 Dec 2021 17:11:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/a-s-exp-evaluator/</guid><description>前言 翻没看过的藏书的时候找出一本《SICP》的 PDF（PS：已经买了正版书），想起曾经拿 Rust 写玩具解释器，结果现在连 Rust 本身都已经快忘光了。
所以就当怀旧，写个很简单的玩具，s表达式求值器。
技术栈 语言选择了 Go，用 gocc 生成 Parser/Lexer 。虽然说手写+调试 Lexer/Parser 也是挺快乐的，但毕竟只是怀旧重温下当年愣头青的自己，不想花太多时间。
词法定义 简单解释下 gocc 定义词法元素的 DSL 是怎么回事。gocc 的这个 DSL 是类似于 EBNF 的语法（自称）， _letter: 'a'-'z' 就是一条产生式，:前面是产生式的名称，后面是模式。
产生式名称也有特殊含义。
! 开头的产生式会被 Lexer 忽略。 _ 开头的产生式叫做 regDefId，可以理解成给后面的模式定义的别名。 a-z小写字母开头的是 token，也就是一般说的词法元素定义了。 值得注意的是 token 不能被用作其他词法元素产生式的模式部分，但 regDefId 可以，所以要注意要复用的规则应该定义成下划线开头。
比如说下面的例子。
// example 1 letter: &amp;#39;a&amp;#39;-&amp;#39;z&amp;#39;; identifier: letter; // Error! // example 2 _letter: &amp;#39;a&amp;#39;-&amp;#39;z&amp;#39;; identifier: _letter; // OK 下面是求值器的词法元素定义。
!whitespace: &amp;#39; &amp;#39; | &amp;#39;\t&amp;#39; | &amp;#39;\r&amp;#39; | &amp;#39;\n&amp;#39;; !</description></item><item><title>用 tree-sitter 写一个代码高亮</title><link>https://nnnewb.github.io/blog/p/%E7%94%A8-tree-sitter-%E5%86%99%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/</link><pubDate>Tue, 03 Aug 2021 15:52:21 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E7%94%A8-tree-sitter-%E5%86%99%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/</guid><description>这次用 tree-sitter 写一个简单的代码高亮。
前言 我寻思代码高亮是什么应该没啥可解释的，也有叫“语法高亮”，总之都是一个意思。就是给编辑器里的代码涂上颜色，便于阅读。
一般来说，简单的代码高亮只需要正则表达式就能搞定（比如说关键字高亮，Camel Case 标识符高亮等），不过正则表达式来实现高亮还是有很大的局限性。
举例来说，当我把函数当参数传给另一个函数的时候——
function f() {} function higher(fn) { return () =&amp;gt; fn() != 0; } higher(f); 在 higher(f) 这一行中的 f 不会以函数名的颜色标出。这就引出了一种新基于语义的代码高亮，让编辑器真正“认识”你的代码，并提供更聪明的提示。
开始 还是在 vscode 折腾。
先创建一个 vscode 插件项目，用 yo code 完成。
然后编辑 package.json ，添加你的语言和插件的激活事件。
{ &amp;#34;activationEvents&amp;#34;: [&amp;#34;onLanguage:proto&amp;#34;], &amp;#34;contributes&amp;#34;: { &amp;#34;languages&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;proto&amp;#34;, &amp;#34;extensions&amp;#34;: [&amp;#34;.proto&amp;#34;] } ] } } 然后修改 src/extension.ts，去掉默认创建的 hello world 代码，留一个 console.log，然后 F5 启动，打开一个 .proto 文件，检查插件是否已经激活。
// The module &amp;#39;vscode&amp;#39; contains the VS Code extensibility API // Import the module and reference it with the alias vscode in your code below import * as vscode from &amp;#34;vscode&amp;#34;; // this method is called when your extension is activated // your extension is activated the very first time the command is executed export function activate(context: vscode.</description></item><item><title>玩玩 tree-sitter</title><link>https://nnnewb.github.io/blog/p/%E7%8E%A9%E7%8E%A9-tree-sitter/</link><pubDate>Thu, 29 Jul 2021 10:14:36 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E7%8E%A9%E7%8E%A9-tree-sitter/</guid><description>什么是tree-sitter呢？
tree-sitter 是一个 parser-generator，也是一个增量解析库（incremental parsing library）。它可以为源文件构建完整的语法树，并在源文件被编辑时高效地更新。
快速开始 tree-sitter 本身是一个 parser generator ，使用 javascript 来作为描述语法规则的语言（不像其他，如 yacc 一类的工具，以类似 EBNF 的 DSL 来描述语法规则）。
我们写 tree-sitter 语法规则本质上是类似于写一个 tree-sitter 的语法支持包，可以参考下 tree-sitter/tree-sitter-go: Go grammar for tree-sitter (github.com) 的项目结构。
废话不多说，先写个简单的 demo 跑起来。
mkdir tree-sitter-hello &amp;amp;&amp;amp; cd tree-sitter-hello npm init npm i --save nan npm i --save-dev tree-sitter-cli 初始化好项目目录，在 package.json 里写个简单的命令，方便之后用。
{ &amp;#34;scripts&amp;#34;:{ &amp;#34;test&amp;#34;: &amp;#34;tree-sitter generate &amp;amp;&amp;amp; tree-sitter parse test.txt&amp;#34; } } 现在开始干正事儿，创建一个 grammar.js
module.exports = grammar({ name: &amp;#39;hello&amp;#39;, rules: { source_file: $ =&amp;gt; repeat($.</description></item></channel></rss>