<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编译技术 on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/</link><description>Recent content in 编译技术 on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 03 Aug 2021 15:52:21 +0000</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml"/><item><title>用 tree-sitter 写一个代码高亮</title><link>https://nnnewb.github.io/blog/p/%E7%94%A8-tree-sitter-%E5%86%99%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/</link><pubDate>Tue, 03 Aug 2021 15:52:21 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/%E7%94%A8-tree-sitter-%E5%86%99%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/</guid><description>这次用 tree-sitter 写一个简单的代码高亮。
前言 我寻思代码高亮是什么应该没啥可解释的，也有叫“语法高亮”，总之都是一个意思。就是给编辑器里的代码涂上颜色，便于阅读。
一般来说，简单的代码高亮只需要正则表达式就能搞定（比如说关键字高亮，Camel Case 标识符高亮等），不过正则表达式来实现高亮还是有很大的局限性。
举例来说，当我把函数当参数传给另一个函数的时候——
function f() {} function higher(fn) { return () =&amp;gt; fn() != 0; } higher(f); 在 higher(f) 这一行中的 f 不会以函数名的颜色标出。这就引出了一种新基于语义的代码高亮，让编辑器真正“认识”你的代码，并提供更聪明的提示。
开始 还是在 vscode 折腾。
先创建一个 vscode 插件项目，用 yo code 完成。
然后编辑 package.json ，添加你的语言和插件的激活事件。
{ &amp;#34;activationEvents&amp;#34;: [&amp;#34;onLanguage:proto&amp;#34;], &amp;#34;contributes&amp;#34;: { &amp;#34;languages&amp;#34;: [ { &amp;#34;id&amp;#34;: &amp;#34;proto&amp;#34;, &amp;#34;extensions&amp;#34;: [&amp;#34;.proto&amp;#34;] } ] } } 然后修改 src/extension.ts，去掉默认创建的 hello world 代码，留一个 console.log，然后 F5 启动，打开一个 .proto 文件，检查插件是否已经激活。
// The module &amp;#39;vscode&amp;#39; contains the VS Code extensibility API // Import the module and reference it with the alias vscode in your code below import * as vscode from &amp;#34;vscode&amp;#34;; // this method is called when your extension is activated // your extension is activated the very first time the command is executed export function activate(context: vscode.</description></item><item><title>玩玩 tree-sitter</title><link>https://nnnewb.github.io/blog/p/%E7%8E%A9%E7%8E%A9-tree-sitter/</link><pubDate>Thu, 29 Jul 2021 10:14:36 +0000</pubDate><guid>https://nnnewb.github.io/blog/p/%E7%8E%A9%E7%8E%A9-tree-sitter/</guid><description>什么是tree-sitter呢？
tree-sitter 是一个 parser-generator，也是一个增量解析库（incremental parsing library）。它可以为源文件构建完整的语法树，并在源文件被编辑时高效地更新。
快速开始 tree-sitter 本身是一个 parser generator ，使用 javascript 来作为描述语法规则的语言（不像其他，如 yacc 一类的工具，以类似 EBNF 的 DSL 来描述语法规则）。
我们写 tree-sitter 语法规则本质上是类似于写一个 tree-sitter 的语法支持包，可以参考下 tree-sitter/tree-sitter-go: Go grammar for tree-sitter (github.com) 的项目结构。
废话不多说，先写个简单的 demo 跑起来。
mkdir tree-sitter-hello &amp;amp;&amp;amp; cd tree-sitter-hello npm init npm i --save nan npm i --save-dev tree-sitter-cli 初始化好项目目录，在 package.json 里写个简单的命令，方便之后用。
{ &amp;#34;scripts&amp;#34;:{ &amp;#34;test&amp;#34;: &amp;#34;tree-sitter generate &amp;amp;&amp;amp; tree-sitter parse test.txt&amp;#34; } } 现在开始干正事儿，创建一个 grammar.js
module.exports = grammar({ name: &amp;#39;hello&amp;#39;, rules: { source_file: $ =&amp;gt; repeat($.</description></item></channel></rss>