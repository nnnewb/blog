<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/tags/go/</link><description>Recent content in go on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 16 Dec 2021 15:00:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>XA 事务从理论到实践</title><link>https://nnnewb.github.io/blog/p/xa-transaction-theory-to-practice/</link><pubDate>Thu, 16 Dec 2021 15:00:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/xa-transaction-theory-to-practice/</guid><description>前言 有言道，纸上得来终觉浅，绝知此事要躬行。分布式事务的具体方案，看几篇文章就基本有了概念，但实际应用的机会很少。这不有点闲暇，就试试看把理论化作代码，在实践中检验。
#1 案例设计 采用分布式事务经典的转账案例：用户从银行A转账到银行B，银行A扣除余额，银行B增加余额。
XA事务官方规范文档给出的示意图如下。
事务模型
用 XA 事务描述，用户的转账操作发生在AP，AP调用TM注册全局事务后，调用银行A（RM）完成扣款（PREPARE），调用银行B（RM）完成增加余额（PREPARE），然后调用TM提交全局事务，TM回调银行A和B提交本地事务。
图示如下。
xa事务时序图
上面的时序图是读了 github.com/yedf/dtm 代码后胡乱分析出来的，图略去了错误处理的部分。根据这个时序图可以做出一个简单的服务划分设计。
案例服务划分
为了更好地观察服务的交互情况，引入了 Jaeger ，如果是为了简化整个案例代码考虑也可以不要。但大部分时候 Jaeger 应该是没什么存在感的。
nginx 反向代理将 AP 的接口还有 Bank1/Bank2的接口导出给用户访问，实际上案例中没有需要访问 Bank1/Bank2 接口的情况，所以 去掉 nginx 反向代理应该也没什么大关系。
#2 技术栈 所有服务使用docker-compose部署，kubernetes也没问题。
MySQL使用5.7版本，jaeger和nginx最新稳定版。AP/Bank服务都使用 Go 语言编写， 使用 Gin 作为 HTTP 服务框架，OpenTelemetry 跟踪，sqlx 做 ORM。
#3 接口设计 接口url设计有参考 Google APIs 规范，但并不是硬套 RESTful 。
AP服务提供接口
/v1alpha1/transfer 转账接口 Bank服务提供接口
/v1alpha1/trans_in 余额转入 /v1alpha1/trans_out 余额转出 /v1alpha1/tm_callback 事务回调，当AP提交事务或者回滚时，TM回调这个接口并告知需要提交还是回滚 TM服务提供接口</description></item></channel></rss>