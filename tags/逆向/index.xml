<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>逆向 on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/tags/%E9%80%86%E5%90%91/</link><description>Recent content in 逆向 on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 14 Oct 2021 16:31:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/tags/%E9%80%86%E5%90%91/index.xml" rel="self" type="application/rss+xml"/><item><title>关于在内存里找kernel32这件事</title><link>https://nnnewb.github.io/blog/p/find-kernel32-in-memory/</link><pubDate>Thu, 14 Oct 2021 16:31:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/find-kernel32-in-memory/</guid><description>前言 总得有个前言。
用 nasm 手工打造了一个 PE 文件后，这个 PE 文件还没什么卵用。如果要动 IAT，又嫌麻烦。网上冲浪找到一篇关于 shellcode 的文章，讲如何在内存里找到 kernel32.dll 并调用 WinExec 函数，于是就想实践一下看看，实际抄代码碰到不少坑。对汇编又熟悉了一点。
0x01 寻找 kernel32 微软有一篇很简短的文章。
The Thread Environment Block (TEB structure) holds context information for a thread.
In the following versions of Windows, the offset of the 32-bit TEB address within the 64-bit TEB is 0. This can be used to directly access the 32-bit TEB of a WOW64 thread. This might change in later versions of Windows</description></item><item><title>nasm汇编手写个PE可执行文件</title><link>https://nnnewb.github.io/blog/p/hand-write-pe-file-with-nasm-assembly/</link><pubDate>Wed, 13 Oct 2021 11:05:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/hand-write-pe-file-with-nasm-assembly/</guid><description>前言 主要是虽然有个汇编器 nasm 但是不知道怎么用，啥汇编都是调试器里纸上谈兵。最近碰到个问题，MinGW 可以用参数 -Wl,section-start= 来修改 section 地址，但 msvc 没有对应物，就蛋疼。手动改 PE 来添加 section 好像可行，但不知道该怎么做，lief 也不熟悉。
正好瞎谷歌的时候发现 nasm 可以直接编译出 PE 文件，这就听起来很有意思了。汇编嘛，听着就很底层，很自由，改个 Section 地址不是手到擒来。于是就学学看。
参考文章附于文末。
0x01 nasm 基本用法 1.1 label 汇编当然有经典的 label 和 instruction 了，instruction 的参数就叫 operand 。
nasm 的 label 语法很简单，任何不是宏和 instruction 或者伪指令的东西，出现在行首，都会被认作 label。
lbl1: ; 这是label sub esp, 4h jmp lbl lbl2 ; 这也是 label sub esp, 4h lbl3 db 1 ; 这还是 label .label4 ; 这是本地 label，可以用 .</description></item><item><title>加壳原理02 - 简单加壳机</title><link>https://nnnewb.github.io/blog/p/learning-packer-02/</link><pubDate>Tue, 28 Sep 2021 16:57:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-02/</guid><description>前言 对 Windows 程序的加载和运行过程有了基本了解后，手动加载并运行一个PE文件并不成问题。加壳仅仅是在这上面更进一步：把加载程序和被加载的程序合并成一个文件。
这么说可能有点太简单化，大部分的工作其实就在这儿：如何处理被加载的程序？压缩？加密？混淆？加载器（或者叫壳程序）如何反调试？
这里先写一个简单的加壳机，仅仅是把被加载的PE文件作为一个 Section，添加到壳程序里，让壳程序直接从这个 Section 加载并运行。
0x01 壳程序 1.1 思路 和加载一个PE文件不同，既然被加载的程序就在 Section 里，那需要做的只有定位到 Section，然后把 Section 内容当读取进内存的 PE 文件内容处理就好了。
壳程序应该尽量保持轻量，不在原始程序上添加太多东西（加完壳大小翻一倍还多了一堆DLL依赖那谁受得了啊），所以很多标准C库的函数也不能用了，像是memcpy、strcmp 都要自己简单实现一个。
1.2 壳实现 绝大部分内容和之前文章中的 load_PE 一致，入口点修改为 _start，需要注意。
#include &amp;lt;Windows.h&amp;gt;#include &amp;lt;winnt.h&amp;gt; void *load_PE(char *PE_data); void fix_iat(char *p_image_base, IMAGE_NT_HEADERS *p_NT_headers); void fix_base_reloc(char *p_image_base, IMAGE_NT_HEADERS *p_NT_headers); int mystrcmp(const char *str1, const char *str2); void mymemcpy(char *dest, const char *src, size_t length); int _start(void) { char *unpacker_VA = (char *)GetModuleHandleA(NULL); IMAGE_DOS_HEADER *p_DOS_header = (IMAGE_DOS_HEADER *)unpacker_VA; IMAGE_NT_HEADERS *p_NT_headers = (IMAGE_NT_HEADERS *)(((char *)unpacker_VA) + p_DOS_header-&amp;gt;e_lfanew); IMAGE_SECTION_HEADER *sections = (IMAGE_SECTION_HEADER *)(p_NT_headers + 1); char *packed = NULL; char packed_section_name[] = &amp;#34;.</description></item><item><title>加壳原理01 - Windows 程序的加载和运行</title><link>https://nnnewb.github.io/blog/p/learning-packer-01-windows-program-load-and-execution/</link><pubDate>Mon, 27 Sep 2021 14:51:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-01-windows-program-load-and-execution/</guid><description>前言 本文由多篇相关文章翻译整合得来，参考文章和书目文末给出。
0x01 PE文件结构 1.1 从 PE-COFF 格式说起 &amp;hellip; 现在PC平台流行的 可执行文件格式（Executable） 主要是 Windows 下的 PE （Portable Executable） 和 Linux 的 ELF （Executable Linkable Format），它们都是 COFF（Common Object File Format）格式的变种。目标文件就是源代码编译后但未进行链接的那些中间文件（Windows 的 .obj 和 Linux 下的 .o），它和可执行文件的内容和结构很相似，所以一般跟可执行文件一起采用一种格式存储。从广义上看，目标文件与可执行文件的格式其实几乎是一样的，所以我们可以广义地将目标文件与可执行文件看成是同一种类型的文件，在 Windows 下，我们可以统称它们为 PE-COFF 文件格式。在 Linux 下，我们可以将它们统称为 ELF 文件。
&amp;hellip; 不光是 可执行文件 （Windows 的 .exe 和 Linux 下的 ELF 可执行文件）按照可执行文件格式存储。动态链接库（DLL，Dynamic Linking Library） （Windows 的 DLL 和 Linux 下的 .so ）以及静态链接库 （Static Linking Library） （Windows 的 .lib 和 Linux 下的 .</description></item><item><title>自娱自乐 crackme-03</title><link>https://nnnewb.github.io/blog/p/crackme-03/</link><pubDate>Fri, 24 Sep 2021 16:58:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/crackme-03/</guid><description>前言 总得有个前言。
一直玩命令行 crackme 看着就没啥意思，来点带界面的。依然是学习用，目标是把汇编和底层和内存这套东西读熟。这次是用 wxwidgets 做的简单 crackme，为了在 CrackME-02 基础上再增加点难度但又不至于太难，这次是 OTP 生成序列号，要求解出生成 OTP 的 SECRET。
源码 越来越长了，贴上来没法看。现在托管到GitHub，包括前面的两个cm。
前两个cm托管的代码编译参数有一点修改，可能造成结果和文章不一致，但大体是一样的，别在意。
源码托管地址：github.com/nnnewb/crackmes
挑战一下C++代码开启优化的Hard模式。
观察 一个输入框，点击try it尝试。失败时提示Wrong，没有别的信息。
静态分析 老规矩先静态分析一波，粗略扫一眼，捋一捋逻辑。用你喜欢的反汇编工具打开，我用Cutter先试试。
因为是GUI程序，直接跳main肯定是不行的。Win32 GUI程序的入口点（程序员视角）在WinMain这个特殊函数，不过真拿Win32API手撸界面我是真没见过了，Win32 GUI程序设计也是玩的事件响应，找到主函数的意义不大。
所以找关键跳这一步只能是从数据段找字符串查引用，或者调试器下合适的访问断点了。
这里直接从数据段找到了字符串，定位到弹出错误对话框的逻辑。
这里有个姿势点是__thiscall，这是个微软自定义的调用约定，点这里看微软的文档。
__thiscall __thiscall的特点是被调用方清栈，this指针通过ecx寄存器传递，其他参数右至左压栈。对于可变长度参数（VAARG）的成员函数会特殊处理，采用cdecl调用约定，this指针最后压栈。
这里简单读一下定位到的几句代码，分析下意图。
0x004064dc 68 34 e8 40 00 push str.Try_again ; 0x40e834 0x004064e1 8d 4d d0 lea ecx, [ebp - 0x30] 0x004064e4 ff 15 e0 33 41 00 call dword [public: void __thiscall wxString::constructor(char const *)] ; 0x4133e0 0x004064ea 68 44 e8 40 00 push str.</description></item><item><title>自娱自乐 crackme-02</title><link>https://nnnewb.github.io/blog/p/crackme-02/</link><pubDate>Wed, 15 Sep 2021 15:43:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/crackme-02/</guid><description>得有个前言 总之上一个 crackme-01 还过得去，稍微加强一点，把密码隐藏起来，不要随便被看到。
0x01 源码 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt; size_t getline(char **lineptr, size_t *n, FILE *stream) { char *bufptr = NULL; char *p = bufptr; size_t size; int c; if (lineptr == NULL) { return -1; } if (stream == NULL) { return -1; } if (n == NULL) { return -1; } bufptr = *lineptr; size = *n; c = fgetc(stream); if (c == EOF) { return -1; } if (bufptr == NULL) { bufptr = malloc(128); if (bufptr == NULL) { return -1; } size = 128; } p = bufptr; while (c !</description></item><item><title>自娱自乐 CrackMe-1</title><link>https://nnnewb.github.io/blog/p/crackme-01/</link><pubDate>Fri, 10 Sep 2021 09:49:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/crackme-01/</guid><description>前言 总之得有个前言。从前有个老和尚（不是，掉光了头发的攻城狮），&amp;hellip;&amp;hellip;
以上略，于是作为萌新含量110%的萌新，出于练手、熟悉下反汇编调试的环境之类的目的，还是自己写crackme来把玩吧。
CM01 介绍 于是这个 CrackMe 就叫 CM01 好了，命令行无界面。适合差不多对这些东西懂个大概或者打算学习的萌新：
反汇编/调试工具 寄存器（主要是 ebp、esp、eip、eax） 函数调用（cdecl） 栈/栈帧 内存模型和寻址 CM01 源码 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt; size_t getline(char **lineptr, size_t *n, FILE *stream) { char *bufptr = NULL; char *p = bufptr; size_t size; int c; if (lineptr == NULL) { return -1; } if (stream == NULL) { return -1; } if (n == NULL) { return -1; } bufptr = *lineptr; size = *n; c = fgetc(stream); if (c == EOF) { return -1; } if (bufptr == NULL) { bufptr = malloc(128); if (bufptr == NULL) { return -1; } size = 128; } p = bufptr; while (c !</description></item><item><title>32位 Windows x86 汇编语言学习</title><link>https://nnnewb.github.io/blog/p/assembly-learning-note/</link><pubDate>Thu, 09 Sep 2021 16:14:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/assembly-learning-note/</guid><description>前言 最近迷上了 Crack Me，入门无果。老是看到有大佬发52pojie又有哪个佬把什么黄油给手撕了，心痒痒。干脆也正正经经地去学一下好了。
这当然也算是程序员本职的正经知识（心虚而且超大声）。
常规知识和速记 笔记内容是关于 8086/x86 汇编。
x86体系结构下内存和寄存器都是小端序。小端序指低位在右，高位在左。如0x1的小端序表示是0000 0001。
8比特能表示2位16进制数（0xFF，也就是255），16比特能表示4位16进制数（0xFFFF，65535），32比特能表示8位16进制数（0XFFFFFFFF，4294967295）。
数据类型：
助记符 描述 dword 双字（double word），32比特整型数据。 word 字，16比特整型数据。 byte 字节，8比特整型数据。 常用的16进制数记法：
0x2A，前缀0x 2AH，后缀H 寄存器 通用寄存器 参考：x86汇编 - 维基百科
参考：x64体系结构 - windows hardware
64位寄存器 32位寄存器 16位寄存器 8位寄存器 用途 RAX或R0 EAX AX AL和AH Accumlator，累加寄存器，用于算术运算。 RBX或R3 EBX BX BL和BH Base，基址寄存器，指向数据块基址（段模式存于段寄存器DS） RCX或R1 ECX CX CL和CH Counter，用于用于移/环指令及循环（没懂）。 RDX或R2 EDX DX DL和DH Data，用于数学运算和IO操作。 RSI或R6 ESI SI SIL Source Index，指向指令流操作中的源。 RDI或R7 EDI DI DIL Destination Index，指向指令流操作中的目标。 RBP或R5 EBP BP BPL Stack Base Pointer，指向栈的基地址。 RSP或R4 ESP SP SPL Stack Pointer，指向栈顶的地址。 R8 R8D R8W R8B 无别名。 R9 R9D R9W R9B 无别名。 R10 R10D R10W R10B 无别名。 R11 R11D R11W R11B 无别名。 R12 R12D R12W R12B 无别名。 R13 R13D R13W R13B 无别名。 R14 R14D R14W R14B 无别名。 R15 R15D R15W R15B 无别名。 后续还是用 32 位寄存器的名字称呼这些寄存器。</description></item><item><title>一个安卓应用的逆向分析</title><link>https://nnnewb.github.io/blog/p/%E4%B8%80%E4%B8%AA%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</link><pubDate>Tue, 29 Dec 2020 14:04:02 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E4%B8%80%E4%B8%AA%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</guid><description>说起来也不算什么新鲜的东西，现成的工具拼拼凑凑就搞定了，单纯算是点亮了新的技能。
待破解应用的名字不透露了，避免引火烧身。
需要准备的工具包括
mumu 模拟器(或者别的什么有 root 权限、能装 xposed 的模拟器) FDex2 脱壳 jadx 反编译 dex 源码 apktools 拆解 apk mitmproxy 中间人拦截网络请求 0x01 目标和方向选择 首要的目标是破解这个软件的 api 加密。
使用 mitmproxy 抓到 https 流量，发现请求体全部是 base64 ，解码发现乱码。基本断定是加密了。
mitmproxy 怎么抓 https 流量不多说了，基本流程就是装证书，然后配置代理。能看到有流量进 mitmproxy 就算成功了。
直接参考 mitmproxy 的文档快一点。
搜了一圈没有什么现成的对这个 App 的破解的文章，于是决定自己动手。
0x02 解包和脱壳 先确认下电脑上装了 JDK 或者 JRE ，没有的话就装好。
推荐一个 vscode 的插件，apklab。会帮你装好 jadx 和 apktools / signer 这些工具。
接下来直接用 apklab 打开需要破解的 apk 文件。
apklab 会自动用 apktools 和 jadx 完成拆包和反编译。</description></item></channel></rss>