<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>逆向 on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/tags/%E9%80%86%E5%90%91/</link><description>Recent content in 逆向 on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 09 Sep 2021 16:14:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/tags/%E9%80%86%E5%90%91/index.xml" rel="self" type="application/rss+xml"/><item><title>32位 Windows x86 汇编语言学习</title><link>https://nnnewb.github.io/blog/p/assembly-learning-note/</link><pubDate>Thu, 09 Sep 2021 16:14:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/assembly-learning-note/</guid><description>前言 最近迷上了 Crack Me，入门无果。老是看到有大佬发52pojie又有哪个佬把什么黄油给手撕了，心痒痒。干脆也正正经经地去学一下好了。
这当然也算是程序员本职的正经知识（心虚而且超大声）。
常规知识和速记 笔记内容是关于 8086/x86 汇编。
x86体系结构下内存和寄存器都是小端序。小端序指低位在右，高位在左。如0x1的小端序表示是0000 0001。
8比特能表示2位16进制数（0xFF，也就是255），16比特能表示4位16进制数（0xFFFF，65535），32比特能表示8位16进制数（0XFFFFFFFF，4294967295）。
数据类型：
助记符 描述 dword 双字（double word），32比特整型数据。 word 字，16比特整型数据。 byte 字节，8比特整型数据。 常用的16进制数记法：
0x2A，前缀0x 2AH，后缀H 寄存器 通用寄存器 参考：x86汇编 - 维基百科
参考：x64体系结构 - windows hardware
64位寄存器 32位寄存器 16位寄存器 8位寄存器 用途 RAX或R0 EAX AX AL和AH Accumlator，累加寄存器，用于算术运算。 RBX或R3 EBX BX BL和BH Base，基址寄存器，指向数据块基址（段模式存于段寄存器DS） RCX或R1 ECX CX CL和CH Counter，用于用于移/环指令及循环（没懂）。 RDX或R2 EDX DX DL和DH Data，用于数学运算和IO操作。 RSI或R6 ESI SI SIL Source Index，指向指令流操作中的源。 RDI或R7 EDI DI DIL Destination Index，指向指令流操作中的目标。 RBP或R5 EBP BP BPL Stack Base Pointer，指向栈的基地址。 RSP或R4 ESP SP SPL Stack Pointer，指向栈顶的地址。 R8 R8D R8W R8B 无别名。 R9 R9D R9W R9B 无别名。 R10 R10D R10W R10B 无别名。 R11 R11D R11W R11B 无别名。 R12 R12D R12W R12B 无别名。 R13 R13D R13W R13B 无别名。 R14 R14D R14W R14B 无别名。 R15 R15D R15W R15B 无别名。 后续还是用 32 位寄存器的名字称呼这些寄存器。</description></item><item><title>一个安卓应用的逆向分析</title><link>https://nnnewb.github.io/blog/p/%E4%B8%80%E4%B8%AA%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</link><pubDate>Tue, 29 Dec 2020 14:04:02 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E4%B8%80%E4%B8%AA%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</guid><description>说起来也不算什么新鲜的东西，现成的工具拼拼凑凑就搞定了，单纯算是点亮了新的技能。
待破解应用的名字不透露了，避免引火烧身。
需要准备的工具包括
mumu 模拟器(或者别的什么有 root 权限、能装 xposed 的模拟器) FDex2 脱壳 jadx 反编译 dex 源码 apktools 拆解 apk mitmproxy 中间人拦截网络请求 0x01 目标和方向选择 首要的目标是破解这个软件的 api 加密。
使用 mitmproxy 抓到 https 流量，发现请求体全部是 base64 ，解码发现乱码。基本断定是加密了。
mitmproxy 怎么抓 https 流量不多说了，基本流程就是装证书，然后配置代理。能看到有流量进 mitmproxy 就算成功了。
直接参考 mitmproxy 的文档快一点。
搜了一圈没有什么现成的对这个 App 的破解的文章，于是决定自己动手。
0x02 解包和脱壳 先确认下电脑上装了 JDK 或者 JRE ，没有的话就装好。
推荐一个 vscode 的插件，apklab。会帮你装好 jadx 和 apktools / signer 这些工具。
接下来直接用 apklab 打开需要破解的 apk 文件。
apklab 会自动用 apktools 和 jadx 完成拆包和反编译。</description></item></channel></rss>