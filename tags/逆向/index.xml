<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>逆向 on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/tags/%E9%80%86%E5%90%91/</link><description>Recent content in 逆向 on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 03 Nov 2021 16:54:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/tags/%E9%80%86%E5%90%91/index.xml" rel="self" type="application/rss+xml"/><item><title>加壳原理08：混淆技术入门</title><link>https://nnnewb.github.io/blog/p/learning-packer-08/</link><pubDate>Wed, 03 Nov 2021 16:54:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-08/</guid><description>前言 本篇尝试学习通过动手写一个 LLVM Pass 来学习编译阶段进行代码混淆的技术。
0x01 环境设置 LLVM 是个相当大的项目，做好环境设置是首先要做的事情。这里选择 msys2 作为首要开发环境，不然光是 MSVC 把 LLVM 源码编译一遍就够呛了。
安装好MSYS2之后安装 clang 工具链（2021年11月3日，clang32工具链默认不在msys2的源里，需要手动改 pacman.conf 加入 clang32 源，这里以 x86_64 的 LLVM 工具链进行实践）。
pacman -Sy mingw-w64-clang-x86_64-toolchain 完成后添加环境变量，把 msys2 安装目录下的 clang64/bin 加入环境变量，方便 VSCode + CMake 找到工具链。另外注意装一个 Ninja，同样加入 Path。
VSCode 里装上微软的 C/C++ 和 clangd，禁用微软 C/C++ 的 Intellisense，实在太慢。
手动编译整个LLVM源码树实在是太费时间了，我选择用MSYS2的工具链。参考这篇文档去配置一个 LLVM 源码树外的 Pass 工程：CMake out of source pass - LLVM 。写一个简单的 CMakeLists.txt ，跟着 Writing an LLVM Pass - LLVM 这篇文档快速实现一个遍历函数的 Pass 。</description></item><item><title>加壳原理07 - 花指令入门</title><link>https://nnnewb.github.io/blog/p/learning-packer-07/</link><pubDate>Sun, 31 Oct 2021 17:14:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-07/</guid><description>前言 个人浅见，一般分析一个程序可以有动态和静态两条路，动态一般指的就是调试或者别的运行时跟踪程序行为的方式了，除了调试器外就是抓取事件、日志、API调用记录、看内存数据等，比如有 Frida，还有内存搜索如CE。静态则是用各种工具在不实际运行程序的前提下，从程序文件里提取有用的信息。
对于运行时的对抗手段很多，毕竟程序都跑起来了，你来我往打擂台嘛。而且在Windows这个闭源平台上，还可以靠不大可能被动手脚的内核来保护自己，Linux上就可能内核都是被魔改过的。
但是对静态分析就没有什么特别好的办法，又要人造的计算机能正确运行，又要人不能理解，就有点矛盾。
广为人知的对抗静态分析的手段有这些：
混淆，把程序逻辑转换成更晦涩但等价的形式。 加花，对抗反汇编引擎，利用反汇编工具的算法缺陷、漏洞来迫使分析者必须花费大量时间处理错误的反汇编结果，让诸如控制流视图之类的工具失效。 混淆和加花的主要区别 在我这 定义为 混淆是变换原程序逻辑，花指令不改变原程序逻辑 。
这些对抗手段主要的目的都是 消磨耐心 和 拖延时间 ，抬高人肉分析的成本。但混淆加花这种手段是无法做到只让机器读懂代码而人读不懂这种效果的。这个结论忘了是哪篇论文里提到的了。
本篇只讲如何对抗反汇编，也就是花指令技术。
0x01 花指令原理 1.1 机器码指令格式 码农日常工作接触的是高级语言（这个概念可能有争议，反正相对汇编、机器码这个层级来说都是高级语言就对了），汇编和机器码这种满是历史尘埃的领域是绝无机会接触的。但要理解花指令，首先要理解汇编代码的二进制表示，才会明白为什么反汇编工具的力量是有极限的。
zHClf
这是 Intel 的 64-ia-32-architectures-software-developer-instruction-set-reference-manual 里的一张图，说明了汇编指令如何以二进制形式保存。可以简单看成3部分，1字节的可选前缀，1-3字节的opcode部分，剩余描述操作数的部分。
几个要素：
指令长度不固定，最短 1 字节，最长可能有 14 （图中全部相加，实际会不会有我就不知道了）。 一条汇编代码里的指令可能对应很多不同的 opcode ，简单到 add 这样的指令也会有很多种不同形式。 熟悉机器码格式在自己构造花指令的时候大概会有用，但实话说 Intel 这手册看得我头痛。所以还是直接快进到花指令原理。
1.2 花指令原理 花指令的英文是 junk code ，也就是垃圾代码。实际上花指令的确是一些不影响程序逻辑的 垃圾 机器码，它存在的唯一意义就是干扰反汇编引擎和人肉分析。
花指令有两种类型：
不可执行的花指令 可执行的花指令 听起来像是废话但实际上构造这两种花指令的难度是完全不一样的。
对于不可执行的花指令，本质上我们做的事情是在跳转指令之后插入一个多字节指令的字节，欺骗反汇编器将这个字节之后的几个字节当成一个多字节指令解释，进而造成后续指令反汇编出错。
而可执行的花指令，本质是将指令的组成部分重新解释执行。像是一个2字节的跳转指令，第二个字节是操作数，但操作数可以是 0xff，也就是带符号的 -1，使 EIP 落在 0xff 这个字节上，将0xff作为指令继续执行。这个过程中0xff既可以被当成数字0xff解释，也被当成了指令来解释。</description></item><item><title>加壳原理06：反调试技术入门</title><link>https://nnnewb.github.io/blog/p/learning-packer-06/</link><pubDate>Wed, 27 Oct 2021 19:50:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-06/</guid><description>前言 反调试技术，往大了说是用尽一切手段防止运行时对程序的非法篡改和窥视，往小了说就是防调试器。反正反调试这件事和各种技术都能搭点边，什么HOOK啦DLL注入啦。真要给涉及到的各方面都说得头头是道，那我这个菜鸡就不叫菜鸡了。
反正涉及的各种技术细节吧，将来都会慢慢学到的。也不急于一时。本篇关注的重点还是在导，引入，了解个大概。看看有什么反调试思路，对付这些反调试技术又有什么 bypass 的手段。
说这么多，其实还是找了篇写得不错的外文文章，抄了然后调试了下案例。
0x01 反调试思路 首先概述一下本篇主要的反调试思路。
1.1 系统API或数据结构 操作系统提供了一些调试标志位，调试器启动的进程会有标识。调试器也可能会为了提供更好的调试体验，修改一些参数，让我们有迹可循。
PEB-&amp;gt;BeingDebugged和IsDebuggerPresent PEB-&amp;gt;NtGlobalFlag PEB-&amp;gt;HEAP-&amp;gt;Flags和PEB-&amp;gt;HEAP-&amp;gt;ForceFlags CheckRemoteDebuggerPresent NtQueryInformationProcess ProcessDebugPort ProcessDebugObjectHandle ProcessDebugFlags ProcessBasicInformation NtSetInformationThread和NtCreateThreadEx 利用 HideFromDebugger 标志位来对调试器隐藏自身。 1.2 SEH、VEH 总的来说，利用 SEH 和 VEH 机制，尝试抛出一些会被调试器处理的中断或异常，同时自己挂一个处理函数，如果异常被调试器捕获了，那自己挂的异常处理函数就不会被调用，借此判断是否有调试器正在调试程序。
TF标志位和INT 1中断 INT 3 中断和 SEH 处理函数，__try __except 或 MinGW 的 __try1 __except1，顺便一提我的SEH实验没成功。但是 VEH 基本没问题。 DBG_PRINTEXCEPTION_WIDE_C和DBG_PRINTEXCEPTION_W，Windows 10 OutputDebugString 利用了这个 Exception 来抛出调试字符串。 EXCEPTION_INVALID_HANDLE 1.3 调试寄存器 GetThreadContext 获取当前上下文，判断 Dr0-Dr3寄存器的值。
1.4 完整性校验 原理是调试器通过临时修改断点处指令为中断来取得程序控制权，可以用CRC校验，或者更简单点，直接逐字节求和，判断代码是否被篡改。</description></item><item><title>加壳原理05：利用图片隐藏</title><link>https://nnnewb.github.io/blog/p/learning-packer-05/</link><pubDate>Thu, 21 Oct 2021 21:17:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-05/</guid><description>前言 完成了简单的压缩壳之后放松下，在52论坛病毒分析区看到过几次把代码隐藏到图片里的做法，也看到过把程序转成图片后训练神经网络来判断有没有恶意的，于是就想，淦，这不是挺好玩的嘛。
0x01 思路 用图片保存程序最简单的做法就是直接把程序每个字节都转成像素，然后输出成灰度图。比较进阶的做法就像是二维码了，大色块，容错校验，图片被压到包浆也能扫出来。但那个有点点难（我菜）最终成果也大到不现实，而且实话说打包到程序里就不用考虑被二次压缩的情况了。所以简单的8bit灰度图就刑。
说到位图肯定有人想到了 BMP ，我记得上学那会儿还跟着网上哪儿找的教程，学着用 ffmpeg 把 Bad Apple 转成位图序列，再转成字符图合并成 HTML，用 js 播放。说起来都是泪。
现在已经成了正经的码农，再折腾 BMP 就没意思了，PNG 就挺好的。
图片可以放到 Section 里——但并没有意义，所以我选择放到资源里。写一个 .rc 文件用 windres 编译出目标文件，再拿 gcc 链接就行了。如此一来并没有 lief 出场的机会，编译好的加载器就是加完壳的程序。
加载器则采用开启 ASLR 的模式，这样程序的节表会比较干净，没有明显特征（虽然也没什么卵用）。
0x02 加载器 2.1 资源介绍 参考微软的文档 Using Resources、Menu and Other Resources。
A resource is binary data that you can add to the executable file of a Windows-based application. A resource can be either standard or defined. The data in a standard resource describes an icon, cursor, menu, dialog box, bitmap, enhanced metafile, font, accelerator table, message-table entry, string-table entry, or version information.</description></item><item><title>加壳原理04 - zlib压缩壳案例</title><link>https://nnnewb.github.io/blog/p/learning-packer-04-zlib-compression-packer-demo/</link><pubDate>Wed, 20 Oct 2021 16:07:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-04-zlib-compression-packer-demo/</guid><description>前言 本文在前一篇基础上，写一个使用 zlib 的压缩壳案例。
0x01 zlib 解压 1.1 概述 关于 zlib 的用法找了这些参考资料：
zlib.net/zpipe.c zlib Usage Example Compress and Decompress a string with zlib 尝试了 zlib、lzo、Windows Compression API，对压缩和解压 API 的基本模式的基本认识大概是这样：
首先，你得有被压缩数据的大小（要么分块压缩，要么有整个压缩后的大小） 然后得有解压后的预期大小，这个能通过 尝试解压 的操作来实现。比如 Windows Compression API 和 lzo 都可以在解压 buffer 传 NULL，尝试取得解压后的大小，再分配好内存解压。 zlib 这样的流式压缩、解压处理文件比较友好，但全程在内存里进行的话，流式解压就会导致大量内存分配 =。= 除非一开始就分配足够的空间，不然一个一个内存块申请和合并会很蛋疼。 1.2 内存布局 压缩后的 .packed 节在头部留出 8 个字节，分别保存压缩后大小和压缩前大小，以便一次分配好内存完成解压。
偏移 大小 内容 0 DWORD 小端序，压缩后大小 4 DWORD 小端序，压缩前大小 8 可变 压缩后的数据 1.</description></item><item><title>加壳原理03 - 支持没有重定位的程序</title><link>https://nnnewb.github.io/blog/p/learning-packer-03-support-no-relocations/</link><pubDate>Wed, 20 Oct 2021 10:25:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-03-support-no-relocations/</guid><description>前言 距离上一篇加壳原理已经过去挺久了，这段时间稍微折腾了一下 nasm，尝试手工制作了 PE32 文件，积累了一些基本的知识吧。
所以现在继续学习加壳——如何对不支持 ASLR 的 PE32 程序进行加壳？
0x01 关于ASLR ASLR是一项内存保护技术，用于防范内存损坏漏洞，比如缓冲区溢出。需要注意的是 ASLR 并不是 解决 了相关威胁，而是让利用相关的漏洞变得更加困难和具有挑战性。
ASLR 的全名是 Address Space Layout Randomization ，地址空间布局随机化技术。一个典型的 PE32 程序在没有 ASLR 支持的情况下， 地址空间布局是确定的：程序镜像总会加载到固定的地址。这个地址会在文件头里指定。攻击者可以利用这一特点来构造恶意数据，让存在内存损坏漏洞的程序按攻击者意图跳过或执行特定逻辑，造成安全威胁。
对应 ASLR 的地址空间布局随机化，程序需要再次编译来支持重定位 Relocation ，别无他法（大概）。
0x02 思路 对于加壳一个没有重定位，不支持 ASLR 的 PE32 程序，假设这个程序的基址是 0x04000000，原先的 VirtualAlloc 方式分配内存是行不通的。加壳后程序若开启 ASLR，则 0x04000000 可能已经存在其他模块，并不能保证这个基址可用。所以加壳后的程序必须也使用 0x04000000 这个基址，而且标记为不支持 ASLR，避免基址已经被其他模块使用造成加载器无法工作。
将加壳后程序的基址设置为固定的 0x04000000 又会产生新的问题：加载器的代码段不能放在 0x04000000 ，否则加载器运行时就会出现被被加载的代码覆盖的情况，导致程序跑飞。所以编译后的加载器所有 Section 都必须有一定的偏移，这个偏移值就是被加载程序的 Section 大小之和（对齐后）。而因此多出来的空间单独分成一个 Section ，正好用来放要加载的程序。
另外，还必须确认文件头大小是否一致，因为我们需要将被加载程序的文件头覆盖加载器的文件头。而最开始预留的空间必须分配为一个 Section，让 Windows 的加载器能顺利加载程序而不报“不是有效的Win32程序”错误。
内存布局示意图如下：
内存布局
所以加载器的加载步骤如下：</description></item><item><title>关于在内存里找kernel32这件事</title><link>https://nnnewb.github.io/blog/p/find-kernel32-in-memory/</link><pubDate>Thu, 14 Oct 2021 16:31:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/find-kernel32-in-memory/</guid><description>前言 总得有个前言。
用 nasm 手工打造了一个 PE 文件后，这个 PE 文件还没什么卵用。如果要动 IAT，又嫌麻烦。网上冲浪找到一篇关于 shellcode 的文章，讲如何在内存里找到 kernel32.dll 并调用 WinExec 函数，于是就想实践一下看看，实际抄代码碰到不少坑。对汇编又熟悉了一点。
0x01 寻找 kernel32 微软有一篇很简短的文章。
The Thread Environment Block (TEB structure) holds context information for a thread.
In the following versions of Windows, the offset of the 32-bit TEB address within the 64-bit TEB is 0. This can be used to directly access the 32-bit TEB of a WOW64 thread. This might change in later versions of Windows</description></item><item><title>nasm汇编手写个PE可执行文件</title><link>https://nnnewb.github.io/blog/p/hand-write-pe-file-with-nasm-assembly/</link><pubDate>Wed, 13 Oct 2021 11:05:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/hand-write-pe-file-with-nasm-assembly/</guid><description>前言 主要是虽然有个汇编器 nasm 但是不知道怎么用，啥汇编都是调试器里纸上谈兵。最近碰到个问题，MinGW 可以用参数 -Wl,section-start= 来修改 section 地址，但 msvc 没有对应物，就蛋疼。手动改 PE 来添加 section 好像可行，但不知道该怎么做，lief 也不熟悉。
正好瞎谷歌的时候发现 nasm 可以直接编译出 PE 文件，这就听起来很有意思了。汇编嘛，听着就很底层，很自由，改个 Section 地址不是手到擒来。于是就学学看。
参考文章附于文末。
0x01 nasm 基本用法 1.1 label 汇编当然有经典的 label 和 instruction 了，instruction 的参数就叫 operand 。
nasm 的 label 语法很简单，任何不是宏和 instruction 或者伪指令的东西，出现在行首，都会被认作 label。
lbl1: ; 这是label sub esp, 4h jmp lbl lbl2 ; 这也是 label sub esp, 4h lbl3 db 1 ; 这还是 label .label4 ; 这是本地 label，可以用 .</description></item><item><title>加壳原理02 - 简单加壳机</title><link>https://nnnewb.github.io/blog/p/learning-packer-02/</link><pubDate>Tue, 28 Sep 2021 16:57:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-02/</guid><description>前言 对 Windows 程序的加载和运行过程有了基本了解后，手动加载并运行一个PE文件并不成问题。加壳仅仅是在这上面更进一步：把加载程序和被加载的程序合并成一个文件。
这么说可能有点太简单化，大部分的工作其实就在这儿：如何处理被加载的程序？压缩？加密？混淆？加载器（或者叫壳程序）如何反调试？
这里先写一个简单的加壳机，仅仅是把被加载的PE文件作为一个 Section，添加到壳程序里，让壳程序直接从这个 Section 加载并运行。其他花里胡哨的操作都先不整，仅作为证明工作原理的案例。
0x01 壳程序 1.1 思路 和加载一个PE文件不同，既然被加载的程序就在 Section 里，那需要做的只有定位到 Section，然后把 Section 内容当读取进内存的 PE 文件内容处理就好了。
壳程序应该尽量保持轻量，不在原始程序上添加太多东西（加完壳大小翻一倍还多了一堆DLL依赖那谁受得了啊），所以很多标准C库的函数也不能用了，像是memcpy、strcmp 都要自己简单实现一个。
1.2 壳实现 绝大部分内容和之前文章中的 load_PE 一致，入口点修改为 _start，需要注意。
#include &amp;lt;Windows.h&amp;gt;#include &amp;lt;winnt.h&amp;gt; void *load_PE(char *PE_data); void fix_iat(char *p_image_base, IMAGE_NT_HEADERS *p_NT_headers); void fix_base_reloc(char *p_image_base, IMAGE_NT_HEADERS *p_NT_headers); int mystrcmp(const char *str1, const char *str2); void mymemcpy(char *dest, const char *src, size_t length); int _start(void) { char *unpacker_VA = (char *)GetModuleHandleA(NULL); IMAGE_DOS_HEADER *p_DOS_header = (IMAGE_DOS_HEADER *)unpacker_VA; IMAGE_NT_HEADERS *p_NT_headers = (IMAGE_NT_HEADERS *)(((char *)unpacker_VA) + p_DOS_header-&amp;gt;e_lfanew); IMAGE_SECTION_HEADER *sections = (IMAGE_SECTION_HEADER *)(p_NT_headers + 1); char *packed = NULL; char packed_section_name[] = &amp;#34;.</description></item><item><title>加壳原理01 - Windows 程序的加载和运行</title><link>https://nnnewb.github.io/blog/p/learning-packer-01/</link><pubDate>Mon, 27 Sep 2021 14:51:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/learning-packer-01/</guid><description>前言 本文由多篇相关文章翻译整合得来，参考文章和书目文末给出。
0x01 PE文件结构 PE_Format
1.1 从 PE-COFF 格式说起 &amp;hellip; 现在PC平台流行的 可执行文件格式（Executable） 主要是 Windows 下的 PE （Portable Executable） 和 Linux 的 ELF （Executable Linkable Format），它们都是 COFF（Common Object File Format）格式的变种。目标文件就是源代码编译后但未进行链接的那些中间文件（Windows 的 .obj 和 Linux 下的 .o），它和可执行文件的内容和结构很相似，所以一般跟可执行文件一起采用一种格式存储。从广义上看，目标文件与可执行文件的格式其实几乎是一样的，所以我们可以广义地将目标文件与可执行文件看成是同一种类型的文件，在 Windows 下，我们可以统称它们为 PE-COFF 文件格式。在 Linux 下，我们可以将它们统称为 ELF 文件。
&amp;hellip; 不光是 可执行文件 （Windows 的 .exe 和 Linux 下的 ELF 可执行文件）按照可执行文件格式存储。动态链接库（DLL，Dynamic Linking Library） （Windows 的 DLL 和 Linux 下的 .so ）以及静态链接库 （Static Linking Library） （Windows 的 .</description></item><item><title>自娱自乐 crackme-03</title><link>https://nnnewb.github.io/blog/p/crackme-03/</link><pubDate>Fri, 24 Sep 2021 16:58:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/crackme-03/</guid><description>前言 总得有个前言。
一直玩命令行 crackme 看着就没啥意思，来点带界面的。依然是学习用，目标是把汇编和底层和内存这套东西读熟。这次是用 wxwidgets 做的简单 crackme，为了在 CrackME-02 基础上再增加点难度但又不至于太难，这次是 OTP 生成序列号，要求解出生成 OTP 的 SECRET。
源码 越来越长了，贴上来没法看。现在托管到GitHub，包括前面的两个cm。
前两个cm托管的代码编译参数有一点修改，可能造成结果和文章不一致，但大体是一样的，别在意。
源码托管地址：github.com/nnnewb/crackmes
挑战一下C++代码开启优化的Hard模式。
观察 image-20210923104439284
一个输入框，点击try it尝试。失败时提示Wrong，没有别的信息。
静态分析 老规矩先静态分析一波，粗略扫一眼，捋一捋逻辑。用你喜欢的反汇编工具打开，我用Cutter先试试。
因为是GUI程序，直接跳main肯定是不行的。Win32 GUI程序的入口点（程序员视角）在WinMain这个特殊函数，不过真拿Win32API手撸界面我是真没见过了，Win32 GUI程序设计也是玩的事件响应，找到主函数的意义不大。
所以找关键跳这一步只能是从数据段找字符串查引用，或者调试器下合适的访问断点了。
这里直接从数据段找到了字符串，定位到弹出错误对话框的逻辑。
image-20210923105415082
这里有个姿势点是__thiscall，这是个微软自定义的调用约定，点这里看微软的文档。
__thiscall __thiscall的特点是被调用方清栈，this指针通过ecx寄存器传递，其他参数右至左压栈。对于可变长度参数（VAARG）的成员函数会特殊处理，采用cdecl调用约定，this指针最后压栈。
这里简单读一下定位到的几句代码，分析下意图。
0x004064dc 68 34 e8 40 00 push str.Try_again ; 0x40e834 0x004064e1 8d 4d d0 lea ecx, [ebp - 0x30] 0x004064e4 ff 15 e0 33 41 00 call dword [public: void __thiscall wxString::constructor(char const *)] ; 0x4133e0 0x004064ea 68 44 e8 40 00 push str.</description></item><item><title>自娱自乐 crackme-02</title><link>https://nnnewb.github.io/blog/p/crackme-02/</link><pubDate>Wed, 15 Sep 2021 15:43:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/crackme-02/</guid><description>得有个前言 总之上一个 crackme-01 还过得去，稍微加强一点，把密码隐藏起来，不要随便被看到。
0x01 源码 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt; size_t getline(char **lineptr, size_t *n, FILE *stream) { char *bufptr = NULL; char *p = bufptr; size_t size; int c; if (lineptr == NULL) { return -1; } if (stream == NULL) { return -1; } if (n == NULL) { return -1; } bufptr = *lineptr; size = *n; c = fgetc(stream); if (c == EOF) { return -1; } if (bufptr == NULL) { bufptr = malloc(128); if (bufptr == NULL) { return -1; } size = 128; } p = bufptr; while (c !</description></item><item><title>自娱自乐 CrackMe-1</title><link>https://nnnewb.github.io/blog/p/crackme-01/</link><pubDate>Fri, 10 Sep 2021 09:49:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/crackme-01/</guid><description>前言 总之得有个前言。从前有个老和尚（不是，掉光了头发的攻城狮），&amp;hellip;&amp;hellip;
以上略，于是作为萌新含量110%的萌新，出于练手、熟悉下反汇编调试的环境之类的目的，还是自己写crackme来把玩吧。
CM01 介绍 于是这个 CrackMe 就叫 CM01 好了，命令行无界面。适合差不多对这些东西懂个大概或者打算学习的萌新：
反汇编/调试工具 寄存器（主要是 ebp、esp、eip、eax） 函数调用（cdecl） 栈/栈帧 内存模型和寻址 CM01 源码 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt; size_t getline(char **lineptr, size_t *n, FILE *stream) { char *bufptr = NULL; char *p = bufptr; size_t size; int c; if (lineptr == NULL) { return -1; } if (stream == NULL) { return -1; } if (n == NULL) { return -1; } bufptr = *lineptr; size = *n; c = fgetc(stream); if (c == EOF) { return -1; } if (bufptr == NULL) { bufptr = malloc(128); if (bufptr == NULL) { return -1; } size = 128; } p = bufptr; while (c !</description></item><item><title>32位 Windows x86 汇编语言学习</title><link>https://nnnewb.github.io/blog/p/assembly-learning-note/</link><pubDate>Thu, 09 Sep 2021 16:14:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/assembly-learning-note/</guid><description>前言 最近迷上了 Crack Me，入门无果。老是看到有大佬发52pojie又有哪个佬把什么黄油给手撕了，心痒痒。干脆也正正经经地去学一下好了。
这当然也算是程序员本职的正经知识（心虚而且超大声）。
常规知识和速记 笔记内容是关于 8086/x86 汇编。
x86体系结构下内存和寄存器都是小端序。小端序指低位在右，高位在左。如0x1的小端序表示是0000 0001。
8比特能表示2位16进制数（0xFF，也就是255），16比特能表示4位16进制数（0xFFFF，65535），32比特能表示8位16进制数（0XFFFFFFFF，4294967295）。
数据类型：
助记符 描述 dword 双字（double word），32比特整型数据。 word 字，16比特整型数据。 byte 字节，8比特整型数据。 常用的16进制数记法：
0x2A，前缀0x 2AH，后缀H 寄存器 通用寄存器 参考：x86汇编 - 维基百科
参考：x64体系结构 - windows hardware
64位寄存器 32位寄存器 16位寄存器 8位寄存器 用途 RAX或R0 EAX AX AL和AH Accumlator，累加寄存器，用于算术运算。 RBX或R3 EBX BX BL和BH Base，基址寄存器，指向数据块基址（段模式存于段寄存器DS） RCX或R1 ECX CX CL和CH Counter，用于用于移/环指令及循环（没懂）。 RDX或R2 EDX DX DL和DH Data，用于数学运算和IO操作。 RSI或R6 ESI SI SIL Source Index，指向指令流操作中的源。 RDI或R7 EDI DI DIL Destination Index，指向指令流操作中的目标。 RBP或R5 EBP BP BPL Stack Base Pointer，指向栈的基地址。 RSP或R4 ESP SP SPL Stack Pointer，指向栈顶的地址。 R8 R8D R8W R8B 无别名。 R9 R9D R9W R9B 无别名。 R10 R10D R10W R10B 无别名。 R11 R11D R11W R11B 无别名。 R12 R12D R12W R12B 无别名。 R13 R13D R13W R13B 无别名。 R14 R14D R14W R14B 无别名。 R15 R15D R15W R15B 无别名。 后续还是用 32 位寄存器的名字称呼这些寄存器。</description></item><item><title>一个安卓应用的逆向分析</title><link>https://nnnewb.github.io/blog/p/%E4%B8%80%E4%B8%AA%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</link><pubDate>Tue, 29 Dec 2020 14:04:02 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/%E4%B8%80%E4%B8%AA%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</guid><description>说起来也不算什么新鲜的东西，现成的工具拼拼凑凑就搞定了，单纯算是点亮了新的技能。
待破解应用的名字不透露了，避免引火烧身。
需要准备的工具包括
mumu 模拟器(或者别的什么有 root 权限、能装 xposed 的模拟器) FDex2 脱壳 jadx 反编译 dex 源码 apktools 拆解 apk mitmproxy 中间人拦截网络请求 0x01 目标和方向选择 首要的目标是破解这个软件的 api 加密。
使用 mitmproxy 抓到 https 流量，发现请求体全部是 base64 ，解码发现乱码。基本断定是加密了。
mitmproxy 怎么抓 https 流量不多说了，基本流程就是装证书，然后配置代理。能看到有流量进 mitmproxy 就算成功了。
直接参考 mitmproxy 的文档快一点。
01
搜了一圈没有什么现成的对这个 App 的破解的文章，于是决定自己动手。
0x02 解包和脱壳 先确认下电脑上装了 JDK 或者 JRE ，没有的话就装好。
推荐一个 vscode 的插件，apklab。会帮你装好 jadx 和 apktools / signer 这些工具。
接下来直接用 apklab 打开需要破解的 apk 文件。</description></item></channel></rss>