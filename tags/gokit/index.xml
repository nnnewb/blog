<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gokit on weakptr's 笔记</title><link>https://nnnewb.github.io/blog/tags/gokit/</link><description>Recent content in gokit on weakptr's 笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 02 Mar 2022 12:30:00 +0800</lastBuildDate><atom:link href="https://nnnewb.github.io/blog/tags/gokit/index.xml" rel="self" type="application/rss+xml"/><item><title>gokit 架构之我见</title><link>https://nnnewb.github.io/blog/p/my-opinion-of-gokit-architecture/</link><pubDate>Wed, 02 Mar 2022 12:30:00 +0800</pubDate><guid>https://nnnewb.github.io/blog/p/my-opinion-of-gokit-architecture/</guid><description>前言 这是看了 Go kit: the road ahead 之后，对 go kit 这套抽象的一些想法。主要是关于 endpoint 是否有必要、generic 会如何影响 go kit 的架构、go kit 的代码生成这些问题。
endpoint 抽象层是否必要存在 我的看法是需要。原因下面分析。
一个没有额外功能的 Endpoint 其实是起到了把请求类型适配到 Go 函数签名的作用。stringsvc 实现如下。
import ( &amp;#34;context&amp;#34; &amp;#34;github.com/go-kit/kit/endpoint&amp;#34; ) func makeUppercaseEndpoint(svc StringService) endpoint.Endpoint { return func(_ context.Context, request interface{}) (interface{}, error) { req := request.(uppercaseRequest) v, err := svc.Uppercase(req.S) if err != nil { return uppercaseResponse{v, err.Error()}, nil } return uppercaseResponse{v, &amp;#34;&amp;#34;}, nil } } func makeCountEndpoint(svc StringService) endpoint.</description></item></channel></rss>